{
  "api/Hedgehog.AutoGen.DefaultGenerators.html": {
    "href": "api/Hedgehog.AutoGen.DefaultGenerators.html",
    "title": "Class DefaultGenerators | Hedgehog .NET",
    "summary": "Class DefaultGenerators Namespace Hedgehog.AutoGen Assembly Hedgehog.dll type DefaultGenerators = static member Bool : Gen<bool> static member Byte : Gen<byte> static member Char : Gen<char> static member DateTime : Gen<DateTime> static member DateTimeOffset : Gen<DateTimeOffset> static member Decimal : Gen<decimal> static member Dictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<Dictionary<'k, 'v>> static member Double : Gen<double> static member FSharpList : AutoGenContext -> Gen<'a> -> Gen<'a list> static member Guid : Gen<Guid> static member IDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<IDictionary<'k, 'v>> static member IImmutableList : AutoGenContext -> Gen<'a> -> Gen<IImmutableList<'a>> static member IImmutableSet : AutoGenContext -> Gen<'a> -> Gen<IImmutableSet<'a>> static member IList : AutoGenContext -> Gen<'a> -> Gen<IList<'a>> static member IReadOnlyDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<IReadOnlyDictionary<'k, 'v>> static member IReadOnlyList : AutoGenContext -> Gen<'a> -> Gen<IReadOnlyList<'a>> static member ImmutableArray : AutoGenContext -> Gen<'a> -> Gen<ImmutableArray<'a>> static member ImmutableHashSet : AutoGenContext -> Gen<'a> -> Gen<ImmutableHashSet<'a>> static member ImmutableList : AutoGenContext -> Gen<'a> -> Gen<ImmutableList<'a>> static member ImmutableSet : AutoGenContext -> Gen<'a> -> Gen<ImmutableSortedSet<'a>> static member Int16 : Gen<int16> static member Int32 : Gen<int32> static member Int64 : Gen<int64> static member IpAddress : Gen<IPAddress> static member List : AutoGenContext -> Gen<'a> -> Gen<List<'a>> static member Map : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<Map<'k, 'v>> static member Nullable : AutoGenContext -> Gen<'a> -> Gen<Nullable<'a>> static member Option : AutoGenContext -> Gen<'a> -> Gen<'a option> static member ReadOnlyDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<ReadOnlyDictionary<'k, 'v>> static member Seq : AutoGenContext -> Gen<'a> -> Gen<'a seq> static member Set : AutoGenContext -> Gen<'a> -> Gen<Set<'a>> static member Single : Gen<single> static member String : Gen<string> static member UInt16 : Gen<uint16> static member UInt32 : Gen<uint32> static member UInt64 : Gen<uint64> static member Uri : Gen<Uri> DefaultGenerators Methods Bool val Bool : Gen<bool> Byte val Byte : Gen<byte> Char val Char : Gen<char> DateTime val DateTime : Gen<DateTime> DateTimeOffset val DateTimeOffset : Gen<DateTimeOffset> Decimal val Decimal : Gen<decimal> Dictionary val Dictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<Dictionary<'k, 'v>> Double val Double : Gen<double> FSharpList val FSharpList : AutoGenContext -> Gen<'a> -> Gen<'a list> Guid val Guid : Gen<Guid> IDictionary val IDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<IDictionary<'k, 'v>> IImmutableList val IImmutableList : AutoGenContext -> Gen<'a> -> Gen<IImmutableList<'a>> IImmutableSet val IImmutableSet : AutoGenContext -> Gen<'a> -> Gen<IImmutableSet<'a>> IList val IList : AutoGenContext -> Gen<'a> -> Gen<IList<'a>> IReadOnlyDictionary val IReadOnlyDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<IReadOnlyDictionary<'k, 'v>> IReadOnlyList val IReadOnlyList : AutoGenContext -> Gen<'a> -> Gen<IReadOnlyList<'a>> ImmutableArray val ImmutableArray : AutoGenContext -> Gen<'a> -> Gen<ImmutableArray<'a>> ImmutableHashSet val ImmutableHashSet : AutoGenContext -> Gen<'a> -> Gen<ImmutableHashSet<'a>> ImmutableList val ImmutableList : AutoGenContext -> Gen<'a> -> Gen<ImmutableList<'a>> ImmutableSet val ImmutableSet : AutoGenContext -> Gen<'a> -> Gen<ImmutableSortedSet<'a>> Int16 val Int16 : Gen<int16> Int32 val Int32 : Gen<int32> Int64 val Int64 : Gen<int64> List val List : AutoGenContext -> Gen<'a> -> Gen<List<'a>> Map val Map : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<Map<'k, 'v>> Nullable val Nullable : AutoGenContext -> Gen<'a> -> Gen<Nullable<'a>> Option val Option : AutoGenContext -> Gen<'a> -> Gen<'a option> ReadOnlyDictionary val ReadOnlyDictionary : AutoGenContext -> Gen<'k> -> Gen<'v> -> Gen<ReadOnlyDictionary<'k, 'v>> Seq val Seq : AutoGenContext -> Gen<'a> -> Gen<'a seq> Set val Set : AutoGenContext -> Gen<'a> -> Gen<Set<'a>> Single val Single : Gen<single> String val String : Gen<string> UInt16 val UInt16 : Gen<uint16> UInt32 val UInt32 : Gen<uint32> UInt64 val UInt64 : Gen<uint64> IpAddress val IpAddress : Gen<IPAddress> Uri val Uri : Gen<Uri>"
  },
  "api/Hedgehog.AutoGenConfig.html": {
    "href": "api/Hedgehog.AutoGenConfig.html",
    "title": "Class AutoGenConfig | Hedgehog .NET",
    "summary": "Class AutoGenConfig Namespace Hedgehog Assembly Hedgehog.dll C#-friendly entry points for automatic generator configuration. This module provides compiled names for F# functions to make them more accessible from C#. type AutoGenConfig = member defaults : IAutoGenConfig member empty : IAutoGenConfig AutoGenConfig Methods empty Creates an empty configuration with no custom settings. Use this as a starting point to build a custom configuration. val empty : IAutoGenConfig defaults Creates a default configuration with standard generators for common types. This configuration includes generators for standard collection types such as List, Array, Dictionary, ImmutableList, ImmutableArray, and other common .NET types. Use this as a base configuration and add your own custom generators as needed. val defaults : IAutoGenConfig"
  },
  "api/Hedgehog.AutoGenContext.html": {
    "href": "api/Hedgehog.AutoGenContext.html",
    "title": "Class AutoGenContext | Hedgehog .NET",
    "summary": "Class AutoGenContext Namespace Hedgehog Assembly Hedgehog.dll type AutoGenContext = member AutoGenerate : Gen<'a> member CanRecurse : bool member CollectionRange : Range<int> member CurrentRecursionDepth : int AutoGenContext Methods AutoGenerate val AutoGenerate : Gen<'a> CanRecurse val CanRecurse : bool CollectionRange val CollectionRange : Range<int> CurrentRecursionDepth val CurrentRecursionDepth : int"
  },
  "api/Hedgehog.FSharp.AutoGenConfig.html": {
    "href": "api/Hedgehog.FSharp.AutoGenConfig.html",
    "title": "Class AutoGenConfig | Hedgehog .NET",
    "summary": "Class AutoGenConfig Namespace Hedgehog.FSharp Assembly Hedgehog.dll Functions for configuring automatic generator discovery and registration. This module provides an F#-friendly API for customizing how generators are automatically created for your types. Use these functions to set collection ranges, recursion depth, and register custom generators. type AutoGenConfig = member addGenerator : Gen<'a> -> IAutoGenConfig -> IAutoGenConfig member addGenerators : IAutoGenConfig -> IAutoGenConfig member merge : IAutoGenConfig -> IAutoGenConfig -> IAutoGenConfig member recursionDepth : IAutoGenConfig -> int member seqRange : IAutoGenConfig -> Range<int> member setRecursionDepth : int -> IAutoGenConfig -> IAutoGenConfig member setSeqRange : Range<int> -> IAutoGenConfig -> IAutoGenConfig AutoGenConfig Methods seqRange Gets the collection range from the configuration, or the default if not set. val seqRange : IAutoGenConfig -> Range<int> setSeqRange Sets the range for collection sizes. This controls how many elements are generated when creating collections like lists, arrays, and sets. val setSeqRange : Range<int> -> IAutoGenConfig -> IAutoGenConfig recursionDepth Gets the recursion depth from the configuration, or the default if not set. val recursionDepth : IAutoGenConfig -> int setRecursionDepth Sets the maximum recursion depth for nested type generation. This controls how deeply nested structures can be generated. Use this to prevent infinite recursion when generating recursive data structures or to control the complexity of generated values. val setRecursionDepth : int -> IAutoGenConfig -> IAutoGenConfig merge Merges two configurations, with values from the second configuration taking precedence. This is useful for creating configuration hierarchies where you can have a base configuration and override specific settings with another configuration. val merge : IAutoGenConfig -> IAutoGenConfig -> IAutoGenConfig addGenerator Adds a custom generator for a specific type to the configuration. Use this function to override or provide a generator for a specific type. This is useful when you want to customize how instances of a particular type are generated. val addGenerator : Gen<'a> -> IAutoGenConfig -> IAutoGenConfig addGenerators Registers all generator methods defined in a given type. The type is expected to have static methods that return Gen. These methods can have parameters which will be automatically injected: Hedgehog.AutoGenContext - provides context information such as recursion depth and collection range Hedgehog.IAutoGenConfig - the current auto-generation configuration Hedgehog.Gen1` - other generators that have been registered This enables dependency injection of generators, allowing you to compose complex generators from simpler ones. The system will use reflection to discover methods and automatically wire up their dependencies. Example: // a type containing generators for generic types // methods should return Gen<_> and are allowed to take Gen<_> and AutoGenContext as parameters type GenericGenerators = // Generate generic types static member MyGenericType<'a>(valueGen : Gen<'a>) : Gen<MyGenericType<'a>> = valueGen | Gen.map (fun x -> MyGenericType(x)) // Generate generic types with recursion support and access to AutoGenContext static member ImmutableList<'a>(context: AutoGenContext, valueGen: Gen<'a>) : Gen<ImmutableList<'a>> = if context.CanRecurse then valueGen |> Gen.list context.CollectionRange |> Gen.map ImmutableList.CreateRange else Gen.constant ImmutableList<'a>.Empty // register the generic generators in AutoGenConfig let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<GenericGenerators> 'a val valueGen: obj val context: obj val config: obj type GenericGenerators = static member ImmutableList: context: obj * valueGen: obj -> obj static member MyGenericType: valueGen: obj -> obj val addGenerators : IAutoGenConfig -> IAutoGenConfig"
  },
  "api/Hedgehog.FSharp.Gen.Builder.html": {
    "href": "api/Hedgehog.FSharp.Gen.Builder.html",
    "title": "Class Builder | Hedgehog .NET",
    "summary": "Class Builder Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Builder = member Bind : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b> member BindReturn : Gen<'a> -> 'a -> 'b -> Gen<'b> member Combine : Gen<unit> -> Gen<'a> -> Gen<'a> member Delay : unit -> Gen<'a> -> Gen<'a> member For : 'a seq -> 'a -> Gen<'a0> -> Gen<unit> member MergeSources : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> member Return : 'a -> Gen<'a> member ReturnFrom : Gen<'a> -> Gen<'a> member Zero : Gen<unit> Builder Methods Bind val Bind : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b> BindReturn val BindReturn : Gen<'a> -> 'a -> 'b -> Gen<'b> Combine val Combine : Gen<unit> -> Gen<'a> -> Gen<'a> Delay val Delay : unit -> Gen<'a> -> Gen<'a> For val For : 'a seq -> 'a -> Gen<'a0> -> Gen<unit> MergeSources val MergeSources : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> Return val Return : 'a -> Gen<'a> ReturnFrom val ReturnFrom : Gen<'a> -> Gen<'a> Zero val Zero : Gen<unit>"
  },
  "api/Hedgehog.FSharp.Gen.Operators.html": {
    "href": "api/Hedgehog.FSharp.Gen.Operators.html",
    "title": "Class Operators | Hedgehog .NET",
    "summary": "Class Operators Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Operators = member (<!>) : 'a -> 'b -> Gen<'a> -> Gen<'b> member (<*>) : Gen<('a -> 'b)> -> Gen<'a> -> Gen<'b> member (>>=) : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b> Operators Methods (<!>) val (<!>) : 'a -> 'b -> Gen<'a> -> Gen<'b> (<*>) val (<*>) : Gen<('a -> 'b)> -> Gen<'a> -> Gen<'b> (>>=) val (>>=) : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b>"
  },
  "api/Hedgehog.FSharp.Gen.html": {
    "href": "api/Hedgehog.FSharp.Gen.html",
    "title": "Class Gen | Hedgehog .NET",
    "summary": "Class Gen Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Gen = member addElement : 'a -> Gen<'a list> -> Gen<'a list> member alpha : Gen<char> member alphaNum : Gen<char> member apply : Gen<'a> -> Gen<('a -> 'b)> -> Gen<'b> member array : Range<int> -> Gen<'a> -> Gen<'a array> member ascii : Gen<char> member auto : Gen<'a> member autoWith : IAutoGenConfig -> Gen<'a> member bigint : Range<bigint> -> Gen<bigint> member bind : 'a -> Gen<'b> -> Gen<'a> -> Gen<'b> member bool : Gen<bool> member byte : Range<byte> -> Gen<byte> member char : char -> char -> Gen<char> member choice : Gen<'a> seq -> Gen<'a> member choiceRec : Gen<'a> seq -> Gen<'a> seq -> Gen<'a> member constant : 'a -> Gen<'a> member create : 'a -> 'a seq -> Random<'a> -> Gen<'a> member decimal : Range<decimal> -> Gen<decimal> member delay : unit -> Gen<'a> -> Gen<'a> member digit : Gen<char> member domainName : Gen<string> member double : Range<double> -> Gen<double> member email : Gen<string> member filter : 'a -> bool -> Gen<'a> -> Gen<'a> member frequency : (int * Gen<'a>) seq -> Gen<'a> member generateTree : Gen<'a> -> Tree<'a> member guid : Gen<Guid> member identifier : int -> Gen<string> member int16 : Range<int16> -> Gen<int16> member int32 : Range<int32> -> Gen<int32> member int64 : Range<int64> -> Gen<int64> member integral : Range<^a> -> Gen<^a> member ipAddress : Gen<IPAddress> member ipv4Address : Gen<IPAddress> member ipv6Address : Gen<IPAddress> member item : 'a seq -> Gen<'a> member kebabCase : Range<int> -> Range<int> -> Gen<string> member latin1 : Gen<char> member latinName : int -> Gen<string> member list : Range<int> -> Gen<'a> -> Gen<List<'a>> member lower : Gen<char> member map : 'a -> 'b -> Gen<'a> -> Gen<'b> member map2 : 'a -> 'b -> 'c -> Gen<'a> -> Gen<'b> -> Gen<'c> member map3 : 'a -> 'b -> 'c -> 'd -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> member map4 : 'a -> 'b -> 'c -> 'd -> 'e -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'e> member mapRandom : Random<Tree<'a>> -> Random<Tree<'b>> -> Gen<'a> -> Gen<'b> member mapTree : Tree<'a> -> Tree<'b> -> Gen<'a> -> Gen<'b> member noShrink : Gen<'a> -> Gen<'a> member notContains : 'a -> Gen<'a list> -> Gen<'a list> member notIn : 'a list -> Gen<'a> -> Gen<'a> member notNull : Gen<'a> -> Gen<'a> member ofRandom : Random<Tree<'a>> -> Gen<'a> member option : Gen<'a> -> Gen<'a option> member renderSample : Gen<'a> -> string member resize : int -> Gen<'a> -> Gen<'a> member sample : Size -> int -> Gen<'a> -> 'a seq member sampleTree : Size -> int -> Gen<'a> -> Tree<'a> seq member sbyte : Range<sbyte> -> Gen<sbyte> member scale : int -> int -> Gen<'a> -> Gen<'a> member seq : Range<int> -> Gen<'a> -> Gen<'a seq> member sequence : 'a -> Gen<'a0 seq> member sequenceList : List<Gen<'a>> -> Gen<List<'a>> member shrink : 'a -> List<'a> -> Gen<'a> -> Gen<'a> member shrinkLazy : 'a -> 'a seq -> Gen<'a> -> Gen<'a> member shuffle : 'a list -> Gen<'a list> member shuffleCase : string -> Gen<string> member single : Range<single> -> Gen<single> member sized : Size -> Gen<'a> -> Gen<'a> member snakeCase : Range<int> -> Range<int> -> Gen<string> member some : Gen<'a option> -> Gen<'a> member string : Range<int> -> Gen<char> -> Gen<string> member subsetOf : 'a -> Gen<'T seq> member toRandom : Gen<'a> -> Random<Tree<'a>> member traverse : 'a -> Gen<'b> -> 'a0 -> Gen<'b seq> member traverseList : 'a -> Gen<'b> -> List<'a> -> Gen<List<'b>> member tryFilter : 'a -> bool -> Gen<'a> -> Gen<'a option> member tryFinally : unit -> unit -> Gen<'a> -> Gen<'a> member tryWith : exn -> Gen<'a> -> Gen<'a> -> Gen<'a> member tuple : Gen<'a> -> Gen<'a * 'a> member tuple3 : Gen<'a> -> Gen<'a * 'a * 'a> member tuple4 : Gen<'a> -> Gen<'a * 'a * 'a * 'a> member uint16 : Range<uint16> -> Gen<uint16> member uint32 : Range<uint32> -> Gen<uint32> member uint64 : Range<uint64> -> Gen<uint64> member unicode : Gen<char> member unicodeAll : Gen<char> member upper : Gen<char> member uri : Gen<Uri> member withDistinctMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> member withMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> member withNull : Gen<'a> -> Gen<'a> member zip : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> member zip3 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'a * 'b * 'c> member zip4 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'a * 'b * 'c * 'd> Gen Methods auto Automatically generates a value of the specified type using the default configuration. val auto : Gen<'a> autoWith Automatically generates a value of the specified type using the provided configuration. val autoWith : IAutoGenConfig -> Gen<'a> ofRandom val ofRandom : Random<Tree<'a>> -> Gen<'a> toRandom val toRandom : Gen<'a> -> Random<Tree<'a>> delay val delay : unit -> Gen<'a> -> Gen<'a> tryFinally Ensures a cleanup function runs after a generator executes, even if it throws an exception. val tryFinally : unit -> unit -> Gen<'a> -> Gen<'a> tryWith Catches exceptions thrown by a generator and handles them with a recovery function. val tryWith : exn -> Gen<'a> -> Gen<'a> -> Gen<'a> create val create : 'a -> 'a seq -> Random<'a> -> Gen<'a> constant Create a generator that always yields a constant value. val constant : 'a -> Gen<'a> mapRandom val mapRandom : Random<Tree<'a>> -> Random<Tree<'b>> -> Gen<'a> -> Gen<'b> mapTree val mapTree : Tree<'a> -> Tree<'b> -> Gen<'a> -> Gen<'b> map val map : 'a -> 'b -> Gen<'a> -> Gen<'b> bind val bind : 'a -> Gen<'b> -> Gen<'a> -> Gen<'b> apply val apply : Gen<'a> -> Gen<('a -> 'b)> -> Gen<'b> map2 val map2 : 'a -> 'b -> 'c -> Gen<'a> -> Gen<'b> -> Gen<'c> map3 val map3 : 'a -> 'b -> 'c -> 'd -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> map4 val map4 : 'a -> 'b -> 'c -> 'd -> 'e -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'e> zip val zip : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> zip3 val zip3 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'a * 'b * 'c> zip4 val zip4 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'a * 'b * 'c * 'd> tuple val tuple : Gen<'a> -> Gen<'a * 'a> tuple3 val tuple3 : Gen<'a> -> Gen<'a * 'a * 'a> tuple4 val tuple4 : Gen<'a> -> Gen<'a * 'a * 'a * 'a> noShrink Prevent a 'Gen' from shrinking. val noShrink : Gen<'a> -> Gen<'a> shrinkLazy Apply an additional shrinker to all generated trees. val shrinkLazy : 'a -> 'a seq -> Gen<'a> -> Gen<'a> shrink Apply an additional shrinker to all generated trees. val shrink : 'a -> List<'a> -> Gen<'a> -> Gen<'a> sized Used to construct generators that depend on the size parameter. val sized : Size -> Gen<'a> -> Gen<'a> resize Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. val resize : int -> Gen<'a> -> Gen<'a> scale Adjust the size parameter, by transforming it with the given function. val scale : int -> int -> Gen<'a> -> Gen<'a> integral Generates a random number in the given inclusive range. val integral : Range<^a> -> Gen<^a> item Randomly selects one of the values in the list. The input list must be non-empty. val item : 'a seq -> Gen<'a> frequency Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. val frequency : (int * Gen<'a>) seq -> Gen<'a> choice Randomly selects one of the gens in the list. The input list must be non-empty. val choice : Gen<'a> seq -> Gen<'a> choiceRec Randomly selects from one of the gens in either the non-recursive or the recursive list. When a selection is made from the recursive list, the size is halved. When the size gets to one or less, selections are no longer made from the recursive list. The first argument (i.e. the non-recursive input list) must be non-empty. val choiceRec : Gen<'a> seq -> Gen<'a> seq -> Gen<'a> filter Generates a value that satisfies a predicate. val filter : 'a -> bool -> Gen<'a> -> Gen<'a> tryFilter Tries to generate a value that satisfies a predicate. val tryFilter : 'a -> bool -> Gen<'a> -> Gen<'a option> some Runs an option generator until it produces a 'Some'. val some : Gen<'a option> -> Gen<'a> option Generates a 'None' or a 'Some'. 'None' becomes less common with larger Sizes. val option : Gen<'a> -> Gen<'a option> list Generates a list using a 'Range' to determine the length and a 'Gen' to produce the elements. val list : Range<int> -> Gen<'a> -> Gen<List<'a>> array Generates an array using a 'Range' to determine the length. val array : Range<int> -> Gen<'a> -> Gen<'a array> seq Generates an enumerable using a 'Range' to determine the length. val seq : Range<int> -> Gen<'a> -> Gen<'a seq> withNull Generates null part of the time. val withNull : Gen<'a> -> Gen<'a> notNull Generates a value that is not null. val notNull : Gen<'a> -> Gen<'a> sampleTree val sampleTree : Size -> int -> Gen<'a> -> Tree<'a> seq sample Returns a seq of values produced by the generator. val sample : Size -> int -> Gen<'a> -> 'a seq generateTree Run a generator. The size passed to the generator is always 30; if you want another size then you should explicitly use 'resize'. val generateTree : Gen<'a> -> Tree<'a> renderSample Samples the gen 5 times with a Size of 10, called the \"Outcome\" in the returned string. Then the shrink path to each Outcome is produced. This may be useful in debugging shrink paths in complex Gens. val renderSample : Gen<'a> -> string notIn val notIn : 'a list -> Gen<'a> -> Gen<'a> notContains Generates a list that does not contain the specified element. Shortcut for Gen.filter (not << List.contains x). val notContains : 'a -> Gen<'a list> -> Gen<'a list> addElement Inserts the given element at a random place in the list. val addElement : 'a -> Gen<'a list> -> Gen<'a list> identifier Generates a random identifier string that starts with a lowercase letter, followed by alphanumeric characters or underscores, up to the specified maximum length. val identifier : int -> Gen<string> snakeCase Generates a snake_case string composed of random words of specified lengths and counts. val snakeCase : Range<int> -> Range<int> -> Gen<string> kebabCase Generates a kebab-case string composed of random words of specified lengths and counts. val kebabCase : Range<int> -> Range<int> -> Gen<string> latinName Generates a Latin-style name starting with an uppercase letter followed by lowercase letters, val latinName : int -> Gen<string> withMapTo Generates a list using inpGen together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list may map to the same output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'] or ['A'; 'A'; 'A'], but never ['A'; 'B'; 'C']. The generated function throws if called with values not present in the input list. val withMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> withDistinctMapTo Generates a list using inpGen together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list are guaranteed to map to distinct output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'], but never ['A'; 'A'; 'A'] or ['A'; 'B'; 'C']. Only use this if the output space is large enough that the required number of distinct output values are likely to be generated. The generated function throws if called with values not present in the input list. val withDistinctMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> char Generates a random character in the given range. val char : char -> char -> Gen<char> unicodeAll Generates a Unicode character, including invalid standalone surrogates, i.e. from '\\000' to '\\65535'. val unicodeAll : Gen<char> digit Generates a random numerical character, i.e. from '0' to '9'. Example: Combine with string to create strings of a desired length. Gen.digit |> Gen.string (Range.constant 5 10) val digit : Gen<char> lower Generates a random lowercase character, i.e. from 'a' to 'z'. Example: Combine with string to create strings of a desired length. Gen.lower |> Gen.string (Range.constant 5 10) val lower : Gen<char> upper Generates a random uppercase character, i.e. from 'A' to 'Z'. Example: Combine with string to create strings of a desired length. Gen.upper |> Gen.string (Range.constant 5 10) val upper : Gen<char> ascii Generates a random ASCII character, i.e. from '\\000' to '\\127', i.e. any 7 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with string to create strings of a desired length. Gen.ascii |> Gen.string (Range.constant 5 10) val ascii : Gen<char> latin1 Generates a random Latin-1 character, i.e. from '\\000' to '\\255', i.e. any 8 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with string to create strings of a desired length. Gen.latin1 |> Gen.string (Range.constant 5 10) val latin1 : Gen<char> unicode Generates a Unicode character, excluding non-characters ('\\65534' and '\\65535') and invalid standalone surrogates (from '\\55296' to '\\57343'). Example: Combine with string to create strings of a desired length. Gen.unicode |> Gen.string (Range.constant 5 10) val unicode : Gen<char> alpha Generates an alphabetic character, i.e. 'a' to 'z' or 'A' to 'Z'. Example: Combine with string to create strings of a desired length. Gen.alpha |> Gen.string (Range.constant 5 10) This generates strings such as Ldklk or aFDG val alpha : Gen<char> alphaNum Generates an alphanumeric character, i.e. 'a' to 'z', 'A' to 'Z', or '0' to '9'. Example: Combine with string to create strings of a desired length. Gen.alphaNum |> Gen.string (Range.constant 5 10) This generates strings such as Ld5lk or 4dFDG val alphaNum : Gen<char> string Generates a random string using 'Range' to determine the length and the given character generator. val string : Range<int> -> Gen<char> -> Gen<string> bool Generates a random boolean. val bool : Gen<bool> byte Generates a random byte. val byte : Range<byte> -> Gen<byte> sbyte Generates a random signed byte. val sbyte : Range<sbyte> -> Gen<sbyte> int16 Generates a random signed 16-bit integer. val int16 : Range<int16> -> Gen<int16> uint16 Generates a random unsigned 16-bit integer. val uint16 : Range<uint16> -> Gen<uint16> int32 Generates a random signed 32-bit integer. val int32 : Range<int32> -> Gen<int32> uint32 Generates a random unsigned 32-bit integer. val uint32 : Range<uint32> -> Gen<uint32> int64 Generates a random signed 64-bit integer. val int64 : Range<int64> -> Gen<int64> uint64 Generates a random unsigned 64-bit integer. val uint64 : Range<uint64> -> Gen<uint64> double Generates a random 64-bit floating point number. val double : Range<double> -> Gen<double> single Generates a random 32-bit floating point number. val single : Range<single> -> Gen<single> decimal Generates a random decimal floating-point number. val decimal : Range<decimal> -> Gen<decimal> bigint Generates a random big integer. val bigint : Range<bigint> -> Gen<bigint> guid Generates a random globally unique identifier. val guid : Gen<Guid> shuffle Generates a permutation of the given list. val shuffle : 'a list -> Gen<'a list> shuffleCase Shuffles the case of the given string. val shuffleCase : string -> Gen<string> subsetOf Generates the subset of the provided items. The generated subset will be in the same order as the input items. val subsetOf : 'a -> Gen<'T seq> traverse Apply a generator-producing function to each element and collect the results. val traverse : 'a -> Gen<'b> -> 'a0 -> Gen<'b seq> sequence Turn a sequence of generators into a generator of a sequence. val sequence : 'a -> Gen<'a0 seq> traverseList Apply a generator-producing function to each list element and collect the results. val traverseList : 'a -> Gen<'b> -> List<'a> -> Gen<List<'b>> sequenceList Turn a list of generators into a generator of a list. val sequenceList : List<Gen<'a>> -> Gen<List<'a>> domainName Generates a random valid domain name. val domainName : Gen<string> uri Generates a random URI. val uri : Gen<Uri> ipv4Address Generates a random IPv4 address. val ipv4Address : Gen<IPAddress> ipv6Address Generates a random IPv6 address. val ipv6Address : Gen<IPAddress> ipAddress Generates a random IP address (either IPv4 or IPv6) with a higher chance of generating an IPv4 address. val ipAddress : Gen<IPAddress> email Generates a random email address. val email : Gen<string>"
  },
  "api/Hedgehog.FSharp.Property.html": {
    "href": "api/Hedgehog.FSharp.Property.html",
    "title": "Class Property | Hedgehog .NET",
    "summary": "Class Property Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Property = member bind : 'a -> Property<'b> -> Property<'a> -> Property<'b> member bindReturnWith : 'a -> Journal -> 'a -> 'b -> Gen<'a> -> Property<'b> member bindWith : 'a -> Journal -> 'a -> Property<'b> -> Gen<'a> -> Property<'b> member check : Property<unit> -> unit member checkBool : Property<bool> -> unit member checkBoolWith : IPropertyConfig -> Property<bool> -> unit member checkWith : IPropertyConfig -> Property<unit> -> unit member counterexample : unit -> string -> Property<unit> member delay : unit -> Property<'a> -> Property<'a> member discard : Property<unit> member failure : Property<unit> member falseToFailure : Property<bool> -> Property<unit> member filter : 'a -> bool -> Property<'a> -> Property<'a> member forAll : 'a -> Property<'b> -> Gen<'a> -> Property<'b> member forAll' : Gen<'a> -> Property<'a> member map : 'a -> 'b -> Property<'a> -> Property<'b> member ofBool : bool -> Property<unit> member ofGen : Gen<Lazy<Journal * Outcome<'a>>> -> Property<'a> member ofOutcome : Outcome<'a> -> Property<'a> member recheck : string -> Property<unit> -> unit member recheckBool : string -> Property<bool> -> unit member recheckBoolWith : string -> IPropertyConfig -> Property<bool> -> unit member recheckWith : string -> IPropertyConfig -> Property<unit> -> unit member render : Property<unit> -> string member renderBool : Property<bool> -> string member renderBoolWith : IPropertyConfig -> Property<bool> -> string member renderWith : IPropertyConfig -> Property<unit> -> string member report : Property<unit> -> Report member reportBool : Property<bool> -> Report member reportBoolWith : IPropertyConfig -> Property<bool> -> Report member reportRecheck : string -> Property<unit> -> Report member reportRecheckBool : string -> Property<bool> -> Report member reportRecheckBoolWith : string -> IPropertyConfig -> Property<bool> -> Report member reportRecheckWith : string -> IPropertyConfig -> Property<unit> -> Report member reportWith : IPropertyConfig -> Property<unit> -> Report member success : 'a -> Property<'a> member toGen : Property<'a> -> Gen<Lazy<Journal * Outcome<'a>>> member tryFinally : unit -> unit -> Property<'a> -> Property<'a> member tryWith : exn -> Property<'a> -> Property<'a> -> Property<'a> member using : 'a -> 'a -> Property<'b> -> Property<'b> Property Methods ofGen val ofGen : Gen<Lazy<Journal * Outcome<'a>>> -> Property<'a> toGen val toGen : Property<'a> -> Gen<Lazy<Journal * Outcome<'a>>> tryFinally val tryFinally : unit -> unit -> Property<'a> -> Property<'a> tryWith val tryWith : exn -> Property<'a> -> Property<'a> -> Property<'a> delay val delay : unit -> Property<'a> -> Property<'a> using val using : 'a -> 'a -> Property<'b> -> Property<'b> filter val filter : 'a -> bool -> Property<'a> -> Property<'a> ofOutcome val ofOutcome : Outcome<'a> -> Property<'a> failure val failure : Property<unit> discard val discard : Property<unit> success val success : 'a -> Property<'a> ofBool val ofBool : bool -> Property<unit> counterexample val counterexample : unit -> string -> Property<unit> map val map : 'a -> 'b -> Property<'a> -> Property<'b> bind Monadic bind operation for properties. Applies a property-returning function to the result of another property, sequencing their execution and combining their journals. val bind : 'a -> Property<'b> -> Property<'a> -> Property<'b> bindWith Binds a generator to a property-returning function while adding custom journal entries. This allows you to add contextual information (like formatted parameter names and values) that will appear in test failure reports before the property's own journal entries. Use this when the property function returns Property<'b> and you want to enhance the failure output with information about the generated input values. val bindWith : 'a -> Journal -> 'a -> Property<'b> -> Gen<'a> -> Property<'b> bindReturnWith Binds a generator to a value-returning function while adding custom journal entries. This allows you to add contextual information (like formatted parameter names and values) that will appear in test failure reports. The function's return value is automatically checked for success (e.g., awaiting tasks, validating booleans/Results, handling exceptions). Use this for test functions that don't return Property<'b> - instead they return plain values, Task, Async, bool, Result, etc. The function is wrapped with exception handling via Property.map. val bindReturnWith : 'a -> Journal -> 'a -> 'b -> Gen<'a> -> Property<'b> falseToFailure val falseToFailure : Property<bool> -> Property<unit> forAll val forAll : 'a -> Property<'b> -> Gen<'a> -> Property<'b> forAll' val forAll' : Gen<'a> -> Property<'a> reportWith val reportWith : IPropertyConfig -> Property<unit> -> Report report val report : Property<unit> -> Report reportBoolWith val reportBoolWith : IPropertyConfig -> Property<bool> -> Report reportBool val reportBool : Property<bool> -> Report checkWith val checkWith : IPropertyConfig -> Property<unit> -> unit check val check : Property<unit> -> unit checkBool val checkBool : Property<bool> -> unit checkBoolWith val checkBoolWith : IPropertyConfig -> Property<bool> -> unit reportRecheckWith val reportRecheckWith : string -> IPropertyConfig -> Property<unit> -> Report reportRecheck val reportRecheck : string -> Property<unit> -> Report reportRecheckBoolWith val reportRecheckBoolWith : string -> IPropertyConfig -> Property<bool> -> Report reportRecheckBool val reportRecheckBool : string -> Property<bool> -> Report recheckWith val recheckWith : string -> IPropertyConfig -> Property<unit> -> unit recheck val recheck : string -> Property<unit> -> unit recheckBoolWith val recheckBoolWith : string -> IPropertyConfig -> Property<bool> -> unit recheckBool val recheckBool : string -> Property<bool> -> unit renderWith val renderWith : IPropertyConfig -> Property<unit> -> string render val render : Property<unit> -> string renderBool val renderBool : Property<bool> -> string renderBoolWith val renderBoolWith : IPropertyConfig -> Property<bool> -> string"
  },
  "api/Hedgehog.FSharp.PropertyBuilder.Builder.html": {
    "href": "api/Hedgehog.FSharp.PropertyBuilder.Builder.html",
    "title": "Class Builder | Hedgehog .NET",
    "summary": "Class Builder Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Builder = member Bind : Gen<'a> -> 'a -> Property<'b> -> Property<'b> member BindReturn : Gen<'a> -> 'a -> 'b -> Property<'b> member Combine : Property<unit> -> Property<'a> -> Property<'a> member Counterexample : 'a -> string -> Property<'a> member Delay : unit -> Property<'a> -> Property<'a> member For : 'a -> 'a0 -> Property<unit> -> Property<unit> member For : Property<'a> -> 'a -> Property<'b> -> Property<'b> member MergeSources : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> member Return : bool -> Property<unit> member ReturnFrom : Property<'a> -> Property<'a> member TryFinally : Property<'a> -> unit -> unit -> Property<'a> member TryWith : Property<'a> -> exn -> Property<'a> -> Property<'a> member Using : 'a -> 'a -> Property<'b> -> Property<'b> member Where : 'a -> bool -> Property<'a> member While : unit -> bool -> Property<unit> -> Property<unit> member Yield : 'a -> Property<'a> member Zero : Property<unit> Builder Methods Bind val Bind : Gen<'a> -> 'a -> Property<'b> -> Property<'b> BindReturn val BindReturn : Gen<'a> -> 'a -> 'b -> Property<'b> Combine val Combine : Property<unit> -> Property<'a> -> Property<'a> Counterexample val Counterexample : 'a -> string -> Property<'a> Delay val Delay : unit -> Property<'a> -> Property<'a> For val For : 'a -> 'a0 -> Property<unit> -> Property<unit> For val For : Property<'a> -> 'a -> Property<'b> -> Property<'b> MergeSources val MergeSources : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> Return val Return : bool -> Property<unit> ReturnFrom val ReturnFrom : Property<'a> -> Property<'a> TryFinally val TryFinally : Property<'a> -> unit -> unit -> Property<'a> TryWith val TryWith : Property<'a> -> exn -> Property<'a> -> Property<'a> Using val Using : 'a -> 'a -> Property<'b> -> Property<'b> Where val Where : 'a -> bool -> Property<'a> While val While : unit -> bool -> Property<unit> -> Property<unit> Yield val Yield : 'a -> Property<'a> Zero val Zero : Property<unit>"
  },
  "api/Hedgehog.FSharp.Random.html": {
    "href": "api/Hedgehog.FSharp.Random.html",
    "title": "Class Random | Hedgehog .NET",
    "summary": "Class Random Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Random = member bind : 'a -> Random<'b> -> Random<'a> -> Random<'b> member constant : 'a -> Random<'a> member delay : unit -> Random<'a> -> Random<'a> member double : Range<double> -> Random<double> member integral : Range<^a> -> Random<^a> member map : 'a -> 'b -> Random<'a> -> Random<'b> member replicate : int -> Random<'a> -> Random<'a seq> member resize : Size -> Random<'a> -> Random<'a> member run : Seed -> Size -> Random<'a> -> 'a member sized : Size -> Random<'a> -> Random<'a> member tryFinally : unit -> unit -> Random<'a> -> Random<'a> member tryWith : exn -> Random<'a> -> Random<'a> -> Random<'a> Random Methods run val run : Seed -> Size -> Random<'a> -> 'a delay val delay : unit -> Random<'a> -> Random<'a> tryFinally val tryFinally : unit -> unit -> Random<'a> -> Random<'a> tryWith val tryWith : exn -> Random<'a> -> Random<'a> -> Random<'a> constant val constant : 'a -> Random<'a> map val map : 'a -> 'b -> Random<'a> -> Random<'b> bind val bind : 'a -> Random<'b> -> Random<'a> -> Random<'b> replicate val replicate : int -> Random<'a> -> Random<'a seq> sized Used to construct generators that depend on the size parameter. val sized : Size -> Random<'a> -> Random<'a> resize Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. val resize : Size -> Random<'a> -> Random<'a> integral Generates a random integral number in the given inclusive range. val integral : Range<^a> -> Random<^a> double Generates a random floating point number in the given inclusive range. val double : Range<double> -> Random<double>"
  },
  "api/Hedgehog.FSharp.Range.html": {
    "href": "api/Hedgehog.FSharp.Range.html",
    "title": "Class Range | Hedgehog .NET",
    "summary": "Class Range Namespace Hedgehog.FSharp Assembly Hedgehog.dll type Range = member bounds : Size -> Range<'a> -> 'a * 'a member constant : 'a -> 'a -> Range<'a> member constantBounded : unit -> Range<^a> member constantFrom : 'a -> 'a -> 'a -> Range<'a> member exponential : ^a -> ^a -> Range<^a> member exponentialBounded : unit -> Range<^a> member exponentialFrom : ^a -> ^a -> ^a -> Range<^a> member linear : ^a -> ^a -> Range<^a> member linearBounded : unit -> Range<^a> member linearFrom : ^a -> ^a -> ^a -> Range<^a> member lowerBound : Size -> Range<'a> -> 'a member map : 'a -> 'b -> Range<'a> -> Range<'b> member origin : Range<'a> -> 'a member singleton : 'a -> Range<'a> member upperBound : Size -> Range<'a> -> 'a Range Methods origin Get the origin of a range. This might be the mid-point or the lower bound, depending on what the range represents. The 'bounds' of a range are scaled around this value when using the 'linear' family of combinators. When using a 'Range' to generate numbers, the shrinking function will shrink towards the origin. val origin : Range<'a> -> 'a map Map a modification function over a Range. val map : 'a -> 'b -> Range<'a> -> Range<'b> bounds Get the extents of a range, for a given size. val bounds : Size -> Range<'a> -> 'a * 'a lowerBound Get the lower bound of a range for the given size. val lowerBound : Size -> Range<'a> -> 'a upperBound Get the upper bound of a range for the given size. val upperBound : Size -> Range<'a> -> 'a singleton Construct a range which represents a constant single value. val singleton : 'a -> Range<'a> constantFrom Construct a range which is unaffected by the size parameter with a origin point which may differ from the bounds. val constantFrom : 'a -> 'a -> 'a -> Range<'a> constant Construct a range which is unaffected by the size parameter. val constant : 'a -> 'a -> Range<'a> constantBounded Construct a range which is unaffected by the size parameter using the full range of a data type. val constantBounded : unit -> Range<^a> linearFrom Construct a range which scales the bounds relative to the size parameter. val linearFrom : ^a -> ^a -> ^a -> Range<^a> linear Construct a range which scales the second bound relative to the size parameter. val linear : ^a -> ^a -> Range<^a> linearBounded Construct a range which is scaled relative to the size parameter and uses the full range of a data type. val linearBounded : unit -> Range<^a> exponentialFrom Construct a range which scales the bounds exponentially relative to the size parameter. val exponentialFrom : ^a -> ^a -> ^a -> Range<^a> exponential Construct a range which scales the second bound exponentially relative to the size parameter. val exponential : ^a -> ^a -> Range<^a> exponentialBounded Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. val exponentialBounded : unit -> Range<^a>"
  },
  "api/Hedgehog.FailureData.html": {
    "href": "api/Hedgehog.FailureData.html",
    "title": "Class FailureData | Hedgehog .NET",
    "summary": "Class FailureData Namespace Hedgehog Assembly Hedgehog.dll type FailureData FailureData"
  },
  "api/Hedgehog.FromBigInt.html": {
    "href": "api/Hedgehog.FromBigInt.html",
    "title": "Class FromBigInt | Hedgehog .NET",
    "summary": "Class FromBigInt Namespace Hedgehog Assembly Hedgehog.dll type FromBigInt = static member FromBigInt : unativeint -> FromBigInt -> bigint -> unativeint static member FromBigInt : nativeint -> FromBigInt -> bigint -> nativeint static member FromBigInt : decimal -> FromBigInt -> bigint -> decimal static member FromBigInt : double -> FromBigInt -> bigint -> double static member FromBigInt : single -> FromBigInt -> bigint -> single static member FromBigInt : int64 -> FromBigInt -> bigint -> int64 static member FromBigInt : int32 -> FromBigInt -> bigint -> int32 static member FromBigInt : int16 -> FromBigInt -> bigint -> int16 static member FromBigInt : int8 -> FromBigInt -> bigint -> int8 static member FromBigInt : uint64 -> FromBigInt -> bigint -> uint64 static member FromBigInt : uint32 -> FromBigInt -> bigint -> uint32 static member FromBigInt : uint16 -> FromBigInt -> bigint -> uint16 static member FromBigInt : uint8 -> FromBigInt -> bigint -> uint8 static member FromBigInt : bigint -> FromBigInt -> bigint -> bigint static member Invoke : bigint -> ^Num FromBigInt Methods FromBigInt val FromBigInt : unativeint -> FromBigInt -> bigint -> unativeint FromBigInt val FromBigInt : nativeint -> FromBigInt -> bigint -> nativeint FromBigInt val FromBigInt : decimal -> FromBigInt -> bigint -> decimal FromBigInt val FromBigInt : double -> FromBigInt -> bigint -> double FromBigInt val FromBigInt : single -> FromBigInt -> bigint -> single FromBigInt val FromBigInt : int64 -> FromBigInt -> bigint -> int64 FromBigInt val FromBigInt : int32 -> FromBigInt -> bigint -> int32 FromBigInt val FromBigInt : int16 -> FromBigInt -> bigint -> int16 FromBigInt val FromBigInt : int8 -> FromBigInt -> bigint -> int8 FromBigInt val FromBigInt : uint64 -> FromBigInt -> bigint -> uint64 FromBigInt val FromBigInt : uint32 -> FromBigInt -> bigint -> uint32 FromBigInt val FromBigInt : uint16 -> FromBigInt -> bigint -> uint16 FromBigInt val FromBigInt : uint8 -> FromBigInt -> bigint -> uint8 FromBigInt val FromBigInt : bigint -> FromBigInt -> bigint -> bigint Invoke val Invoke : bigint -> ^Num"
  },
  "api/Hedgehog.GenDateTime.Gen.html": {
    "href": "api/Hedgehog.GenDateTime.Gen.html",
    "title": "Class Gen | Hedgehog .NET",
    "summary": "Class Gen Namespace Hedgehog Assembly Hedgehog.dll type Gen = member dateTime : Range<DateTime> -> Gen<DateTime> member dateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> member timeSpan : Range<TimeSpan> -> Gen<TimeSpan> Gen Methods dateTime Generates a random DateTime using the given range. Example: let range = Range.constantFrom (DateTime (2000, 1, 1)) DateTime.MinValue DateTime.MaxValue Gen.dateTime range val range: obj val dateTime : Range<DateTime> -> Gen<DateTime> dateTimeOffset Generates a random DateTimeOffset using the given range. val dateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> timeSpan Generates a random TimeSpan using the specified range. val timeSpan : Range<TimeSpan> -> Gen<TimeSpan>"
  },
  "api/Hedgehog.Gen_a_.html": {
    "href": "api/Hedgehog.Gen_a_.html",
    "title": "Class Gen<'a> | Hedgehog .NET",
    "summary": "Class Gen<'a> Namespace Hedgehog Assembly Hedgehog.dll A generator for values and shrink trees of type 'a. type Gen<'a> Gen<'a>"
  },
  "api/Hedgehog.IAutoGenConfig.html": {
    "href": "api/Hedgehog.IAutoGenConfig.html",
    "title": "Class IAutoGenConfig | Hedgehog .NET",
    "summary": "Class IAutoGenConfig Namespace Hedgehog Assembly Hedgehog.dll Configuration for automatic generator discovery and registration. This interface provides settings that control how generators are automatically created for custom types. It manages collection size ranges, recursion depth limits, and registered custom generators. type IAutoGenConfig IAutoGenConfig"
  },
  "api/Hedgehog.IPropertyConfig.html": {
    "href": "api/Hedgehog.IPropertyConfig.html",
    "title": "Class IPropertyConfig | Hedgehog .NET",
    "summary": "Class IPropertyConfig Namespace Hedgehog Assembly Hedgehog.dll type IPropertyConfig IPropertyConfig"
  },
  "api/Hedgehog.Journal.html": {
    "href": "api/Hedgehog.Journal.html",
    "title": "Class Journal | Hedgehog .NET",
    "summary": "Class Journal Namespace Hedgehog Assembly Hedgehog.dll type Journal = member append : Journal -> Journal -> Journal member empty : Journal member eval : Journal -> string seq member ofSeq : (unit -> string) seq -> Journal member singleton : unit -> string -> Journal member singletonMessage : string -> Journal Journal Methods ofSeq Creates a journal from a sequence of entries. val ofSeq : (unit -> string) seq -> Journal eval Evaluates all entries in the journal, returning their messages. val eval : Journal -> string seq empty Represents a journal with no entries. val empty : Journal singletonMessage Creates a single entry journal from a given message. val singletonMessage : string -> Journal singleton Creates a single entry journal from a given entry. val singleton : unit -> string -> Journal append Creates a journal composed of entries from two journals. val append : Journal -> Journal -> Journal"
  },
  "api/Hedgehog.Language.html": {
    "href": "api/Hedgehog.Language.html",
    "title": "Class Language | Hedgehog .NET",
    "summary": "Class Language Namespace Hedgehog Assembly Hedgehog.dll type Language Language"
  },
  "api/Hedgehog.Linq.AutoGenExtensions.html": {
    "href": "api/Hedgehog.Linq.AutoGenExtensions.html",
    "title": "Class AutoGenExtensions | Hedgehog .NET",
    "summary": "Class AutoGenExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll Extension methods for IAutoGenConfig to support fluent API for C#. This class provides a C#-friendly interface for configuring automatic generator discovery and registration. Use these methods to customize how generators are created for your custom types when using Auto.Gen (). public class AutoGenExtensions { public static IAutoGenConfig AddGenerator(this IAutoGenConfig self, Gen<T> generator) public static IAutoGenConfig AddGenerators(this IAutoGenConfig self) public static Range<int> GetCollectionRange(this IAutoGenConfig self) public static int GetRecursionDepth(IAutoGenConfig self) public static IAutoGenConfig SetCollectionRange(this IAutoGenConfig self, Range<int> range) public static IAutoGenConfig SetRecursionDepth(this IAutoGenConfig self, int depth) } AutoGenExtensions Methods AddGenerator(IAutoGenConfig, Gen) Registers a custom generator for type T. Use this method to override or provide a generator for a specific type. This is useful when you want to customize how instances of a particular type are generated. public static IAutoGenConfig AddGenerator(this IAutoGenConfig self, Gen<T> generator) AddGenerators(IAutoGenConfig) Registers all generator methods defined in a given type. The type is expected to have static methods returning Gen . These methods can take parameters that will be automatically injected: Hedgehog.AutoGenContext - provides context information such as recursion depth and collection range Hedgehog.IAutoGenConfig - the current auto-generation configuration Hedgehog.Gen&lt;U&gt; - other generators that have been registered for type U This enables dependency injection of generators, allowing you to compose complex generators from simpler ones. Example: public sealed class MyGenerators { public static Gen<ImmutableList<T>> ImmutableListGen<T>( AutoGenContext ctx, // context can be injected Gen<T> valueGen // value generator is injected ) { if (ctx.CanRecurse) // if recursion is possible then construct a list of values // respecting the configured collection range return valueGen.List(ctx.CollectionRange).Select(ImmutableList.CreateRange); else // cannot recurse anymore, return the base case return ImmutableList.Empty<T>(); } } public static IAutoGenConfig AddGenerators(this IAutoGenConfig self) GetCollectionRange(IAutoGenConfig) Gets the currently configured collection range. public static Range<int> GetCollectionRange(this IAutoGenConfig self) GetRecursionDepth(IAutoGenConfig) Gets the currently configured recursion depth. public static int GetRecursionDepth(IAutoGenConfig self) SetCollectionRange(IAutoGenConfig, Range) Sets the range for collection sizes when generating collections (lists, arrays, sets, etc.). This setting controls how many elements are generated when creating collections. The default range is exponential from 0 to 50. Use this to generate smaller or larger collections as needed. public static IAutoGenConfig SetCollectionRange(this IAutoGenConfig self, Range<int> range) SetRecursionDepth(IAutoGenConfig, int) Sets the maximum recursion depth for nested type generation. This controls how deeply nested structures can be generated. A depth of 0 means no recursion is allowed. A depth of 1 allows one level of recursion, and so on. Use this to prevent infinite recursion when generating recursive data structures or to control the complexity of generated values. Higher values create more complex nested structures. public static IAutoGenConfig SetRecursionDepth(this IAutoGenConfig self, int depth)"
  },
  "api/Hedgehog.Linq.Gen.html": {
    "href": "api/Hedgehog.Linq.Gen.html",
    "title": "Class Gen | Hedgehog .NET",
    "summary": "Class Gen Namespace Hedgehog.Linq Assembly Hedgehog.dll public class Gen { public static Gen<char> Alpha() public static Gen<char> AlphaNumeric() public static Gen<char> Ascii() public static Gen<T> Auto() public static Gen<T> AutoWith(IAutoGenConfig config) public static Gen<bool> Bool() public static Gen<byte> Byte(Range<byte> range) public static Gen<char> Char(char lo, char hi) public static Gen<T> Choice(Gen<T> array gens) public static Gen<T> ChoiceRecursive(Gen<T>IEnumerable nonrecs, Gen<T>IEnumerable recs) public static Gen<T> Constant(T value) public static Gen<T> Create(Func<T, TIEnumerable> shrink, Random<T> random) public static Gen<DateTime> DateTime(Range<DateTime> range) public static Gen<DateTimeOffset> DateTimeOffset(Range<DateTimeOffset> range) public static Gen<decimal> Decimal(Range<decimal> range) public static Gen<T> Delay(Func<Gen<T>> func) public static Gen<char> Digit() public static Gen<string> DomainName() public static Gen<double> Double(Range<double> range) public static Gen<string> Email() public static Gen<T> Frequency(((int, Gen)<T>) array values) public static Gen<T> Frequency(((int, Gen)<T>) array gens) public static Gen<T> FromRandom(Random<Tree<T>> random) public static Gen<T> FromValue(T value) public static Gen<Guid> Guid() public static Gen<string> Identifier(int maxLen) public static Gen<int16> Int16(Range<int16> range) public static Gen<int32> Int32(Range<int32> range) public static Gen<int64> Int64(Range<int64> range) public static Gen<decimal> Integral(Range<decimal> range) public static Gen<double> Integral(Range<double> range) public static Gen<uint64> Integral(Range<uint64> range) public static Gen<int64> Integral(Range<int64> range) public static Gen<uint32> Integral(Range<uint32> range) public static Gen<int32> Integral(Range<int32> range) public static Gen<uint16> Integral(Range<uint16> range) public static Gen<int16> Integral(Range<int16> range) public static Gen<sbyte> Integral(Range<sbyte> range) public static Gen<byte> Integral(Range<byte> range) public static Gen<IPAddress> IpAddress() public static Gen<IPAddress> Ipv4Address() public static Gen<IPAddress> Ipv6Address() public static Gen<T> Item(T array items) public static Gen<string> KebabCase(int maxWordLength, int maxWordsCount) public static Gen<string> KebabCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<char> Latin1() public static Gen<string> LatinName(int maxLength) public static Gen<char> Lower() public static Gen<sbyte> SByte(Range<sbyte> range) public static Gen<TIEnumerable> Shuffle(TIEnumerable items) public static Gen<string> ShuffleCase(string value) public static Gen<single> Single(Range<single> range) public static Gen<T> Sized(Func<Size, Gen<T>> scaler) public static Gen<string> SnakeCase(int maxWordLength, int maxWordsCount) public static Gen<string> SnakeCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<TIEnumerable> SubsetOf(TIEnumerable items) public static Gen<uint16> UInt16(Range<uint16> range) public static Gen<uint32> UInt32(Range<uint32> range) public static Gen<uint64> UInt64(Range<uint64> range) public static Gen<char> Unicode() public static Gen<char> UnicodeAll() public static Gen<char> Upper() public static Gen<Uri> Uri() } Gen Methods Auto Create a generator that automatically generates values of the specified type. public static Gen<T> Auto() AutoWith(IAutoGenConfig) Create a generator that automatically generates values of the specified type, using the provided configuration. public static Gen<T> AutoWith(IAutoGenConfig config) Byte(Range) Generates a random byte. public static Gen<byte> Byte(Range<byte> range) Char(char, char) Generates a random character in the given range. public static Gen<char> Char(char lo, char hi) Choice(Gen) Randomly selects one of the gens in the list. The input list must be non-empty. public static Gen<T> Choice(Gen<T> array gens) ChoiceRecursive(Gen, Gen) Randomly selects from one of the gens in either the non-recursive or the recursive list. When a selection is made from the recursive list, the size is halved. When the size gets to one or less, selections are no longer made from the recursive list. The first argument (i.e. the non-recursive input list) must be non-empty. public static Gen<T> ChoiceRecursive(Gen<T>IEnumerable nonrecs, Gen<T>IEnumerable recs) Constant('T) Create a generator that always yields a constant value. public static Gen<T> Constant(T value) Create(Func, Random) public static Gen<T> Create(Func<T, TIEnumerable> shrink, Random<T> random) DateTime(Range) Generates a random DateTime using the given range. Example: var TwentiethCentury = Gen.DateTime( Range.Constant( new DateTime(1900, 1, 1), new DateTime(1999, 12, 31))); public static Gen<DateTime> DateTime(Range<DateTime> range) DateTimeOffset(Range) Generates a random DateTimeOffset using the given range. public static Gen<DateTimeOffset> DateTimeOffset(Range<DateTimeOffset> range) Decimal(Range) Generates a random decimal floating-point number. public static Gen<decimal> Decimal(Range<decimal> range) Delay(Func) public static Gen<T> Delay(Func<Gen<T>> func) Double(Range) Generates a random 64-bit floating point number. public static Gen<double> Double(Range<double> range) Frequency((int) Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. public static Gen<T> Frequency(((int, Gen)<T>) array gens) Frequency((int) Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. public static Gen<T> Frequency(((int, Gen)<T>) array gens) FromRandom(Random) public static Gen<T> FromRandom(Random<Tree<T>> random) FromValue('T) Create a generator that always yields a constant value. public static Gen<T> FromValue(T value) Identifier(int) Generates a random identifier string (starts with a lowercase letter, followed by lowercase letters, digits, or underscores) of up to the specified maximum length public static Gen<string> Identifier(int maxLen) Int16(Range) Generates a random signed 16-bit integer. public static Gen<int16> Int16(Range<int16> range) Int32(Range) Generates a random signed 32-bit integer. public static Gen<int32> Int32(Range<int32> range) Int64(Range) Generates a random signed 64-bit integer. public static Gen<int64> Int64(Range<int64> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. public static Gen<byte> Integral(Range<byte> range) Item('T) Randomly selects one of the values in the list. The input list must be non-empty. public static Gen<T> Item(T array items) KebabCase(int, int) Generates a random kebab-case string composed of words with the specified maximum word length and maximum words count. public static Gen<string> KebabCase(int maxWordLength, int maxWordsCount) KebabCase(Range, Range) Generates a random kebab-case string composed of words with the specified word length and words count ranges. public static Gen<string> KebabCase(Range<int> wordLength, Range<int> wordsCount) LatinName(int) Generates a random Latin-style name starting with an uppercase letter, followed by lowercase letters, of up to the specified maximum length. public static Gen<string> LatinName(int maxLength) SByte(Range) Generates a random signed byte. public static Gen<sbyte> SByte(Range<sbyte> range) Shuffle('T) Generates a permutation of the given items. public static Gen<TIEnumerable> Shuffle(TIEnumerable items) ShuffleCase(string) Shuffles the case of the given string. public static Gen<string> ShuffleCase(string value) Single(Range) Generates a random 32-bit floating point number. public static Gen<single> Single(Range<single> range) Sized(Func) Used to construct generators that depend on the size parameter. public static Gen<T> Sized(Func<Size, Gen<T>> scaler) SnakeCase(int, int) Generates a random snake_case string composed of words with the specified maximum word length and maximum words count. public static Gen<string> SnakeCase(int maxWordLength, int maxWordsCount) SnakeCase(Range, Range) Generates a random snake_case string composed of words with the specified word length and words count ranges. public static Gen<string> SnakeCase(Range<int> wordLength, Range<int> wordsCount) SubsetOf('T) Generates the subset of the provided items. The generated subset will be in the same order as the input items. public static Gen<TIEnumerable> SubsetOf(TIEnumerable items) UInt16(Range) Generates a random unsigned 16-bit integer. public static Gen<uint16> UInt16(Range<uint16> range) UInt32(Range) Generates a random unsigned 32-bit integer. public static Gen<uint32> UInt32(Range<uint32> range) UInt64(Range) Generates a random unsigned 64-bit integer. public static Gen<uint64> UInt64(Range<uint64> range) Upper Generates a random uppercase character, i.e. from 'A' to 'Z'. Example: Combine with String to create strings of a desired length. Gen.Upper.String(Range.Constant(5, 10)) public static Gen<char> Upper() AlphaNumeric Generates an alphanumeric character, i.e. 'a' to 'z', 'A' to 'Z', or '0' to '9'. Example: Combine with String to create strings of a desired length. Gen.AlphaNumeric.String(Range.Constant(5, 10)) This generates strings such as Ld5lk or 4dFDG public static Gen<char> AlphaNumeric() Lower Generates a random lowercase character, i.e. from 'a' to 'z'. Example: Combine with String to create strings of a desired length. Gen.Lower.String(Range.Constant(5, 10)) public static Gen<char> Lower() Unicode Generates a Unicode character, excluding non-characters ('\\65534' and '\\65535') and invalid standalone surrogates (from '\\55296' to '\\57343'). Example: Combine with String to create strings of a desired length. Gen.Unicode.String(Range.Constant(5, 10)) public static Gen<char> Unicode() IpAddress Generates a random IP address (either IPv4 or IPv6) with a higher chance of generating an IPv4 address. public static Gen<IPAddress> IpAddress() Guid Generates a random globally unique identifier. public static Gen<Guid> Guid() DomainName Generates a random valid domain name. public static Gen<string> DomainName() Bool Generates a random boolean. public static Gen<bool> Bool() Digit Generates a random numerical character, i.e. from '0' to '9'. Example: Combine with String to create strings of a desired length. Gen.Digit.String(Range.Constant(5, 10)) public static Gen<char> Digit() Ipv4Address Generates a random IPv4 address. public static Gen<IPAddress> Ipv4Address() Uri Generates a random URI public static Gen<Uri> Uri() Ipv6Address Generates a random IPv6 address. public static Gen<IPAddress> Ipv6Address() Ascii Generates a random ASCII character, i.e. from '\\000' to '\\127', i.e. any 7 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with String to create strings of a desired length. Gen.Ascii.String(Range.Constant(5, 10)) public static Gen<char> Ascii() Latin1 Generates a random Latin-1 character, i.e. from '\\000' to '\\255', i.e. any 8 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with String to create strings of a desired length. Gen.Latin1.String(Range.Constant(5, 10)) public static Gen<char> Latin1() Email Generates a random email address. public static Gen<string> Email() UnicodeAll Generates a Unicode character, including invalid standalone surrogates, i.e. from '\\000' to '\\65535'. public static Gen<char> UnicodeAll() Alpha Generates an alphabetic character, i.e. 'a' to 'z' or 'A' to 'Z'. Example: Combine with String to create strings of a desired length. Gen.Alpha.String(Range.Constant(5, 10)) This generates strings such as Ldklk or aFDG public static Gen<char> Alpha()"
  },
  "api/Hedgehog.Linq.GenExtensions.html": {
    "href": "api/Hedgehog.Linq.GenExtensions.html",
    "title": "Class GenExtensions | Hedgehog .NET",
    "summary": "Class GenExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class GenExtensions { public static Gen<TResult> Apply(this Gen<Func<T, TResult>> genFunc, Gen<T> genArg) public static Gen<T[]> Array(this Gen<T> gen, Range<int> range) public static Gen<TIEnumerable> Enumerable(this Gen<T> gen, Range<int> range) public static Tree<T> GenerateTree(this Gen<T> gen) public static Gen<ResizeArray<T>> List(this Gen<T> gen, Range<int> range) public static Gen<T> NoShrink(this Gen<T> gen) public static Gen<T> NotNull(this Gen<T> self) public static Gen<T> NullReference(this Gen<T> gen) public static Gen<Nullable<T>> NullValue(this Gen<T> gen) public static string RenderSample(this Gen<T> gen) public static Gen<T> Resize(this Gen<T> gen, Size size) public static ResizeArray<T> Sample(this Gen<T> gen, Size size, int count) public static ResizeArray<Tree<T>> SampleTree(this Gen<T> gen, Size size, int count) public static Gen<T> Scale(this Gen<T> gen, Func<int, int> scaler) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, W, TResult> mapper, Gen<U> genB, Gen<V> genC, Gen<W> genD) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, TResult> mapper, Gen<U> genB, Gen<V> genC) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, TResult> mapper, Gen<U> genB) public static Gen<TResult> Select(this Gen<T> gen, Func<T, TResult> mapper) public static Gen<TResult> SelectMany(this Gen<T> gen, Func<T, Gen<TCollection>> binder, Func<T, TCollection, TResult> projection) public static Gen<U> SelectMany(this Gen<T> gen, Func<T, Gen<U>> binder) public static Gen<TResult> SelectRandom(this Gen<T> gen, Func<Random<Tree<T>>, Random<Tree<TResult>>> binder) public static Gen<TResult> SelectTree(this Gen<T> gen, Func<Tree<T>, Tree<TResult>> binder) public static Gen<T> Shrink(this Gen<T> gen, Func<T, ResizeArray<T>> shrinker) public static Gen<T> ShrinkLazy(this Gen<T> gen, Func<T, TIEnumerable> shrinker) public static Gen<T> Some(this Gen<Option<T>> gen) public static Gen<string> String(this Gen<char> gen, Range<int> range) public static Gen<T> ToGen(this Random<Tree<T>> random) public static Random<Tree<T>> ToRandom(this Gen<T> gen) public static Gen<T> TryFinally(this Gen<T> gen, Action after) public static Gen<T> TryWith(this Gen<T> gen, Func<exn, Gen<T>> after) public static Gen<(T, T)> Tuple2(this Gen<T> gen) public static Gen<(T, T, T)> Tuple3(this Gen<T> gen) public static Gen<(T, T, T, T)> Tuple4(this Gen<T> gen) public static Gen<T> Where(this Gen<T> gen, Func<T, bool> predicate) public static Gen<T> WithNull(this Gen<T> self) public static Gen<(T, U, V, W)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC, Gen<W> genD) public static Gen<(T, U, V)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC) public static Gen<(T, U)> Zip(this Gen<T> genA, Gen<U> genB) } GenExtensions Methods Apply(Gen, Gen) public static Gen<TResult> Apply(this Gen<Func<T, TResult>> genFunc, Gen<T> genArg) Array(Gen, Range) Generates an array using a 'Range' to determine the length. public static Gen<T[]> Array(this Gen<T> gen, Range<int> range) Enumerable(Gen, Range) Generates an enumerable using a 'Range' to determine the length. public static Gen<TIEnumerable> Enumerable(this Gen<T> gen, Range<int> range) GenerateTree(Gen) Run a generator. The size passed to the generator is always 30; if you want another size then you should explicitly use 'resize'. public static Tree<T> GenerateTree(this Gen<T> gen) List(Gen, Range) Generates a List using a 'Range' to determine the length and a 'Gen' to produce the elements. public static Gen<ResizeArray<T>> List(this Gen<T> gen, Range<int> range) NoShrink(Gen) Prevent a 'Gen' from shrinking. public static Gen<T> NoShrink(this Gen<T> gen) NotNull(Gen) Generates a value that is not null. public static Gen<T> NotNull(this Gen<T> self) NullReference(Gen) Generates a null or a value from gen. Null becomes less common with larger Sizes. public static Gen<T> NullReference(this Gen<T> gen) NullValue(Gen) Generates a null or a value from gen. Null becomes less common with larger Sizes. public static Gen<Nullable<T>> NullValue(this Gen<T> gen) RenderSample(Gen) Samples the gen 5 times with a Size of 10, called the \"Outcome\" in the returned string. Then the shrink path to each Outcome is produced. This may be useful in debugging shrink paths in complex Gens. public static string RenderSample(this Gen<T> gen) Resize(Gen, Size) Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. public static Gen<T> Resize(this Gen<T> gen, Size size) Sample(Gen, Size, int) Returns a List of values produced by the generator. public static ResizeArray<T> Sample(this Gen<T> gen, Size size, int count) SampleTree(Gen, Size, int) public static ResizeArray<Tree<T>> SampleTree(this Gen<T> gen, Size size, int count) Scale(Gen, Func) Adjust the size parameter, by transforming it with the given function. public static Gen<T> Scale(this Gen<T> gen, Func<int, int> scaler) Select(Gen, Func, Gen, Gen, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, W, TResult> mapper, Gen<U> genB, Gen<V> genC, Gen<W> genD) Select(Gen, Func, Gen, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, TResult> mapper, Gen<U> genB, Gen<V> genC) Select(Gen, Func, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, TResult> mapper, Gen<U> genB) Select(Gen, Func) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); public static Gen<TResult> Select(this Gen<T> gen, Func<T, TResult> mapper) SelectMany(Gen, Func, Func) public static Gen<TResult> SelectMany(this Gen<T> gen, Func<T, Gen<TCollection>> binder, Func<T, TCollection, TResult> projection) SelectMany(Gen, Func) public static Gen<U> SelectMany(this Gen<T> gen, Func<T, Gen<U>> binder) SelectRandom(Gen, Func) public static Gen<TResult> SelectRandom(this Gen<T> gen, Func<Random<Tree<T>>, Random<Tree<TResult>>> binder) SelectTree(Gen, Func) public static Gen<TResult> SelectTree(this Gen<T> gen, Func<Tree<T>, Tree<TResult>> binder) Shrink(Gen, Func) Apply an additional shrinker to all generated trees. public static Gen<T> Shrink(this Gen<T> gen, Func<T, ResizeArray<T>> shrinker) ShrinkLazy(Gen, Func) Apply an additional shrinker to all generated trees. public static Gen<T> ShrinkLazy(this Gen<T> gen, Func<T, TIEnumerable> shrinker) Some(Gen) Runs an option generator until it produces a 'Some'. public static Gen<T> Some(this Gen<Option<T>> gen) String(Gen, Range) Generates a random string using 'Range' to determine the length and the given character generator. public static Gen<string> String(this Gen<char> gen, Range<int> range) ToGen(Random) public static Gen<T> ToGen(this Random<Tree<T>> random) ToRandom(Gen) public static Random<Tree<T>> ToRandom(this Gen<T> gen) TryFinally(Gen, Action) Ensures a cleanup action runs after the generator executes, even if an exception is thrown. public static Gen<T> TryFinally(this Gen<T> gen, Action after) TryWith(Gen, Func) Catches exceptions thrown by a generator and handles them with a recovery function. Use this to provide fallback behavior when a generator might throw an exception. Example: var gen = riskyGen.TryWith(ex => Gen.Constant(defaultValue)); public static Gen<T> TryWith(this Gen<T> gen, Func<exn, Gen<T>> after) Tuple2(Gen) public static Gen<(T, T)> Tuple2(this Gen<T> gen) Tuple3(Gen) public static Gen<(T, T, T)> Tuple3(this Gen<T> gen) Tuple4(Gen) public static Gen<(T, T, T, T)> Tuple4(this Gen<T> gen) Where(Gen, Func) Generates a value that satisfies a predicate. public static Gen<T> Where(this Gen<T> gen, Func<T, bool> predicate) WithNull(Gen) public static Gen<T> WithNull(this Gen<T> self) Zip(Gen, Gen, Gen, Gen) public static Gen<(T, U, V, W)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC, Gen<W> genD) Zip(Gen, Gen, Gen) public static Gen<(T, U, V)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC) Zip(Gen, Gen) public static Gen<(T, U)> Zip(this Gen<T> genA, Gen<U> genB)"
  },
  "api/Hedgehog.Linq.GenFunctionExtensions.html": {
    "href": "api/Hedgehog.Linq.GenFunctionExtensions.html",
    "title": "Class GenFunctionExtensions | Hedgehog .NET",
    "summary": "Class GenFunctionExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class GenFunctionExtensions { public static Gen<ResizeArray<T> * Func<T, TResult>> WithDistinctMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) public static Gen<ResizeArray<T> * Func<T, TResult>> WithMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) } GenFunctionExtensions Methods WithDistinctMapTo(Gen, Gen) Generates a list together with a function that maps each of the distinct elements in the list to distinct values generated by outGen. Distinct elements in the input list are guaranteed to map to distinct output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'], but never ['A'; 'A'; 'A'] or ['A'; 'B'; 'C']. Only use this if the output space is large enough that the required number of distinct output values are likely to be generated. The generated function throws if called with values not present in the input list. public static Gen<ResizeArray<T> * Func<T, TResult>> WithDistinctMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) WithMapTo(Gen, Gen) Generates a list together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list may map to the same output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'] or ['A'; 'A'; 'A'], but never ['A'; 'B'; 'C']. The generated function throws if called with values not present in the input list. public static Gen<ResizeArray<T> * Func<T, TResult>> WithMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen)"
  },
  "api/Hedgehog.Linq.GenListExtensions.html": {
    "href": "api/Hedgehog.Linq.GenListExtensions.html",
    "title": "Class GenListExtensions | Hedgehog .NET",
    "summary": "Class GenListExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class GenListExtensions { public static Gen<ResizeArray<T>> AddElement(this Gen<ResizeArray<T>> self, T x) public static Gen<ResizeArray<T>> NotContains(this Gen<ResizeArray<T>> self, T value) public static Gen<T> NotIn(this Gen<T> self, ResizeArray<T> values) public static Gen<TIEnumerable> Sequence(this a self) public static Gen<TResultIEnumerable> Traverse(this a self, Func<T, Gen<TResult>> f) } GenListExtensions Methods AddElement(Gen, 'T) public static Gen<ResizeArray<T>> AddElement(this Gen<ResizeArray<T>> self, T x) NotContains(Gen, 'T) Generates a list that does not contain the specified element. Shortcut for Gen.filter (not << List.contains x). public static Gen<ResizeArray<T>> NotContains(this Gen<ResizeArray<T>> self, T value) NotIn(Gen, ResizeArray) Generates a value that is not contained in the specified list. public static Gen<T> NotIn(this Gen<T> self, ResizeArray<T> values) Sequence('a) Turn a sequence of generators into a generator of a sequence. public static Gen<TIEnumerable> Sequence(this a self) Traverse('a, Func) Apply a generator-producing function to each element and collect the results. public static Gen<TResultIEnumerable> Traverse(this a self, Func<T, Gen<TResult>> f)"
  },
  "api/Hedgehog.Linq.Property.html": {
    "href": "api/Hedgehog.Linq.Property.html",
    "title": "Class Property | Hedgehog .NET",
    "summary": "Class Property Namespace Hedgehog.Linq Assembly Hedgehog.dll public class Property { public static Property<void> CounterExample(Func<string> message) public static Property<T> Delay(Func<Property<T>> f) public static Property Discard() public static Property Failure() public static Property<T> ForAll(Gen<T> gen) public static Property<TResult> ForAll(Gen<T> gen, Func<T, Property<TResult>> k) public static Property FromBool(bool value) public static Property<T> FromGen(Gen<Lazy<(Journal, Outcome)<T>>> gen) public static Property<T> FromOutcome(Outcome<T> result) public static Property<T> Success(T value) public static Property<TResult> Using(T resource, Func<T, Property<TResult>> action) } Property Methods CounterExample(Func) Adds custom debug information that will be displayed when a property test fails. Use this to include variable values or other context to help diagnose failures. Example: var property = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() from y in Gen.Int32(Range.Constant(-100, 1000)).ForAll() from _ in Property.CounterExample(() => $\"x = {x}, y = {y}, x * y = {x * y}\") select x * y >= 0; public static Property<void> CounterExample(Func<string> message) Delay(Func) public static Property<T> Delay(Func<Property<T>> f) ForAll(Gen) public static Property<T> ForAll(Gen<T> gen) ForAll(Gen, Func) public static Property<TResult> ForAll(Gen<T> gen, Func<T, Property<TResult>> k) FromBool(bool) public static Property FromBool(bool value) FromGen(Gen) public static Property<T> FromGen(Gen<Lazy<(Journal, Outcome)<T>>> gen) FromOutcome(Outcome) public static Property<T> FromOutcome(Outcome<T> result) Success('T) public static Property<T> Success(T value) Using('T, Func) public static Property<TResult> Using(T resource, Func<T, Property<TResult>> action) Failure public static Property Failure() Discard public static Property Discard()"
  },
  "api/Hedgehog.Linq.PropertyConfigExtensions.html": {
    "href": "api/Hedgehog.Linq.PropertyConfigExtensions.html",
    "title": "Class PropertyConfigExtensions | Hedgehog .NET",
    "summary": "Class PropertyConfigExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class PropertyConfigExtensions { public static IPropertyConfig WithShrinks(this IPropertyConfig config, int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit) public static IPropertyConfig WithTests(this IPropertyConfig config, int<MeasureProduct<tests, MeasureOne>> testLimit) public static IPropertyConfig WithoutShrinks(this IPropertyConfig config) } PropertyConfigExtensions Methods WithShrinks(IPropertyConfig, int) Set the number of times a property is allowed to shrink before the test runner gives up and displays the counterexample. public static IPropertyConfig WithShrinks(this IPropertyConfig config, int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit) WithTests(IPropertyConfig, int) Set the number of times a property should be executed before it is considered successful. public static IPropertyConfig WithTests(this IPropertyConfig config, int<MeasureProduct<tests, MeasureOne>> testLimit) WithoutShrinks(IPropertyConfig) Restores the default shrinking behavior. public static IPropertyConfig WithoutShrinks(this IPropertyConfig config)"
  },
  "api/Hedgehog.Linq.PropertyExtensions.html": {
    "href": "api/Hedgehog.Linq.PropertyExtensions.html",
    "title": "Class PropertyExtensions | Hedgehog .NET",
    "summary": "Class PropertyExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class PropertyExtensions { public static void Check(this Property<bool> property, IPropertyConfig config) public static void Check(this Property<bool> property) public static void Check(this Property property, IPropertyConfig config) public static void Check(this Property property) public static Property<TResult> ForAll(this Gen<T> gen, Func<T, Property<TResult>> bind) public static Property<T> ForAll(this Gen<T> gen) public static void Recheck(this Property<bool> property, string recheckData, IPropertyConfig config) public static void Recheck(this Property<bool> property, string recheckData) public static void Recheck(this Property property, string recheckData, IPropertyConfig config) public static void Recheck(this Property property, string recheckData) public static string Render(this Property<bool> property, IPropertyConfig config) public static string Render(this Property<bool> property) public static string Render(this Property property, IPropertyConfig config) public static string Render(this Property property) public static Report Report(this Property<bool> property, IPropertyConfig config) public static Report Report(this Property<bool> property) public static Report Report(this Property property, IPropertyConfig config) public static Report Report(this Property property) public static Report ReportRecheck(this Property<bool> property, string recheckData, IPropertyConfig config) public static Report ReportRecheck(this Property<bool> property, RecheckData recheckData) public static Report ReportRecheck(this Property<bool> property, string recheckData) public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) public static Report ReportRecheck(this Property property, string recheckData) public static Property Select(this Property<T> property, Action<T> mapper) public static Property<TResult> Select(this Property<T> property, Func<T, TResult> mapper) public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) public static Gen<Lazy<(Journal, Outcome)<T>>> ToGen(this Property<T> property) public static Property<T> TryFinally(this Property<T> property, Action onFinally) public static Property<T> TryWith(this Property<T> property, Func<exn, Property<T>> onError) public static Property<T> Where(this Property<T> property, Func<T, bool> filter) } PropertyExtensions Methods Check(Property, IPropertyConfig) Runs the property test with custom configuration and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. public static void Check(this Property property, IPropertyConfig config) Check(Property) Runs the property test and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. public static void Check(this Property property) Check(Property, IPropertyConfig) Runs the property test with custom configuration and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. public static void Check(this Property property, IPropertyConfig config) Check(Property) Runs the property test and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. public static void Check(this Property property) ForAll(Gen, Func) Creates a property from a generator and applies a function to it, allowing it to be used in LINQ query comprehensions. \"For all\" means the property will be tested for all values of that type generated by the generator. public static Property<TResult> ForAll(this Gen<T> gen, Func<T, Property<TResult>> bind) ForAll(Gen) Creates a property from a generator, allowing it to be used in LINQ query comprehensions. \"For all\" means the property will be tested for all values of that type generated by the generator. public static Property<T> ForAll(this Gen<T> gen) Recheck(Property, string, IPropertyConfig) Rechecks a previously failed property test using the same random seed and test inputs, with custom configuration. Use this to reproduce and debug a specific failure without running all test cases again. public static void Recheck(this Property property, string recheckData, IPropertyConfig config) Recheck(Property, string) Rechecks a previously failed property test using the same random seed and test inputs. Use this to reproduce and debug a specific failure without running all test cases again. public static void Recheck(this Property property, string recheckData) Recheck(Property, string, IPropertyConfig) Rechecks a previously failed property test using the same random seed and test inputs, with custom configuration. Use this to reproduce and debug a specific failure without running all test cases again. public static void Recheck(this Property property, string recheckData, IPropertyConfig config) Recheck(Property, string) Rechecks a previously failed property test using the same random seed and test inputs. Use this to reproduce and debug a specific failure without running all test cases again. public static void Recheck(this Property property, string recheckData) Render(Property, IPropertyConfig) public static string Render(this Property property, IPropertyConfig config) Render(Property) public static string Render(this Property property) Render(Property, IPropertyConfig) public static string Render(this Property property, IPropertyConfig config) Render(Property) public static string Render(this Property property) Report(Property, IPropertyConfig) public static Report Report(this Property property, IPropertyConfig config) Report(Property) public static Report Report(this Property property) Report(Property, IPropertyConfig) public static Report Report(this Property property, IPropertyConfig config) Report(Property) public static Report Report(this Property property) ReportRecheck(Property, string, IPropertyConfig) public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) ReportRecheck(Property, RecheckData) public static Report ReportRecheck(this Property<bool> property, RecheckData recheckData) ReportRecheck(Property, string) public static Report ReportRecheck(this Property property, string recheckData) ReportRecheck(Property, string, IPropertyConfig) public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) ReportRecheck(Property, string) public static Report ReportRecheck(this Property property, string recheckData) Select(Property, Action) public static Property Select(this Property<T> property, Action<T> mapper) Select(Property, Func) public static Property<TResult> Select(this Property<T> property, Func<T, TResult> mapper) SelectMany(Property, Func, Action) public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) SelectMany(Property, Func, Func) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) ToGen(Property) public static Gen<Lazy<(Journal, Outcome)<T>>> ToGen(this Property<T> property) TryFinally(Property, Action) public static Property<T> TryFinally(this Property<T> property, Action onFinally) TryWith(Property, Func) public static Property<T> TryWith(this Property<T> property, Func<exn, Property<T>> onError) Where(Property, Func) public static Property<T> Where(this Property<T> property, Func<T, bool> filter)"
  },
  "api/Hedgehog.Linq.Range.html": {
    "href": "api/Hedgehog.Linq.Range.html",
    "title": "Class Range | Hedgehog .NET",
    "summary": "Class Range Namespace Hedgehog.Linq Assembly Hedgehog.dll public class Range { public static Range<T> Constant(T x, T y) public static Range<T> Constant(T z, T x, T y) public static Range<byte> ConstantBoundedByte() public static Range<decimal> ConstantBoundedDecimal() public static Range<double> ConstantBoundedDouble() public static Range<int16> ConstantBoundedInt16() public static Range<int32> ConstantBoundedInt32() public static Range<int64> ConstantBoundedInt64() public static Range<sbyte> ConstantBoundedSByte() public static Range<single> ConstantBoundedSingle() public static Range<uint16> ConstantBoundedUInt16() public static Range<uint32> ConstantBoundedUInt32() public static Range<uint64> ConstantBoundedUInt64() public static Range<byte> ExponentialBoundedByte() public static Range<decimal> ExponentialBoundedDecimal() public static Range<double> ExponentialBoundedDouble() public static Range<int16> ExponentialBoundedInt16() public static Range<int32> ExponentialBoundedInt32() public static Range<int64> ExponentialBoundedInt64() public static Range<sbyte> ExponentialBoundedSByte() public static Range<single> ExponentialBoundedSingle() public static Range<uint16> ExponentialBoundedUInt16() public static Range<uint32> ExponentialBoundedUInt32() public static Range<uint64> ExponentialBoundedUInt64() public static Range<byte> ExponentialByte(byte x, byte y) public static Range<decimal> ExponentialDecimal(decimal x, decimal y) public static Range<double> ExponentialDouble(double x, double y) public static Range<byte> ExponentialFromByte(byte z, byte x, byte y) public static Range<decimal> ExponentialFromDecimal(decimal z, decimal x, decimal y) public static Range<double> ExponentialFromDouble(double z, double x, double y) public static Range<int16> ExponentialFromInt16(int16 z, int16 x, int16 y) public static Range<int32> ExponentialFromInt32(int32 z, int32 x, int32 y) public static Range<int64> ExponentialFromInt64(int64 z, int64 x, int64 y) public static Range<sbyte> ExponentialFromSByte(sbyte z, sbyte x, sbyte y) public static Range<single> ExponentialFromSingle(single z, single x, single y) public static Range<uint16> ExponentialFromUInt16(uint16 z, uint16 x, uint16 y) public static Range<uint32> ExponentialFromUInt32(uint32 z, uint32 x, uint32 y) public static Range<uint64> ExponentialFromUInt64(uint64 z, uint64 x, uint64 y) public static Range<int16> ExponentialInt16(int16 x, int16 y) public static Range<int32> ExponentialInt32(int32 x, int32 y) public static Range<int64> ExponentialInt64(int64 x, int64 y) public static Range<sbyte> ExponentialSByte(sbyte x, sbyte y) public static Range<single> ExponentialSingle(single x, single y) public static Range<uint16> ExponentialUInt16(uint16 x, uint16 y) public static Range<uint32> ExponentialUInt32(uint32 x, uint32 y) public static Range<uint64> ExponentialUInt64(uint64 x, uint64 y) public static Range<T> FromValue(T value) public static Range<byte> LinearBoundedByte() public static Range<decimal> LinearBoundedDecimal() public static Range<double> LinearBoundedDouble() public static Range<int16> LinearBoundedInt16() public static Range<int32> LinearBoundedInt32() public static Range<int64> LinearBoundedInt64() public static Range<sbyte> LinearBoundedSByte() public static Range<single> LinearBoundedSingle() public static Range<uint16> LinearBoundedUInt16() public static Range<uint32> LinearBoundedUInt32() public static Range<uint64> LinearBoundedUInt64() public static Range<byte> LinearByte(byte x, byte y) public static Range<decimal> LinearDecimal(decimal x, decimal y) public static Range<double> LinearDouble(double x, double y) public static Range<byte> LinearFromByte(byte z, byte x, byte y) public static Range<decimal> LinearFromDecimal(decimal z, decimal x, decimal y) public static Range<double> LinearFromDouble(double z, double x, double y) public static Range<int16> LinearFromInt16(int16 z, int16 x, int16 y) public static Range<int32> LinearFromInt32(int32 z, int32 x, int32 y) public static Range<int64> LinearFromInt64(int64 z, int64 x, int64 y) public static Range<sbyte> LinearFromSByte(sbyte z, sbyte x, sbyte y) public static Range<single> LinearFromSingle(single z, single x, single y) public static Range<uint16> LinearFromUInt16(uint16 z, uint16 x, uint16 y) public static Range<uint32> LinearFromUInt32(uint32 z, uint32 x, uint32 y) public static Range<uint64> LinearFromUInt64(uint64 z, uint64 x, uint64 y) public static Range<int16> LinearInt16(int16 x, int16 y) public static Range<int32> LinearInt32(int32 x, int32 y) public static Range<int64> LinearInt64(int64 x, int64 y) public static Range<sbyte> LinearSByte(sbyte x, sbyte y) public static Range<single> LinearSingle(single x, single y) public static Range<uint16> LinearUInt16(uint16 x, uint16 y) public static Range<uint32> LinearUInt32(uint32 x, uint32 y) public static Range<uint64> LinearUInt64(uint64 x, uint64 y) public static Range<T> Singleton(T value) } Range Methods Constant('T, 'T) Construct a range which is unaffected by the size parameter. public static Range<T> Constant(T x, T y) Constant('T, 'T, 'T) Construct a range which is unaffected by the size parameter with a origin point which may differ from the bounds. public static Range<T> Constant(T z, T x, T y) ConstantBoundedByte Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<byte> ConstantBoundedByte() ConstantBoundedDecimal Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<decimal> ConstantBoundedDecimal() ConstantBoundedDouble Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<double> ConstantBoundedDouble() ConstantBoundedInt16 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<int16> ConstantBoundedInt16() ConstantBoundedInt32 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<int32> ConstantBoundedInt32() ConstantBoundedInt64 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<int64> ConstantBoundedInt64() ConstantBoundedSByte Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<sbyte> ConstantBoundedSByte() ConstantBoundedSingle Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<single> ConstantBoundedSingle() ConstantBoundedUInt16 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<uint16> ConstantBoundedUInt16() ConstantBoundedUInt32 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<uint32> ConstantBoundedUInt32() ConstantBoundedUInt64 Construct a range which is unaffected by the size parameter using the full range of a data type. public static Range<uint64> ConstantBoundedUInt64() ExponentialBoundedByte Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<byte> ExponentialBoundedByte() ExponentialBoundedDecimal Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<decimal> ExponentialBoundedDecimal() ExponentialBoundedDouble Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<double> ExponentialBoundedDouble() ExponentialBoundedInt16 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<int16> ExponentialBoundedInt16() ExponentialBoundedInt32 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<int32> ExponentialBoundedInt32() ExponentialBoundedInt64 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<int64> ExponentialBoundedInt64() ExponentialBoundedSByte Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<sbyte> ExponentialBoundedSByte() ExponentialBoundedSingle Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<single> ExponentialBoundedSingle() ExponentialBoundedUInt16 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<uint16> ExponentialBoundedUInt16() ExponentialBoundedUInt32 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<uint32> ExponentialBoundedUInt32() ExponentialBoundedUInt64 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. public static Range<uint64> ExponentialBoundedUInt64() ExponentialByte(byte, byte) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<byte> ExponentialByte(byte x, byte y) ExponentialDecimal(decimal, decimal) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<decimal> ExponentialDecimal(decimal x, decimal y) ExponentialDouble(double, double) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<double> ExponentialDouble(double x, double y) ExponentialFromByte(byte, byte, byte) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<byte> ExponentialFromByte(byte z, byte x, byte y) ExponentialFromDecimal(decimal, decimal, decimal) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<decimal> ExponentialFromDecimal(decimal z, decimal x, decimal y) ExponentialFromDouble(double, double, double) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<double> ExponentialFromDouble(double z, double x, double y) ExponentialFromInt16(int16, int16, int16) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<int16> ExponentialFromInt16(int16 z, int16 x, int16 y) ExponentialFromInt32(int32, int32, int32) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<int32> ExponentialFromInt32(int32 z, int32 x, int32 y) ExponentialFromInt64(int64, int64, int64) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<int64> ExponentialFromInt64(int64 z, int64 x, int64 y) ExponentialFromSByte(sbyte, sbyte, sbyte) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<sbyte> ExponentialFromSByte(sbyte z, sbyte x, sbyte y) ExponentialFromSingle(single, single, single) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<single> ExponentialFromSingle(single z, single x, single y) ExponentialFromUInt16(uint16, uint16, uint16) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<uint16> ExponentialFromUInt16(uint16 z, uint16 x, uint16 y) ExponentialFromUInt32(uint32, uint32, uint32) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<uint32> ExponentialFromUInt32(uint32 z, uint32 x, uint32 y) ExponentialFromUInt64(uint64, uint64, uint64) Construct a range which scales the bounds exponentially relative to the size parameter. public static Range<uint64> ExponentialFromUInt64(uint64 z, uint64 x, uint64 y) ExponentialInt16(int16, int16) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<int16> ExponentialInt16(int16 x, int16 y) ExponentialInt32(int32, int32) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<int32> ExponentialInt32(int32 x, int32 y) ExponentialInt64(int64, int64) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<int64> ExponentialInt64(int64 x, int64 y) ExponentialSByte(sbyte, sbyte) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<sbyte> ExponentialSByte(sbyte x, sbyte y) ExponentialSingle(single, single) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<single> ExponentialSingle(single x, single y) ExponentialUInt16(uint16, uint16) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<uint16> ExponentialUInt16(uint16 x, uint16 y) ExponentialUInt32(uint32, uint32) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<uint32> ExponentialUInt32(uint32 x, uint32 y) ExponentialUInt64(uint64, uint64) Construct a range which scales the second bound exponentially relative to the size parameter. public static Range<uint64> ExponentialUInt64(uint64 x, uint64 y) FromValue('T) Construct a range which represents a constant single value. public static Range<T> FromValue(T value) LinearBoundedByte Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<byte> LinearBoundedByte() LinearBoundedDecimal Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<decimal> LinearBoundedDecimal() LinearBoundedDouble Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<double> LinearBoundedDouble() LinearBoundedInt16 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<int16> LinearBoundedInt16() LinearBoundedInt32 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<int32> LinearBoundedInt32() LinearBoundedInt64 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<int64> LinearBoundedInt64() LinearBoundedSByte Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<sbyte> LinearBoundedSByte() LinearBoundedSingle Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<single> LinearBoundedSingle() LinearBoundedUInt16 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<uint16> LinearBoundedUInt16() LinearBoundedUInt32 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<uint32> LinearBoundedUInt32() LinearBoundedUInt64 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. public static Range<uint64> LinearBoundedUInt64() LinearByte(byte, byte) Construct a range which scales the second bound relative to the size parameter. public static Range<byte> LinearByte(byte x, byte y) LinearDecimal(decimal, decimal) Construct a range which scales the second bound relative to the size parameter. public static Range<decimal> LinearDecimal(decimal x, decimal y) LinearDouble(double, double) Construct a range which scales the second bound relative to the size parameter. public static Range<double> LinearDouble(double x, double y) LinearFromByte(byte, byte, byte) Construct a range which scales the bounds relative to the size parameter. public static Range<byte> LinearFromByte(byte z, byte x, byte y) LinearFromDecimal(decimal, decimal, decimal) Construct a range which scales the bounds relative to the size parameter. public static Range<decimal> LinearFromDecimal(decimal z, decimal x, decimal y) LinearFromDouble(double, double, double) Construct a range which scales the bounds relative to the size parameter. public static Range<double> LinearFromDouble(double z, double x, double y) LinearFromInt16(int16, int16, int16) Construct a range which scales the bounds relative to the size parameter. public static Range<int16> LinearFromInt16(int16 z, int16 x, int16 y) LinearFromInt32(int32, int32, int32) Construct a range which scales the bounds relative to the size parameter. public static Range<int32> LinearFromInt32(int32 z, int32 x, int32 y) LinearFromInt64(int64, int64, int64) Construct a range which scales the bounds relative to the size parameter. public static Range<int64> LinearFromInt64(int64 z, int64 x, int64 y) LinearFromSByte(sbyte, sbyte, sbyte) Construct a range which scales the bounds relative to the size parameter. public static Range<sbyte> LinearFromSByte(sbyte z, sbyte x, sbyte y) LinearFromSingle(single, single, single) Construct a range which scales the bounds relative to the size parameter. public static Range<single> LinearFromSingle(single z, single x, single y) LinearFromUInt16(uint16, uint16, uint16) Construct a range which scales the bounds relative to the size parameter. public static Range<uint16> LinearFromUInt16(uint16 z, uint16 x, uint16 y) LinearFromUInt32(uint32, uint32, uint32) Construct a range which scales the bounds relative to the size parameter. public static Range<uint32> LinearFromUInt32(uint32 z, uint32 x, uint32 y) LinearFromUInt64(uint64, uint64, uint64) Construct a range which scales the bounds relative to the size parameter. public static Range<uint64> LinearFromUInt64(uint64 z, uint64 x, uint64 y) LinearInt16(int16, int16) Construct a range which scales the second bound relative to the size parameter. public static Range<int16> LinearInt16(int16 x, int16 y) LinearInt32(int32, int32) Construct a range which scales the second bound relative to the size parameter. public static Range<int32> LinearInt32(int32 x, int32 y) LinearInt64(int64, int64) Construct a range which scales the second bound relative to the size parameter. public static Range<int64> LinearInt64(int64 x, int64 y) LinearSByte(sbyte, sbyte) Construct a range which scales the second bound relative to the size parameter. public static Range<sbyte> LinearSByte(sbyte x, sbyte y) LinearSingle(single, single) Construct a range which scales the second bound relative to the size parameter. public static Range<single> LinearSingle(single x, single y) LinearUInt16(uint16, uint16) Construct a range which scales the second bound relative to the size parameter. public static Range<uint16> LinearUInt16(uint16 x, uint16 y) LinearUInt32(uint32, uint32) Construct a range which scales the second bound relative to the size parameter. public static Range<uint32> LinearUInt32(uint32 x, uint32 y) LinearUInt64(uint64, uint64) Construct a range which scales the second bound relative to the size parameter. public static Range<uint64> LinearUInt64(uint64 x, uint64 y) Singleton('T) Construct a range which represents a constant single value. public static Range<T> Singleton(T value)"
  },
  "api/Hedgehog.Linq.RangeExtensions.html": {
    "href": "api/Hedgehog.Linq.RangeExtensions.html",
    "title": "Class RangeExtensions | Hedgehog .NET",
    "summary": "Class RangeExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class RangeExtensions { public static (T, T) Bounds(this Range<T> range, Size sz) public static T LowerBound(this Range<T> range, Size sz) public static T Origin(this Range<T> range) public static Range<TResult> Select(this Range<T> range, Func<T, TResult> mapper) public static T UpperBound(this Range<T> range, Size sz) } RangeExtensions Methods Bounds(Range, Size) Get the extents of a range, for a given size. public static (T, T) Bounds(this Range<T> range, Size sz) LowerBound(Range, Size) Get the lower bound of a range for the given size. public static T LowerBound(this Range<T> range, Size sz) Origin(Range) Get the origin of a range. This might be the mid-point or the lower bound, depending on what the range represents. The 'bounds' of a range are scaled around this value when using the 'linear' family of combinators. When using a 'Range' to generate numbers, the shrinking function will shrink towards the origin. public static T Origin(this Range<T> range) Select(Range, Func) public static Range<TResult> Select(this Range<T> range, Func<T, TResult> mapper) UpperBound(Range, Size) Get the upper bound of a range for the given size. public static T UpperBound(this Range<T> range, Size sz)"
  },
  "api/Hedgehog.Linq.ReportExtensions.html": {
    "href": "api/Hedgehog.Linq.ReportExtensions.html",
    "title": "Class ReportExtensions | Hedgehog .NET",
    "summary": "Class ReportExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll public class ReportExtensions { public static string Render(this Report report) } ReportExtensions Methods Render(Report) public static string Render(this Report report)"
  },
  "api/Hedgehog.MaxValue.html": {
    "href": "api/Hedgehog.MaxValue.html",
    "title": "Class MaxValue | Hedgehog .NET",
    "summary": "Class MaxValue Namespace Hedgehog Assembly Hedgehog.dll type MaxValue = static member Invoke : ^a static member MaxValue : 'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h -> MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 static member MaxValue : 'a * 'b * 'c * 'd * 'e * 'f * 'g -> MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 static member MaxValue : 'a * 'b * 'c * 'd * 'e * 'f -> MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 static member MaxValue : 'a * 'b * 'c * 'd * 'e -> MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 static member MaxValue : 'a * 'b * 'c * 'd -> MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 static member MaxValue : 'a * 'b * 'c -> MaxValue -> ^a0 * ^b1 * ^c2 static member MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 static member MaxValue : TimeSpan -> MaxValue -> TimeSpan static member MaxValue : DateTimeOffset -> MaxValue -> DateTimeOffset static member MaxValue : DateTime -> MaxValue -> DateTime static member MaxValue : decimal -> MaxValue -> decimal static member MaxValue : double -> MaxValue -> double static member MaxValue : single -> MaxValue -> single static member MaxValue : int64 -> MaxValue -> int64 static member MaxValue : int32 -> MaxValue -> int32 static member MaxValue : int16 -> MaxValue -> int16 static member MaxValue : int8 -> MaxValue -> int8 static member MaxValue : uint64 -> MaxValue -> uint64 static member MaxValue : uint32 -> MaxValue -> uint32 static member MaxValue : uint16 -> MaxValue -> uint16 static member MaxValue : uint8 -> MaxValue -> uint8 static member MaxValue : char -> MaxValue -> char static member MaxValue : bool -> MaxValue -> bool static member MaxValue : unit -> MaxValue -> unit MaxValue Methods Invoke val Invoke : ^a MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : 'a * 'b -> MaxValue -> ^a0 * ^b1 MaxValue val MaxValue : TimeSpan -> MaxValue -> TimeSpan MaxValue val MaxValue : DateTimeOffset -> MaxValue -> DateTimeOffset MaxValue val MaxValue : DateTime -> MaxValue -> DateTime MaxValue val MaxValue : decimal -> MaxValue -> decimal MaxValue val MaxValue : double -> MaxValue -> double MaxValue val MaxValue : single -> MaxValue -> single MaxValue val MaxValue : int64 -> MaxValue -> int64 MaxValue val MaxValue : int32 -> MaxValue -> int32 MaxValue val MaxValue : int16 -> MaxValue -> int16 MaxValue val MaxValue : int8 -> MaxValue -> int8 MaxValue val MaxValue : uint64 -> MaxValue -> uint64 MaxValue val MaxValue : uint32 -> MaxValue -> uint32 MaxValue val MaxValue : uint16 -> MaxValue -> uint16 MaxValue val MaxValue : uint8 -> MaxValue -> uint8 MaxValue val MaxValue : char -> MaxValue -> char MaxValue val MaxValue : bool -> MaxValue -> bool MaxValue val MaxValue : unit -> MaxValue -> unit"
  },
  "api/Hedgehog.MinValue.html": {
    "href": "api/Hedgehog.MinValue.html",
    "title": "Class MinValue | Hedgehog .NET",
    "summary": "Class MinValue Namespace Hedgehog Assembly Hedgehog.dll type MinValue = static member Invoke : ^a static member MinValue : 'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h -> MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 static member MinValue : 'a * 'b * 'c * 'd * 'e * 'f * 'g -> MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 static member MinValue : 'a * 'b * 'c * 'd * 'e * 'f -> MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 static member MinValue : 'a * 'b * 'c * 'd * 'e -> MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 static member MinValue : 'a * 'b * 'c * 'd -> MinValue -> ^a0 * ^b1 * ^c2 * ^d3 static member MinValue : 'a * 'b * 'c -> MinValue -> ^a0 * ^b1 * ^c2 static member MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 static member MinValue : TimeSpan -> MinValue -> TimeSpan static member MinValue : DateTimeOffset -> MinValue -> DateTimeOffset static member MinValue : DateTime -> MinValue -> DateTime static member MinValue : decimal -> MinValue -> decimal static member MinValue : double -> MinValue -> double static member MinValue : single -> MinValue -> single static member MinValue : int64 -> MinValue -> int64 static member MinValue : int32 -> MinValue -> int32 static member MinValue : int16 -> MinValue -> int16 static member MinValue : int8 -> MinValue -> int8 static member MinValue : uint64 -> MinValue -> uint64 static member MinValue : uint32 -> MinValue -> uint32 static member MinValue : uint16 -> MinValue -> uint16 static member MinValue : uint8 -> MinValue -> uint8 static member MinValue : char -> MinValue -> char static member MinValue : bool -> MinValue -> bool static member MinValue : unit -> MinValue -> unit MinValue Methods Invoke val Invoke : ^a MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : 'a * 'b -> MinValue -> ^a0 * ^b1 MinValue val MinValue : TimeSpan -> MinValue -> TimeSpan MinValue val MinValue : DateTimeOffset -> MinValue -> DateTimeOffset MinValue val MinValue : DateTime -> MinValue -> DateTime MinValue val MinValue : decimal -> MinValue -> decimal MinValue val MinValue : double -> MinValue -> double MinValue val MinValue : single -> MinValue -> single MinValue val MinValue : int64 -> MinValue -> int64 MinValue val MinValue : int32 -> MinValue -> int32 MinValue val MinValue : int16 -> MinValue -> int16 MinValue val MinValue : int8 -> MinValue -> int8 MinValue val MinValue : uint64 -> MinValue -> uint64 MinValue val MinValue : uint32 -> MinValue -> uint32 MinValue val MinValue : uint16 -> MinValue -> uint16 MinValue val MinValue : uint8 -> MinValue -> uint8 MinValue val MinValue : char -> MinValue -> char MinValue val MinValue : bool -> MinValue -> bool MinValue val MinValue : unit -> MinValue -> unit"
  },
  "api/Hedgehog.Numeric.html": {
    "href": "api/Hedgehog.Numeric.html",
    "title": "Class Numeric | Hedgehog .NET",
    "summary": "Class Numeric Namespace Hedgehog Assembly Hedgehog.dll type Numeric = member fromBigInt : bigint -> ^a member maxValue : unit -> ^a member minValue : unit -> ^a member toBigInt : ^a -> bigint Numeric Methods minValue Returns the smallest possible value. val minValue : unit -> ^a maxValue Returns the largest possible value. val maxValue : unit -> ^a fromBigInt Converts from a BigInt to the inferred destination type. val fromBigInt : bigint -> ^a toBigInt Converts to a BigInt. val toBigInt : ^a -> bigint"
  },
  "api/Hedgehog.Outcome.html": {
    "href": "api/Hedgehog.Outcome.html",
    "title": "Class Outcome | Hedgehog .NET",
    "summary": "Class Outcome Namespace Hedgehog Assembly Hedgehog.dll type Outcome = member filter : 'a -> bool -> Outcome<'a> -> Outcome<'a> member isFailure : Outcome<'a> -> bool member map : 'a -> 'b -> Outcome<'a> -> Outcome<'b> Outcome Methods map val map : 'a -> 'b -> Outcome<'a> -> Outcome<'b> filter val filter : 'a -> bool -> Outcome<'a> -> Outcome<'a> isFailure val isFailure : Outcome<'a> -> bool"
  },
  "api/Hedgehog.Outcome_a_.html": {
    "href": "api/Hedgehog.Outcome_a_.html",
    "title": "Class Outcome<'a> | Hedgehog .NET",
    "summary": "Class Outcome<'a> Namespace Hedgehog Assembly Hedgehog.dll type Outcome<'a> Outcome<'a>"
  },
  "api/Hedgehog.PropertyArgs.html": {
    "href": "api/Hedgehog.PropertyArgs.html",
    "title": "Class PropertyArgs | Hedgehog .NET",
    "summary": "Class PropertyArgs Namespace Hedgehog Assembly Hedgehog.dll type PropertyArgs = member init : PropertyArgs PropertyArgs Methods init val init : PropertyArgs"
  },
  "api/Hedgehog.PropertyConfig.html": {
    "href": "api/Hedgehog.PropertyConfig.html",
    "title": "Class PropertyConfig | Hedgehog .NET",
    "summary": "Class PropertyConfig Namespace Hedgehog Assembly Hedgehog.dll type PropertyConfig = member defaults : IPropertyConfig member withShrinks : int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig -> IPropertyConfig member withTests : int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig -> IPropertyConfig member withoutShrinks : IPropertyConfig -> IPropertyConfig PropertyConfig Methods defaults The default configuration for a property test. val defaults : IPropertyConfig withShrinks Set the number of times a property is allowed to shrink before the test runner gives up and displays the counterexample. val withShrinks : int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig -> IPropertyConfig withoutShrinks Restores the default shrinking behavior. val withoutShrinks : IPropertyConfig -> IPropertyConfig withTests Set the number of times a property should be executed before it is considered successful. val withTests : int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig -> IPropertyConfig"
  },
  "api/Hedgehog.Property_a_.html": {
    "href": "api/Hedgehog.Property_a_.html",
    "title": "Class Property<'a> | Hedgehog .NET",
    "summary": "Class Property<'a> Namespace Hedgehog Assembly Hedgehog.dll type Property<'a> Property<'a>"
  },
  "api/Hedgehog.Random_a_.html": {
    "href": "api/Hedgehog.Random_a_.html",
    "title": "Class Random<'a> | Hedgehog .NET",
    "summary": "Class Random<'a> Namespace Hedgehog Assembly Hedgehog.dll A generator for random values of type 'a type Random<'a> Random<'a>"
  },
  "api/Hedgehog.Range_a_.html": {
    "href": "api/Hedgehog.Range_a_.html",
    "title": "Class Range<'a> | Hedgehog .NET",
    "summary": "Class Range<'a> Namespace Hedgehog Assembly Hedgehog.dll A range describes the bounds of a number to generate, which may or may not be dependent on a 'Size'. The constructor takes an origin between the lower and upper bound, and a function from 'Size' to bounds. As the size goes towards 0, the values go towards the origin. type Range<'a> Range<'a>"
  },
  "api/Hedgehog.RecheckData.html": {
    "href": "api/Hedgehog.RecheckData.html",
    "title": "Class RecheckData | Hedgehog .NET",
    "summary": "Class RecheckData Namespace Hedgehog Assembly Hedgehog.dll type RecheckData = member deserialize : string -> RecheckData member serialize : RecheckData -> string RecheckData Methods serialize val serialize : RecheckData -> string deserialize val deserialize : string -> RecheckData"
  },
  "api/Hedgehog.RecheckInfo.html": {
    "href": "api/Hedgehog.RecheckInfo.html",
    "title": "Class RecheckInfo | Hedgehog .NET",
    "summary": "Class RecheckInfo Namespace Hedgehog Assembly Hedgehog.dll type RecheckInfo RecheckInfo"
  },
  "api/Hedgehog.Report.html": {
    "href": "api/Hedgehog.Report.html",
    "title": "Class Report | Hedgehog .NET",
    "summary": "Class Report Namespace Hedgehog Assembly Hedgehog.dll type Report = member render : Report -> string member tryRaise : Report -> unit Report Methods render val render : Report -> string tryRaise val tryRaise : Report -> unit"
  },
  "api/Hedgehog.Seed.html": {
    "href": "api/Hedgehog.Seed.html",
    "title": "Class Seed | Hedgehog .NET",
    "summary": "Class Seed Namespace Hedgehog Assembly Hedgehog.dll Splittable random number generator. type Seed = member from : uint64 -> Seed member nextBigInt : bigint -> bigint -> Seed -> bigint * Seed member nextDouble : double -> double -> Seed -> double * Seed member nextInt32 : int32 -> int32 -> Seed -> int32 * Seed member nextInt64 : int64 -> int64 -> Seed -> int64 * Seed member nextUInt64 : Seed -> uint64 * Seed member random : unit -> Seed member range : int64 * int64 member split : Seed -> Seed * Seed Seed Methods from Create a new 'Seed'. val from : uint64 -> Seed random Create a new random 'Seed'. val random : unit -> Seed range The possible range of values returned from 'next'. val range : int64 * int64 nextUInt64 Generates a random 'System.UInt64'. val nextUInt64 : Seed -> uint64 * Seed nextBigInt Generates a random bigint in the specified range. val nextBigInt : bigint -> bigint -> Seed -> bigint * Seed nextInt32 Generates a random int32 in the specified range. val nextInt32 : int32 -> int32 -> Seed -> int32 * Seed nextInt64 Generates a random int64 in the specified range. val nextInt64 : int64 -> int64 -> Seed -> int64 * Seed nextDouble Generates a random double in the specified range. val nextDouble : double -> double -> Seed -> double * Seed split Splits a 'Seed' in to two. val split : Seed -> Seed * Seed"
  },
  "api/Hedgehog.Shrink.html": {
    "href": "api/Hedgehog.Shrink.html",
    "title": "Class Shrink | Hedgehog .NET",
    "summary": "Class Shrink Namespace Hedgehog Assembly Hedgehog.dll type Shrink = member createTree : ^a -> ^a -> Tree<^a> member elems : 'a -> 'a seq -> List<'a> -> List<'a> seq member halves : ^a -> ^a seq member list : List<'a> -> List<'a> seq member removes : int -> List<'a> -> List<'a> seq member sequence : List<Tree<'a>> -> List<Tree<'a>> seq -> List<Tree<'a>> -> Tree<List<'a>> member sequenceElems : List<Tree<'a>> -> Tree<List<'a>> member sequenceList : List<Tree<'a>> -> Tree<List<'a>> member towards : ^a -> ^a -> ^a seq member towardsDouble : double -> double -> double seq Shrink Methods removes Produce all permutations of removing 'k' elements from a list. val removes : int -> List<'a> -> List<'a> seq halves Produce a list containing the progressive halving of an integral. val halves : ^a -> ^a seq list Shrink a list by edging towards the empty list. Note we always try the empty list first, as that is the optimal shrink. val list : List<'a> -> List<'a> seq elems Shrink each of the elements in input list using the supplied shrinking function. Iterative implementation to avoid stack overflow on large lists. val elems : 'a -> 'a seq -> List<'a> -> List<'a> seq sequence Turn a list of trees in to a tree of lists, using the supplied function to merge shrinking options. val sequence : List<Tree<'a>> -> List<Tree<'a>> seq -> List<Tree<'a>> -> Tree<List<'a>> sequenceList Turn a list of trees in to a tree of lists, opting to shrink both the list itself and the elements in the list during traversal. val sequenceList : List<Tree<'a>> -> Tree<List<'a>> sequenceElems Turn a list of trees in to a tree of lists, opting to shrink only the elements of the list (i.e. the size of the list will always be the same). val sequenceElems : List<Tree<'a>> -> Tree<List<'a>> towards Shrink an integral number by edging towards a destination. val towards : ^a -> ^a -> ^a seq towardsDouble Shrink a floating-point number by edging towards a destination. Note we always try the destination first, as that is the optimal shrink. val towardsDouble : double -> double -> double seq createTree val createTree : ^a -> ^a -> Tree<^a>"
  },
  "api/Hedgehog.ShrinkOutcome.html": {
    "href": "api/Hedgehog.ShrinkOutcome.html",
    "title": "Class ShrinkOutcome | Hedgehog .NET",
    "summary": "Class ShrinkOutcome Namespace Hedgehog Assembly Hedgehog.dll type ShrinkOutcome ShrinkOutcome"
  },
  "api/Hedgehog.Size.html": {
    "href": "api/Hedgehog.Size.html",
    "title": "Class Size | Hedgehog .NET",
    "summary": "Class Size Namespace Hedgehog Assembly Hedgehog.dll Tests are parameterized by the Size of the randomly-generated data, the meaning of which depends on the particular generator used. type Size Size"
  },
  "api/Hedgehog.Status.html": {
    "href": "api/Hedgehog.Status.html",
    "title": "Class Status | Hedgehog .NET",
    "summary": "Class Status Namespace Hedgehog Assembly Hedgehog.dll type Status Status"
  },
  "api/Hedgehog.ToBigInt.html": {
    "href": "api/Hedgehog.ToBigInt.html",
    "title": "Class ToBigInt | Hedgehog .NET",
    "summary": "Class ToBigInt Namespace Hedgehog Assembly Hedgehog.dll type ToBigInt = static member Invoke : ^Integral -> bigint static member ToBigInt : unativeint -> bigint static member ToBigInt : nativeint -> bigint static member ToBigInt : decimal -> bigint static member ToBigInt : double -> bigint static member ToBigInt : single -> bigint static member ToBigInt : int64 -> bigint static member ToBigInt : int32 -> bigint static member ToBigInt : int16 -> bigint static member ToBigInt : int8 -> bigint static member ToBigInt : uint64 -> bigint static member ToBigInt : uint32 -> bigint static member ToBigInt : uint16 -> bigint static member ToBigInt : uint8 -> bigint static member ToBigInt : bigint -> bigint ToBigInt Methods Invoke val Invoke : ^Integral -> bigint ToBigInt val ToBigInt : unativeint -> bigint ToBigInt val ToBigInt : nativeint -> bigint ToBigInt val ToBigInt : decimal -> bigint ToBigInt val ToBigInt : double -> bigint ToBigInt val ToBigInt : single -> bigint ToBigInt val ToBigInt : int64 -> bigint ToBigInt val ToBigInt : int32 -> bigint ToBigInt val ToBigInt : int16 -> bigint ToBigInt val ToBigInt : int8 -> bigint ToBigInt val ToBigInt : uint64 -> bigint ToBigInt val ToBigInt : uint32 -> bigint ToBigInt val ToBigInt : uint16 -> bigint ToBigInt val ToBigInt : uint8 -> bigint ToBigInt val ToBigInt : bigint -> bigint"
  },
  "api/Hedgehog.Tree.html": {
    "href": "api/Hedgehog.Tree.html",
    "title": "Class Tree | Hedgehog .NET",
    "summary": "Class Tree Namespace Hedgehog Assembly Hedgehog.dll type Tree = member addChild : Tree<'a> -> Tree<'a> -> Tree<'a> member addChildValue : 'a -> Tree<'a> -> Tree<'a> member apply : Tree<'a> -> Tree<('a -> 'b)> -> Tree<'b> member bind : 'a -> Tree<'b> -> Tree<'a> -> Tree<'b> member cata : 'a -> 'b seq -> 'b -> Tree<'a> -> 'b member create : 'a -> Tree<'a> seq -> Tree<'a> member depth : Tree<'a> -> int member duplicate : Tree<'a> -> Tree<Tree<'a>> member expand : 'a -> 'a seq -> Tree<'a> -> Tree<'a> member filter : 'a -> bool -> Tree<'a> -> Tree<'a> member filterForest : 'a -> bool -> Tree<'a> seq -> Tree<'a> seq member fold : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> -> 'b member foldForest : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> seq -> 'x member join : Tree<Tree<'a>> -> Tree<'a> member map : 'a -> 'b -> Tree<'a> -> Tree<'b> member mapWithSubtrees : 'a -> Tree<'b> seq -> 'b -> Tree<'a> -> Tree<'b> member outcome : Tree<'a> -> 'a member render : Tree<string> -> string member renderList : Tree<string> -> List<string> member shrinks : Tree<'a> -> Tree<'a> seq member singleton : 'a -> Tree<'a> member toSeq : Tree<'a> -> 'a seq member unfold : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> member unfoldForest : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> seq Tree Methods outcome The generated outcome. val outcome : Tree<'a> -> 'a shrinks All the possible shrinks of this outcome. This should be ordered smallest to largest as if property still fails with the first shrink in the list then we will commit to that path and none of the others will be tried (i.e. there is no backtracking). val shrinks : Tree<'a> -> Tree<'a> seq create val create : 'a -> Tree<'a> seq -> Tree<'a> singleton Create a tree with a single outcome and no shrinks. val singleton : 'a -> Tree<'a> addChild val addChild : Tree<'a> -> Tree<'a> -> Tree<'a> addChildValue val addChildValue : 'a -> Tree<'a> -> Tree<'a> cata val cata : 'a -> 'b seq -> 'b -> Tree<'a> -> 'b depth val depth : Tree<'a> -> int toSeq val toSeq : Tree<'a> -> 'a seq map Map over a tree. val map : 'a -> 'b -> Tree<'a> -> Tree<'b> mapWithSubtrees val mapWithSubtrees : 'a -> Tree<'b> seq -> 'b -> Tree<'a> -> Tree<'b> apply val apply : Tree<'a> -> Tree<('a -> 'b)> -> Tree<'b> bind val bind : 'a -> Tree<'b> -> Tree<'a> -> Tree<'b> join val join : Tree<Tree<'a>> -> Tree<'a> duplicate Turns a tree, in to a tree of trees. Useful for testing Hedgehog itself as it allows you to observe the shrinks for a value inside a property, while still allowing the property to shrink to a minimal counterexample. val duplicate : Tree<'a> -> Tree<Tree<'a>> fold Fold over a tree. val fold : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> -> 'b foldForest Fold over a list of trees. val foldForest : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> seq -> 'x unfold Build a tree from an unfolding function and a seed value. val unfold : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> unfoldForest Build a list of trees from an unfolding function and a seed value. val unfoldForest : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> seq expand Apply an additional unfolding function to an existing tree. The root outcome remains intact, only the shrinks are affected, this applies recursively, so shrinks can only ever be added using this function. If you want to replace the shrinks altogether, try: Tree.unfold f (outcome oldTree) val expand : 'a -> 'a seq -> Tree<'a> -> Tree<'a> filter Recursively discard any shrinks whose outcome does not pass the predicate. Note that the root outcome can never be discarded. val filter : 'a -> bool -> Tree<'a> -> Tree<'a> filterForest Recursively discard any trees whose outcome does not pass the predicate. val filterForest : 'a -> bool -> Tree<'a> seq -> Tree<'a> seq renderList val renderList : Tree<string> -> List<string> render val render : Tree<string> -> string"
  },
  "api/Hedgehog.Tree_a_.html": {
    "href": "api/Hedgehog.Tree_a_.html",
    "title": "Class Tree<'a> | Hedgehog .NET",
    "summary": "Class Tree<'a> Namespace Hedgehog Assembly Hedgehog.dll A rose tree which represents a random generated outcome, and all the ways in which it can be made smaller. type Tree<'a> Tree<'a>"
  },
  "api/Hedgehog.Xunit.AlphaNumStringAttribute.html": {
    "href": "api/Hedgehog.Xunit.AlphaNumStringAttribute.html",
    "title": "Class AlphaNumStringAttribute | Hedgehog .NET",
    "summary": "Class AlphaNumStringAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string containing alphanumeric characters. type AlphaNumStringAttribute AlphaNumStringAttribute"
  },
  "api/Hedgehog.Xunit.DateTimeAttribute.html": {
    "href": "api/Hedgehog.Xunit.DateTimeAttribute.html",
    "title": "Class DateTimeAttribute | Hedgehog .NET",
    "summary": "Class DateTimeAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a DateTime value. type DateTimeAttribute DateTimeAttribute"
  },
  "api/Hedgehog.Xunit.DateTimeOffsetAttribute.html": {
    "href": "api/Hedgehog.Xunit.DateTimeOffsetAttribute.html",
    "title": "Class DateTimeOffsetAttribute | Hedgehog .NET",
    "summary": "Class DateTimeOffsetAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a DateTimeOffset value. type DateTimeOffsetAttribute DateTimeOffsetAttribute"
  },
  "api/Hedgehog.Xunit.DomainNameAttribute.html": {
    "href": "api/Hedgehog.Xunit.DomainNameAttribute.html",
    "title": "Class DomainNameAttribute | Hedgehog .NET",
    "summary": "Class DomainNameAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a valid domain name. type DomainNameAttribute DomainNameAttribute"
  },
  "api/Hedgehog.Xunit.EmailAttribute.html": {
    "href": "api/Hedgehog.Xunit.EmailAttribute.html",
    "title": "Class EmailAttribute | Hedgehog .NET",
    "summary": "Class EmailAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a valid email address. type EmailAttribute EmailAttribute"
  },
  "api/Hedgehog.Xunit.EvenAttribute.html": {
    "href": "api/Hedgehog.Xunit.EvenAttribute.html",
    "title": "Class EvenAttribute | Hedgehog .NET",
    "summary": "Class EvenAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an even integer. type EvenAttribute EvenAttribute"
  },
  "api/Hedgehog.Xunit.GenAttribute_a_.html": {
    "href": "api/Hedgehog.Xunit.GenAttribute_a_.html",
    "title": "Class GenAttribute<'a> | Hedgehog .NET",
    "summary": "Class GenAttribute<'a> Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Set a Generator for a parameter of a test annotated with `Property` Example usage: type ConstantInt(i: int) = inherit ParameterGeneraterBaseType() override _.Generator = Gen.constant i [] let is always 2 ([] i) = Assert.StrictEqual(2, i) type GenAttribute<'a> = member Box : Gen<obj> member Generator : Gen<'a> GenAttribute<'a> Methods Box val Box : Gen<obj> Generator val Generator : Gen<'a>"
  },
  "api/Hedgehog.Xunit.IdentifierAttribute.html": {
    "href": "api/Hedgehog.Xunit.IdentifierAttribute.html",
    "title": "Class IdentifierAttribute | Hedgehog .NET",
    "summary": "Class IdentifierAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string that is a valid identifier. type IdentifierAttribute IdentifierAttribute"
  },
  "api/Hedgehog.Xunit.IntAttribute.html": {
    "href": "api/Hedgehog.Xunit.IntAttribute.html",
    "title": "Class IntAttribute | Hedgehog .NET",
    "summary": "Class IntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an integer within a specified range. type IntAttribute IntAttribute"
  },
  "api/Hedgehog.Xunit.Ipv4AddressAttribute.html": {
    "href": "api/Hedgehog.Xunit.Ipv4AddressAttribute.html",
    "title": "Class Ipv4AddressAttribute | Hedgehog .NET",
    "summary": "Class Ipv4AddressAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an IP address (IPv4). type Ipv4AddressAttribute Ipv4AddressAttribute"
  },
  "api/Hedgehog.Xunit.Ipv6AddressAttribute.html": {
    "href": "api/Hedgehog.Xunit.Ipv6AddressAttribute.html",
    "title": "Class Ipv6AddressAttribute | Hedgehog .NET",
    "summary": "Class Ipv6AddressAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an IPv6 address. type Ipv6AddressAttribute Ipv6AddressAttribute"
  },
  "api/Hedgehog.Xunit.KebabCaseAttribute.html": {
    "href": "api/Hedgehog.Xunit.KebabCaseAttribute.html",
    "title": "Class KebabCaseAttribute | Hedgehog .NET",
    "summary": "Class KebabCaseAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string in kebab-case. type KebabCaseAttribute KebabCaseAttribute"
  },
  "api/Hedgehog.Xunit.LatinNameAttribute.html": {
    "href": "api/Hedgehog.Xunit.LatinNameAttribute.html",
    "title": "Class LatinNameAttribute | Hedgehog .NET",
    "summary": "Class LatinNameAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string representing a Latin name. type LatinNameAttribute LatinNameAttribute"
  },
  "api/Hedgehog.Xunit.NonNegativeIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.NonNegativeIntAttribute.html",
    "title": "Class NonNegativeIntAttribute | Hedgehog .NET",
    "summary": "Class NonNegativeIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a non-negative integer. type NonNegativeIntAttribute NonNegativeIntAttribute"
  },
  "api/Hedgehog.Xunit.NonZeroIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.NonZeroIntAttribute.html",
    "title": "Class NonZeroIntAttribute | Hedgehog .NET",
    "summary": "Class NonZeroIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a non-zero integer. type NonZeroIntAttribute NonZeroIntAttribute"
  },
  "api/Hedgehog.Xunit.OddAttribute.html": {
    "href": "api/Hedgehog.Xunit.OddAttribute.html",
    "title": "Class OddAttribute | Hedgehog .NET",
    "summary": "Class OddAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an odd integer. type OddAttribute OddAttribute"
  },
  "api/Hedgehog.Xunit.PositiveIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.PositiveIntAttribute.html",
    "title": "Class PositiveIntAttribute | Hedgehog .NET",
    "summary": "Class PositiveIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a positive integer. type PositiveIntAttribute PositiveIntAttribute"
  },
  "api/Hedgehog.Xunit.PropertiesAttribute.html": {
    "href": "api/Hedgehog.Xunit.PropertiesAttribute.html",
    "title": "Class PropertiesAttribute | Hedgehog .NET",
    "summary": "Class PropertiesAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Set a default AutoGenConfig or for all [ ] attributed methods in this class/module type PropertiesAttribute = member AutoGenConfig : unit member AutoGenConfigArgs : unit member Shrinks : unit member Size : unit member Tests : unit PropertiesAttribute Methods AutoGenConfig val AutoGenConfig : unit AutoGenConfigArgs val AutoGenConfigArgs : unit Tests val Tests : unit Size val Size : unit Shrinks val Shrinks : unit"
  },
  "api/Hedgehog.Xunit.PropertyAttribute.html": {
    "href": "api/Hedgehog.Xunit.PropertyAttribute.html",
    "title": "Class PropertyAttribute | Hedgehog .NET",
    "summary": "Class PropertyAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates arguments using GenX.auto (or autoWith if you provide an AutoGenConfig), then runs Property.check type PropertyAttribute = member AutoGenConfig : unit member AutoGenConfigArgs : unit member Shrinks : unit member Size : unit member Tests : unit PropertyAttribute Methods AutoGenConfig val AutoGenConfig : unit AutoGenConfigArgs val AutoGenConfigArgs : unit Tests val Tests : unit Size val Size : unit Shrinks val Shrinks : unit"
  },
  "api/Hedgehog.Xunit.PropertyFailedException.html": {
    "href": "api/Hedgehog.Xunit.PropertyFailedException.html",
    "title": "Class PropertyFailedException | Hedgehog .NET",
    "summary": "Class PropertyFailedException Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Exception for property test failures that produces clean output type PropertyFailedException PropertyFailedException"
  },
  "api/Hedgehog.Xunit.RecheckAttribute.html": {
    "href": "api/Hedgehog.Xunit.RecheckAttribute.html",
    "title": "Class RecheckAttribute | Hedgehog .NET",
    "summary": "Class RecheckAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Runs Property.reportRecheck type RecheckAttribute RecheckAttribute"
  },
  "api/Hedgehog.Xunit.SnakeCaseAttribute.html": {
    "href": "api/Hedgehog.Xunit.SnakeCaseAttribute.html",
    "title": "Class SnakeCaseAttribute | Hedgehog .NET",
    "summary": "Class SnakeCaseAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string in snake_case. type SnakeCaseAttribute SnakeCaseAttribute"
  },
  "api/Hedgehog.Xunit.UnicodeStringAttribute.html": {
    "href": "api/Hedgehog.Xunit.UnicodeStringAttribute.html",
    "title": "Class UnicodeStringAttribute | Hedgehog .NET",
    "summary": "Class UnicodeStringAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string containing unicode characters. type UnicodeStringAttribute UnicodeStringAttribute"
  },
  "api/Hedgehog.discards.html": {
    "href": "api/Hedgehog.discards.html",
    "title": "Class discards | Hedgehog .NET",
    "summary": "Class discards Namespace Hedgehog Assembly Hedgehog.dll type discards discards"
  },
  "api/Hedgehog.shrinks.html": {
    "href": "api/Hedgehog.shrinks.html",
    "title": "Class shrinks | Hedgehog .NET",
    "summary": "Class shrinks Namespace Hedgehog Assembly Hedgehog.dll type shrinks shrinks"
  },
  "api/Hedgehog.tests.html": {
    "href": "api/Hedgehog.tests.html",
    "title": "Class tests | Hedgehog .NET",
    "summary": "Class tests Namespace Hedgehog Assembly Hedgehog.dll type tests tests"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Hedgehog .NET",
    "summary": "API Documentation For F# Users To use Hedgehog in F#, import the following namespaces: open Hedgehog open Hedgehog.FSharp Hedgehog.FSharp.Gen Hedgehog.FSharp.Property Hedgehog.FSharp.Range For C# Users To use Hedgehog in C#, import the following namespaces: using Hedgehog; using Hedgehog.Linq; Hedgehog.Linq.Gen Hedgehog.Linq.Property Hedgehog.Linq.Range Core Types The most important types in Hedgehog are: Gen<T> - A generator for random values of type T. Generators can be composed and transformed to create complex data generators. Range<T> - Defines the range from which values are generated and controls shrinking behavior during property testing. Property<T> - Represents a property to be tested. Properties combine generators with assertions to verify that certain conditions hold for all generated test cases."
  },
  "articles/auto-generation.html": {
    "href": "articles/auto-generation.html",
    "title": "Auto-Generation | Hedgehog .NET",
    "summary": "Auto-Generation Warning Auto-generation is not available when using Fable. You must write custom generators manually for Fable projects. Hedgehog can automatically generate test data for your types without manually writing generators. This feature works with F# records, discriminated unions, tuples, and C# classes. Basic Usage F# C# For simple F# types, use Gen.auto<'T>: open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int Email: string } type Status = | Active | Inactive | Pending of reason: string property { let! user = Gen.auto<User> let! status = Gen.auto<Status> return user.Age >= 0 && user.Name.Length > 0 } |> Property.check Auto-generation works with C# classes, records, and structs: using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age, string Email); public enum Status { Active, Inactive, Pending } var property = from user in Gen.Auto<User>().ForAll() from status in Gen.Auto<Status>().ForAll() select user.Age >= 0 && user.Name.Length > 0; property.Check(); Supported Types Auto-generation works with: Primitives: int, string, bool, decimal, DateTime, etc. Records: F# records and C# record types Discriminated Unions: F# union types Tuples: Both F# and C# tuples Collections: List, Array, Set, Map, Dictionary, IEnumerable Options: Option<'T>, ValueOption<'T>, Nullable<'T> Results: Result<'T, 'TError> Classes: C# classes with constructors or mutable properties Nested Types: Any combination of the above Customizing Auto-Generation Using AutoGenConfig When you need to customize how types are generated, use Gen.autoWith with an AutoGenConfig: F# C# open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int Email: string } // Create a custom config let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 5 20) Gen.alpha) // Custom string generator |> AutoGenConfig.addGenerator (Gen.int32 (Range.linear 18 100)) // Ages between 18-100 property { let! user = Gen.autoWith<User> config return user.Age >= 18 && user.Name.Length >= 5 } |> Property.check using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age, string Email); // Create a custom config var config = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(5, 20), Gen.Alpha)) // Custom string generator .AddGenerator(Gen.Int32(Range.LinearInt32(18, 100))); // Ages between 18-100 var property = from user in Gen.AutoWith<User>(config).ForAll() select user.Age >= 18 && user.Name.Length >= 5; property.Check(); Registering Custom Generators For more control, create a custom generator class with static methods that match the names of your types. Hedgehog will automatically discover and use these generators when you register the class. How Generator Classes Work When you call AutoGenConfig.addGenerators<T>, Hedgehog: Scans the class T for public static methods Finds methods that return Gen<T> (for any type T) Uses these methods when generating values of type T Method Requirements: Must be public static Must return Gen<T> where T is the type you want to generate Can optionally accept parameters of type IAutoGenContext or Gen<TValue> for generic types Examples: A method returning Gen<Email> will be used to generate Email values A method returning Gen<User> will be used to generate User values For generic types like Gen<List<T>>, the method can accept a Gen<T> parameter Example F# C# open Hedgehog open Hedgehog.FSharp open System type Email = Email of string type User = { Name: string Email: Email RegisteredAt: DateTime } // Custom generators class type MyGenerators = // Generator for Email type - return type is Gen<Email> static member Email() : Gen<Email> = gen { let! name = Gen.string (Range.linear 3 10) Gen.alphaNum let! domain = Gen.item [\"com\"; \"net\"; \"org\"] return Email $\"{name}@example.{domain}\" } // Generator for DateTime - return type is Gen<DateTime> static member DateTime() : Gen<DateTime> = gen { let! days = Gen.int32 (Range.linear 0 365) return DateTime.Now.AddDays(-float days) } // Register the custom generators let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<MyGenerators> // Now Gen.autoWith will use MyGenerators.Email() for Email types // and MyGenerators.DateTime() for DateTime types property { let! user = Gen.autoWith<User> config let (Email email) = user.Email return email.Contains(\"@\") && user.RegisteredAt <= DateTime.Now } |> Property.check using Hedgehog; using Hedgehog.Linq; using System; public record Email(string Value); public record User(string Name, Email Email, DateTime RegisteredAt); // Custom generators class public class MyGenerators { // Generator for Email type - return type is Gen<Email> public static Gen<Email> Email() => from name in Gen.AlphaNum.String(Range.LinearInt32(3, 10)) from domain in Gen.Item(\"com\", \"net\", \"org\") select new Email($\"{name}@example.{domain}\"); // Generator for DateTime - return type is Gen<DateTime> public static Gen<DateTime> DateTime() => from days in Gen.Int32(Range.LinearInt32(0, 365)) select System.DateTime.Now.AddDays(-days); } // Register the custom generators var config = AutoGenConfig.Defaults .AddGenerators<MyGenerators>(); // Now Gen.AutoWith will use MyGenerators.Email() for Email types // and MyGenerators.DateTime() for DateTime types var property = from user in Gen.AutoWith<User>(config).ForAll() select user.Email.Value.Contains(\"@\") && user.RegisteredAt <= System.DateTime.Now; property.Check(); Generator Method Signatures Custom generator methods must follow specific patterns: Parameterless Generators For types without generic parameters: F# C# static member TypeName() : Gen<TypeName> = ... public static Gen<TypeName> TypeName() => ... Generic Type Generators For generic types, accept Gen<T> parameters for each type parameter: F# C# type GenericGenerators = // Simple generic type static member MyGenericType<'a>(valueGen: Gen<'a>) : Gen<MyGenericType<'a>> = valueGen |> Gen.map (fun x -> MyGenericType(x)) public class GenericGenerators { // Simple generic type public static Gen<MyGenericType<A>> MyGenericType<A>(Gen<A> valueGen) => valueGen.Select(x => new MyGenericType<A>(x)); } Using AutoGenContext For recursive types or when you need access to collection range and recursion depth, use AutoGenContext: F# C# type GenericGenerators = // Access to recursion control via AutoGenContext static member ImmutableList<'a>(context: AutoGenContext, valueGen: Gen<'a>) : Gen<ImmutableList<'a>> = if context.CanRecurse then valueGen |> Gen.list context.CollectionRange |> Gen.map ImmutableList.CreateRange else Gen.constant ImmutableList<'a>.Empty let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<GenericGenerators> public class GenericGenerators { // Access to recursion control via AutoGenContext public static Gen<ImmutableList<A>> ImmutableList<A>(AutoGenContext context, Gen<A> valueGen) => context.CanRecurse ? valueGen.List(context.CollectionRange).Select(System.Collections.Immutable.ImmutableList.CreateRange) : Gen.Constant(System.Collections.Immutable.ImmutableList<A>.Empty); } var config = AutoGenConfig.Defaults .AddGenerators<GenericGenerators>(); Advanced Scenarios Multiple Configurations You can create different configurations for different test scenarios: F# C# let smallDataConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 0 10) Gen.alpha) let largeDataConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 0 1000) Gen.unicode) var smallDataConfig = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(0, 10), Gen.Alpha)); var largeDataConfig = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(0, 1000), Gen.Unicode)); Best Practices Start with Gen.auto - Use the default auto-generation first, only customize when needed Register generators once - Create a shared AutoGenConfig for your test suite Use type safety - Let the type system guide generator creation Test your generators - Verify custom generators produce valid data Leverage AutoGenContext - For recursive types, use AutoGenContext to control depth and collection sizes"
  },
  "articles/best-practices.html": {
    "href": "articles/best-practices.html",
    "title": "Property-Based Testing Best Practices | Hedgehog .NET",
    "summary": "Property-Based Testing Best Practices The Mental Shift: From Examples to Properties Property-based testing requires a fundamental shift in how you think about testing. Instead of asking \"what specific examples should I test?\", you ask \"what is always true about my code?\" Example-Based vs Property-Based Thinking Example-Based Property-Based \"Test with values 1, 5, and 100\" \"Test with any positive integer\" \"Check this specific case\" \"What's always true?\" \"This input gives this output\" \"What relationship holds between input and output?\" \"Cover branches\" \"Cover invariants and properties\" The Core Philosophy Properties over Examples: Seek universal truths that hold for all valid inputs, not just carefully chosen examples. Generative Thinking: Think about the space of all possible inputs. What happens with empty collections? Maximum values? Negative numbers? Unicode characters? Shrinking for Clarity: When tests fail, the framework automatically finds the minimal failing case, revealing the true cause. Specification by Properties: Properties serve as executable specifications that document how your code should behave. Essential over Exhaustive: Focus on minimal, non-overlapping properties that provide unique value. Quality over quantity. Discovering Properties: A Systematic Approach Step 1: Understand the Code's Contracts Before writing any test, ask these fundamental questions: What are the preconditions? (What inputs are valid?) What are the postconditions? (What does the code guarantee about outputs?) What invariants must always hold? (What never changes?) What relationships exist between inputs and outputs? What business rules must never be violated? Step 2: Use Property Pattern Recognition Start with the easiest patterns to identify: Type Properties: Does it return the expected type? Boundary Properties: What happens at edges (empty, zero, max, null)? Idempotent Properties: Does doing it twice = doing it once? Inverse Properties: Can you undo the operation? Invariant Properties: What never changes? Commutative Properties: Does order matter? Business Rule Properties: What domain rules must hold? The Seven Core Property Patterns 1. Invariants: What Never Changes Pattern: Properties that always hold about the result, regardless of input. When to use: When something about the output must always be true. Questions to ask: What properties are preserved by this operation? What must always be true about the result? What can't possibly change? Examples: Sorting preserves all elements (count and contents) Mapping over a list preserves its length Filtering never increases collection size String trimming never increases length F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Sort should preserve all elements`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let sorted = List.sort list test <@ List.length sorted = List.length list @> test <@ List.forall (fun x -> List.contains x sorted) list @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void Sort_Should_Preserve_All_Elements() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let sorted = list.OrderBy(x => x).ToList() select sorted.Count == list.Count && list.All(x => sorted.Contains(x)); property.Check(); } 2. Business Rules: Domain Constraints Pattern: Domain-specific rules that must never be violated. When to use: When you have business logic that defines what's valid. Questions to ask: What business rules must never be broken? What would make the output invalid in the business domain? What constraints does the domain impose? Examples: Discounts never exceed the original price Age must be within valid range (0-120) Account balance can't go negative (unless overdraft allowed) Percentages must be between 0 and 100 F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote let priceGen = Gen.int32 (Range.constant 1 10000) |> Gen.map (fun x -> decimal x / 100m) let discountGen = Gen.int32 (Range.constant 0 100) |> Gen.map (fun x -> decimal x / 100m) [<Fact>] let ``Apply discount should never exceed original price`` () = property { let! price = priceGen let! discountPercent = discountGen let discounted = applyDiscount price discountPercent test <@ discounted <= price @> test <@ discounted >= 0m @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var priceGen = Gen.Int32(Range.Constant(1, 10000)).Select(x => (decimal)x / 100); var discountGen = Gen.Int32(Range.Constant(0, 100)).Select(x => (decimal)x / 100); [Fact] public void ApplyDiscount_Should_Never_Exceed_Original_Price() { var property = from price in priceGen.ForAll() from discountPercent in discountGen.ForAll() let discounted = ApplyDiscount(price, discountPercent) select discounted <= price && discounted >= 0; property.Check(); } 3. Inverse/Roundtrip: Reversible Operations Pattern: Operations that undo each other should return to the original state. When to use: When you have encode/decode, serialize/deserialize, compress/decompress, encrypt/decrypt, or any reversible transformation. Questions to ask: Can I undo this operation? Is there a reverse operation? Should encodedecode return the original? Examples: SerializeDeserialize = identity EncodeDecode = identity CompressDecompress = identity AddSubtract = identity F# C# open Hedgehog open Hedgehog.FSharp open System.Text.Json open Swensen.Unquote [<Fact>] let ``Serialize should roundtrip when deserializing`` () = property { let! person = Gen.auto<Person> let json = JsonSerializer.Serialize(person) let restored = JsonSerializer.Deserialize<Person>(json) test <@ restored = person @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var personGen = /* define your Person generator */; [Fact] public void Serialize_Should_RoundTrip_When_Deserializing() { var property = from person in personGen.ForAll() let json = JsonSerializer.Serialize(person) let restored = JsonSerializer.Deserialize<Person>(json) select restored.Equals(person); property.Check(); } 4. Idempotence: Applying N Times = Applying Once Pattern: Applying an operation multiple times has the same effect as applying it once. When to use: When operations normalize, clean, or reach a stable state. Questions to ask: Does applying this twice change the result? Does the operation stabilize? Is this a normalization? Examples: Normalize(Normalize(x)) = Normalize(x) ToUpper(ToUpper(s)) = ToUpper(s) Trim(Trim(s)) = Trim(s) Absolute value is idempotent: Abs(Abs(x)) = Abs(x) F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Normalize should be idempotent`` () = property { let! text = Gen.string (Range.linear 0 100) Gen.unicode let once = normalize text let twice = normalize once test <@ twice = once @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void Normalize_Should_Be_Idempotent() { var property = from text in Gen.Unicode.String(Range.LinearInt32(0, 100)).ForAll() let once = Normalize(text) let twice = Normalize(once) select twice == once; property.Check(); } 5. Oracle: Comparing Against Known Truth Pattern: Compare your implementation against a reference implementation or mathematical truth. When to use: When you have a trusted implementation (standard library, mathematical formula, legacy system). Questions to ask: Is there a reference implementation? Can I use a mathematical formula? Is there a simpler (but slower) correct implementation? Examples: Custom sort should match standard library sort Square root: sqrt(x)  x Custom parser should match standard parser Optimized algorithm should match naive implementation F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Custom sort should match standard sort`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let custom = myCustomSort list let standard = List.sort list test <@ custom = standard @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void CustomSort_Should_Match_StandardSort() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let custom = MyCustomSort(list) let standard = list.OrderBy(x => x).ToList() select custom.SequenceEqual(standard); property.Check(); } 6. Metamorphic: How Input Changes Affect Output Pattern: How transforming the input should transform the output. When to use: When you understand the mathematical or logical relationship between input and output transformations. Questions to ask: If I double the input, what happens to the output? If I reverse the input, how does the output change? What transformations have predictable effects? Examples: Doubling all elements doubles the sum Reversing input twice returns original Adding constant to all elements adds constant  count to sum Multiplying prices by 2 multiplies total by 2 F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Doubling elements should double the sum`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let originalSum = List.sum list let doubledSum = list |> List.map ((*) 2) |> List.sum test <@ doubledSum = originalSum * 2 @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void DoublingElements_Should_Double_The_Sum() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let originalSum = list.Sum() let doubledSum = list.Select(x => x * 2).Sum() select doubledSum == originalSum * 2; property.Check(); } 7. Model-Based: Generate Valid Output First Pattern: Generate the expected output first, then derive the input that should produce it. When to use: When it's easier to generate valid output than to generate valid input, or when you want to avoid complex filtering. Questions to ask: What does valid output look like? Can I work backwards from output to input? Is it easier to generate the result than the cause? Examples: Generate event  derive command that should produce it Generate normalized form  derive denormalized input Generate valid parse result  derive string that should parse to it F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Create account command should produce expected event`` () = property { let! expectedEvent = Gen.auto<AccountCreatedEvent> // Work backwards: derive command from event let command = { AccountId = expectedEvent.AccountId Name = expectedEvent.Name InitialBalance = expectedEvent.InitialBalance } let actualEvent = accountService.Handle command test <@ actualEvent = expectedEvent @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var eventGen = /* define your AccountCreatedEvent generator */; [Fact] public void CreateAccountCommand_Should_Produce_Expected_Event() { var property = from expectedEvent in eventGen.ForAll() // Work backwards: derive command from event let command = new CreateAccountCommand( expectedEvent.AccountId, expectedEvent.Name, expectedEvent.InitialBalance) let actualEvent = accountService.Handle(command) select actualEvent.Equals(expectedEvent); property.Check(); } Avoiding Overlapping Properties Critical Rule: Before implementing tests, ensure your properties are distinct and non-overlapping. The Problem with Overlapping Properties Multiple properties that verify the same underlying truth waste effort and create maintenance burden without adding value. The Elimination Workflow Discovery: List ALL candidate properties you can think of Analysis: Examine relationships between properties Elimination: Remove redundancy using these criteria: If property A failing  property B must fail: Keep the stronger one only If property A is a special case of B: Keep B only If same invariant, different wording: Keep the clearest one Proposal: Present minimal set with justification Example: Sorting Function Initial candidates: Sorted list contains all original elements Sorted list has same count as original Sorted list has same elements with same frequencies Sorted list is in ascending order Sorting twice gives same result as sorting once Analysis: Property 2 is weaker than property 1 (1 failing  2 fails) Property 3 is weaker than property 1 (1 failing  3 fails) Property 4 tests a different aspect (ordering, not preservation) Property 5 tests a different aspect (idempotence) Final minimal set: Sorted list contains all original elements (covers count and frequencies) Sorted list is in ascending order Sorting twice gives same result as sorting once Designing Effective Generators When to Use Auto-Generation Use auto-generation (default) when: Testing with primitive types (int, string, bool, etc.) Working with simple domain objects with public constructors Testing collections of simple types You want to explore the full input space without constraints When to Create Custom Generators Create custom generators when: You need constrained values (positive numbers, valid emails, etc.) Testing complex domain objects with invariants Values must follow specific business rules Working with recursive data structures You need specific distributions (e.g., mostly small values, rare large values) Generator Design Principles Coverage: Generate the full valid input space, including edge cases (empty, zero, max, min, null, etc.) Relevance: Focus on valid inputs. Test invalid cases separately with explicit invalid generators. Composition: Build complex generators from simple ones using LINQ. Realistic: Generate data that resembles production scenarios, not just random noise. Avoid Over-Filtering: Don't use where clauses that reject most generated values. The Filtering Anti-Pattern  Bad - Filtering rejects many values: F# C# open Hedgehog open Hedgehog.FSharp // Bad: Rejects ~50% of generated values gen { let! x = Gen.int32 (Range.constant -1000 1000) where (x > 0) return x } // Bad: Rejects 50% of values gen { let! x = Gen.int32 (Range.constant -100 100) where (x % 2 = 0) return x } using Hedgehog; using Hedgehog.Linq; // Bad: Rejects ~50% of generated values from x in Gen.Int32(Range.Constant(-1000, 1000)) where x > 0 select x // Bad: Rejects 50% of values from x in Gen.Int32(Range.Constant(-100, 100)) where x % 2 == 0 select x  Good - Generate only valid values: F# C# open Hedgehog open Hedgehog.FSharp // Good: Only generates positive values Gen.int32 (Range.constant 1 1000) // Good: Only generates even values Gen.int32 (Range.constantBounded ()) |> Gen.map (fun x -> x &&& ~~~1) using Hedgehog; using Hedgehog.Linq; // Good: Only generates positive values Gen.Int32(Range.Constant(1, 1000)) // Good: Only generates even values Gen.Int32(Range.ConstantBoundedInt32()).Select(x => x & ~1) Rule of Thumb: If your generator rejects more than 10-20% of values, redesign it to generate valid values directly. Common Anti-Patterns to Avoid Testing Anti-Patterns  Testing Implementation Details: Don't test how code works, test what it does. Bad: Checking internal state or private fields Good: Checking observable behavior and guarantees  Over-Constraining Generators: Don't make generators so specific they only produce passing values. Bad: Only generating sorted lists when testing a sort function Good: Generating any list and asserting it becomes sorted  Hidden Assumptions: Don't assume specific generated values in your assertions. Bad: result.Should().Be(42) in a property test Good: result.Should().BeGreaterThan(input)  Example-Based Thinking in Property Tests: Don't test specific values; test relationships. Bad: [Property] void Test(int x) => Foo(5).Should().Be(10); Good: [Property] void Test(int x) => Foo(x).Should().Be(x * 2);  Ignoring Shrinking Output: The minimal failing case is the key to understanding the bug. Don't just see \"test failed\" Examine the shrunk input to understand why  Too Many Assertions in One Test: Keep property tests focused on a single property. Bad: Testing 5 different invariants in one test Good: One property per test, 5 focused tests  Redundant Properties: Don't create multiple tests that verify the same underlying property. Analyze relationships between properties Keep only distinct, non-overlapping tests  Weak Properties Instead of Strong Ones: Don't write several weak properties when one stronger property would suffice. Bad: Separate tests for count, for element presence, for no duplicates Good: One test asserting \"contains all original elements\" (implies count, presence, and frequency) Generator Anti-Patterns  Insufficient Coverage: Generators that miss important edge cases. Consider: empty, zero, negative, max, min, null, whitespace, Unicode  Unrealistic Data: Generating values that would never occur in production. Bad: Random strings that don't resemble real data Good: Strings that look like actual names, emails, addresses  Over-Filtering: Using where that rejects most generated values (>50% rejection). See \"The Filtering Anti-Pattern\" section above The Property Discovery Checklist When analyzing code to test, systematically ask: Universal Truths:  What's always true about the output?  What can't possibly happen if the code is correct?  What would it mean for this to be correct? Reversibility:  Can I undo this operation?  Is there an inverse operation? Stability:  Does doing this twice differ from once?  Does it reach a stable state? Relationships:  What relationships must hold between input and output?  How do input transformations affect output? Boundaries:  What happens at the edges (empty, zero, max, null)?  What separates valid from invalid? Domain Rules:  What business rules must never be violated?  What domain constraints exist? Comparison:  Is there a reference implementation to compare against?  Is there a mathematical truth to verify? Practical Workflow 1. Start Simple Begin with the most obvious property and auto-generated parameters. 2. Run and Observe Let the generator explore the input space. Pay attention to failures. 3. Analyze Shrinking When tests fail, examine the minimal failing case. What does it reveal? 4. Refine Generators If auto-generation is too broad, add constraints with custom generators. 5. Iterate Add more properties one at a time, ensuring each adds unique value. 6. Review for Overlap Before finalizing, eliminate redundant properties. The Power of Property-Based Testing Coverage: One property test exercises your code with hundreds of different inputs. Edge Cases: Generators automatically explore boundaries you might not think of. Documentation: Properties serve as executable specifications. Regression Protection: Properties continue to verify behavior as code evolves. Bug Finding: Random exploration often finds bugs that example-based tests miss. Minimal Failures: Shrinking reveals the simplest case that breaks your code. Remember: The goal is not to test examples, but to discover and verify universal truths about your code. Think in properties, not examples."
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | Hedgehog .NET",
    "summary": "Getting Started This guide will help you write your first property-based tests with Hedgehog in just a few minutes. Installation Install Hedgehog from NuGet: dotnet add package Hedgehog Your First Property Test Let's test a simple property: reversing a list twice should give you the original list. F# C# open Hedgehog open Hedgehog.FSharp let propReverse = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } // Run it Property.check propReverse using Hedgehog; using Hedgehog.Linq; var propReverse = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); // Run it propReverse.Check(); Run this and you'll see: +++ OK, passed 100 tests. Understanding What Happened Generator: Gen.list (or Gen.Alpha.List) created random lists of characters Range: Range.linear 0 100 specified lists can have 0 to 100 elements Property: The return statement (or select) defines what should be true for all inputs Testing: Hedgehog generated 100 random lists and verified the property held for each Writing Better Properties Good properties describe invariants - things that should always be true. Here are some patterns: Inverse operations: f(g(x)) = x encode(decode(x)) = x serialize(deserialize(x)) = x Commutative operations: f(a, b) = f(b, a) x + y = y + x min(a, b) = min(b, a) Idempotence: f(f(x)) = f(x) sort(sort(xs)) = sort(xs) distinct(distinct(xs)) = distinct(xs) Preservation: Properties that don't change length(reverse(xs)) = length(xs) sum(map(f, xs)) = map(f, sum(xs)) // if f is linear Seeing Shrinking in Action Let's introduce a bug and see how Hedgehog finds the minimal failing case: F# C# open Hedgehog open Hedgehog.FSharp // Buggy function - fails for numbers > 100 let tryAdd a b = if a > 100 then None else Some(a + b) let propAdd = property { let! a = Gen.int32 (Range.constantBounded ()) let! b = Gen.int32 (Range.constantBounded ()) return tryAdd a b = Some(a + b) } Property.check propAdd using Hedgehog; using Hedgehog.Linq; // Buggy function - fails for numbers > 100 int? TryAdd(int a, int b) { if (a > 100) return null; return a + b; } var propAdd = from a in Gen.Int32(Range.ConstantBoundedInt32()).ForAll() from b in Gen.Int32(Range.ConstantBoundedInt32()).ForAll() select TryAdd(a, b) == a + b; propAdd.Check(); Output: *** Failed! Falsifiable (after 16 tests and 5 shrinks): 101 0 Notice Hedgehog didn't just find a failing case - it found the smallest one: a = 101, b = 0. This is automatic shrinking in action. Integration with Test Frameworks xUnit F# C# open Xunit open Hedgehog open Hedgehog.FSharp [<Fact>] let ``reverse twice is identity`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check using Xunit; using Hedgehog; using Hedgehog.Linq; [Fact] public void ReverseTwiceIsIdentity() { var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } NUnit F# C# open NUnit.Framework open Hedgehog open Hedgehog.FSharp [<Test>] let ``reverse twice is identity`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check using NUnit.Framework; using Hedgehog; using Hedgehog.Linq; [Test] public void ReverseTwiceIsIdentity() { var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } Expecto (F# only) open Expecto open Hedgehog open Hedgehog.FSharp let tests = testList \"properties\" [ testCase \"reverse twice is identity\" <| fun _ -> property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check ] [<EntryPoint>] let main args = runTestsWithArgs defaultConfig args tests Building Custom Generators You can compose generators to create complex test data: F# C# open System.Net open Hedgehog open Hedgehog.FSharp // Generator for IP addresses let ipAddressGen = gen { let! bytes = Gen.array (Range.singleton 4) Gen.byte return IPAddress bytes } // Generator for valid email-like strings let emailGen = gen { let! name = Gen.string (Range.linear 1 20) Gen.alphaNum let! domain = Gen.item [\"com\"; \"net\"; \"org\"] return $\"{name}@example.{domain}\" } // Use them in properties property { let! ip = ipAddressGen let! email = emailGen return ip.ToString().Length > 0 && email.Contains(\"@\") } |> Property.check using System.Net; using Hedgehog; using Hedgehog.Linq; // Generator for IP addresses var ipAddressGen = from bytes in Gen.Byte.Array(Range.Singleton(4)) select new IPAddress(bytes); // Generator for valid email-like strings var emailGen = from name in Gen.AlphaNum.String(Range.LinearInt32(1, 20)) from domain in Gen.Item(\"com\", \"net\", \"org\") select $\"{name}@example.{domain}\"; // Use them in properties var property = from ip in ipAddressGen.ForAll() from email in emailGen.ForAll() select ip.ToString().Length > 0 && email.Contains(\"@\"); property.Check(); Auto-Generating Test Data Hedgehog can automatically generate test data for your types: F# C# open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int } property { let! user = Gen.auto<User> return user.Age >= 0 } |> Property.check using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age); var property = from user in Gen.Auto<User>().ForAll() select user.Age >= 0; property.Check(); Auto-generation works with records, unions, tuples, classes, and collections. For advanced customization and registering custom generators, see the Auto-Generation Guide. Controlling Test Runs You can customize how many tests to run and other settings: F# C# open Hedgehog open Hedgehog.FSharp let config = PropertyConfig.defaults |> PropertyConfig.withTests 1000<tests> property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.checkWith config using Hedgehog; using Hedgehog.Linq; var config = PropertyConfig.Defaults .WithTests(PropertyConfig.Test.Create(1000)); var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(config); Common Patterns Re-running Failing Tests When a property fails, Hedgehog provides a seed that you can use to reproduce the exact failure: F# C# open Hedgehog open Hedgehog.FSharp let prop = property { let! x = Gen.int32 (Range.constant 0 1000) return x < 500 // Will fail eventually } // First run - will fail and show a seed Property.check prop // Example output: // *** Failed! Falsifiable (after 6 tests and 1 shrink): // 500 // This failure can be reproduced by running: // > Property.recheck \"1a2b3c4d\" prop // Recheck with the specific seed Property.recheck \"1a2b3c4d\" prop using Hedgehog; using Hedgehog.Linq; var prop = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() select x < 500; // Will fail eventually // First run - will fail and show a seed prop.Check(); // Example output: // *** Failed! Falsifiable (after 6 tests and 1 shrink): // 500 // This failure can be reproduced by running: // > prop.Recheck(\"1a2b3c4d\") // Recheck with the specific seed prop.Recheck(\"1a2b3c4d\"); This is especially useful when: Debugging intermittent failures Sharing reproducible test cases with teammates Verifying a bug fix works for the specific failing case Adding Debug Information Use counterexample to add context when tests fail: F# C# open Hedgehog open Hedgehog.FSharp property { let! x = Gen.int32 (Range.constant 0 1000) let! y = Gen.int32 (Range.constant -100 1000) counterexample $\"x = {x}, y = {y}, x * y = {x * y}\" return x * y >= 0 } |> Property.check using Hedgehog; using Hedgehog.Linq; var property = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() from y in Gen.Int32(Range.Constant(-100, 1000)).ForAll() from _ in Property.CounterExample(() => $\"x = {x}, y = {y}, x * y = {x * y}\") select x * y >= 0; property.Check(); *** Failed! Falsifiable (after 20 tests and 11 shrinks): 1 -100 x = 1, y = -100, x * y = -100 Additional Resources Hedgehog.Xunit - Enhanced xUnit integration with [<Property>] attributes You're now ready to start finding bugs automatically with property-based testing!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Hedgehog .NET | Hedgehog .NET",
    "summary": "Hedgehog .NET Hedgehog will eat all your bugs. Hedgehog is a modern property-based testing system for .NET, designed to help you release with confidence by automatically finding edge cases you didn't think of. What is Property-Based Testing? Instead of writing individual test cases with specific inputs and expected outputs, property-based testing lets you describe properties that should hold true for all inputs: reverse (reverse xs) = xs, xs :: [] This reads as: \"the reverse of the reverse of a list equals the original list  for all lists of any type.\" In Hedgehog, you express this property and the framework generates hundreds of random test cases automatically: F# C# property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.render var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); +++ OK, passed 100 tests. Why Hedgehog? Integrated Shrinking When a property fails, Hedgehog automatically simplifies the failing input to find the smallest counterexample. Unlike older property-based testing libraries that shrink values separately from generation, Hedgehog uses integrated shrinking  shrinking is built into generators, guaranteeing that shrunk values obey the same invariants as the generated values. This means you get minimal, actionable error reports: F# C# property { let! xs = Gen.list (Range.linear 0 100) version return xs |> List.rev = xs } |> Property.render var property = from xs in versionGen.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().SequenceEqual(xs); property.Check(); *** Failed! Falsifiable (after 3 tests and 6 shrinks): [0.0.0; 0.0.1] Even complex types like System.Version shrink automatically to their simplest failing case. Expressive Syntax F# C# Hedgehog provides gen and property computation expressions that feel natural in F#: let ipAddressGen = gen { let! addr = Gen.array (Range.singleton 4) Gen.byte return System.Net.IPAddress addr } Hedgehog provides support for LINQ syntax that allows writing generators and properties easier: var ipAddressGen = from addr in Gen.Byte.Array(Range.Singleton(4)) select new System.Net.IPAddress(addr); Precise Control Range combinators let you control the scope of generated values: Gen.int32 (Range.constant 0 100) // Always between 0-100 Gen.int32 (Range.linear 0 100) // Scales with test size Gen.list (Range.exponential 1 1000) g // Exponential growth Core Concepts Properties are invariants that should hold for all inputs. They're expressed as functions that return bool or Property<bool>. Generators produce random values of a given type. Hedgehog includes generators for primitives and combinators to build generators for complex types. Generators are composable using map, bind, and other familiar operations. Shrinking happens automatically when a property fails. Hedgehog finds progressively smaller inputs that still cause the failure, giving you the minimal reproduction case."
  },
  "xunit/attributes.html": {
    "href": "xunit/attributes.html",
    "title": "Generator Attributes | Hedgehog .NET",
    "summary": "Generator Attributes Hedgehog.Xunit provides a collection of built-in attributes that make it easy to generate test data for your property-based tests. These attributes inherit from GenAttribute<'T> and can be applied directly to test method parameters. Why Use Generator Attributes? Generator attributes provide a declarative, reusable way to specify test data generation. They offer several key benefits: Readability and Intent: Attributes make your test's data requirements immediately visible in the method signature. Instead of scrolling through generator setup code, you can see at a glance that a parameter needs to be a positive integer or a valid email address. Reusability: Define a generator once as an attribute, then reuse it across multiple tests. This eliminates duplication and ensures consistency in how you generate specific types of data throughout your test suite. Composability: Combine multiple attributes in a single test to generate complex test scenarios. Each parameter can have its own specialized generator without cluttering your test logic. Discoverability: Built-in attributes serve as documentation, showing what kinds of constrained data generation are available. When you need a specific type of data, you can often find an existing attribute rather than writing a custom generator. Separation of Concerns: Keep your test logic focused on the property being tested, while data generation concerns are handled declaratively through attributes. When to Create Custom Attributes Consider creating your own GenAttribute when you: Need to generate domain-specific types (e.g., valid credit card numbers, postal codes, product SKUs) Have generation logic that's reused across multiple tests Want to make test signatures more self-documenting Need parameterized generators with sensible defaults Basic Usage Instead of manually creating generators, you can use attributes to declaratively specify what kind of data you want: F# C# open Hedgehog.Xunit open Xunit [<Property>] let ``reversing a list twice returns the original`` ([<PositiveInt>] length: int) = let list = List.init length id let reversed = List.rev (List.rev list) list = reversed using Hedgehog.Xunit; using Xunit; public class ListTests { [Property] public bool ReversingListTwiceReturnsOriginal([PositiveInt] int length) { var list = Enumerable.Range(0, length).ToList(); var reversed = list.AsEnumerable().Reverse().Reverse().ToList(); return list.SequenceEqual(reversed); } } Available Attributes Numeric Attributes Int Attribute Generates integers within a specified range using linear distribution. F# C# // With custom range [<Property>] let ``dice roll`` ([<Int(1, 6)>] roll: int) = roll >= 1 && roll <= 6 // Percentage range [<Property>] let ``percentage values`` ([<Int(0, 100)>] percentage: int) = percentage >= 0 && percentage <= 100 // With custom range [Property] public bool DiceRoll([Int(1, 6)] int roll) { return roll >= 1 && roll <= 6; } // Percentage range [Property] public bool PercentageValues([Int(0, 100)] int percentage) { return percentage >= 0 && percentage <= 100; } Odd and Even Attributes Generate odd or even integers within a specified range. F# C# [<Property>] let ``odd numbers are not divisible by 2`` ([<Odd>] n: int) = n % 2 <> 0 [<Property>] let ``even numbers are divisible by 2`` ([<Even>] n: int) = n % 2 = 0 // With custom range [<Property>] let ``small odd numbers`` ([<Odd(1, 100)>] n: int) = n >= 1 && n <= 100 && n % 2 <> 0 [Property] public bool OddNumbersAreNotDivisibleBy2([Odd] int n) { return n % 2 != 0; } [Property] public bool EvenNumbersAreDivisibleBy2([Even] int n) { return n % 2 == 0; } // With custom range [Property] public bool SmallOddNumbers([Odd(1, 100)] int n) { return n >= 1 && n <= 100 && n % 2 != 0; } PositiveInt Attribute Generates positive integers (greater than 0). F# C# [<Property>] let ``positive integers are greater than zero`` ([<PositiveInt>] n: int) = n > 0 // With custom maximum [<Property>] let ``small positive integers`` ([<PositiveInt(100)>] n: int) = n > 0 && n <= 100 [Property] public bool PositiveIntegersAreGreaterThanZero([PositiveInt] int n) { return n > 0; } // With custom maximum [Property] public bool SmallPositiveIntegers([PositiveInt(100)] int n) { return n > 0 && n <= 100; } NonNegativeInt Attribute Generates non-negative integers (greater than or equal to 0). F# C# [<Property>] let ``array length is non-negative`` ([<NonNegativeInt>] length: int) = let arr = Array.zeroCreate length arr.Length >= 0 [Property] public bool ArrayLengthIsNonNegative([NonNegativeInt] int length) { var arr = new int[length]; return arr.Length >= 0; } NonZeroInt Attribute Generates integers that are not zero. F# C# [<Property>] let ``division by non-zero is safe`` ([<NonZeroInt>] divisor: int) = let result = 100 / divisor true // Won't throw DivideByZeroException [Property] public bool DivisionByNonZeroIsSafe([NonZeroInt] int divisor) { var result = 100 / divisor; return true; // Won't throw DivideByZeroException } String Attributes Identifier Attribute Generates valid programming identifiers. F# C# [<Property>] let ``identifiers start with letter or underscore`` ([<Identifier>] id: string) = let firstChar = id.[0] Char.IsLetter(firstChar) || firstChar = '_' // With custom max length [<Property>] let ``short identifiers`` ([<Identifier(10)>] id: string) = id.Length <= 10 [Property] public bool IdentifiersStartWithLetterOrUnderscore([Identifier] string id) { var firstChar = id[0]; return char.IsLetter(firstChar) || firstChar == '_'; } // With custom max length [Property] public bool ShortIdentifiers([Identifier(10)] string id) { return id.Length <= 10; } LatinName Attribute Generates human-readable Latin names. F# C# [<Property>] let ``names are capitalized`` ([<LatinName>] name: string) = Char.IsUpper(name.[0]) [Property] public bool NamesAreCapitalized([LatinName] string name) { return char.IsUpper(name[0]); } SnakeCase and KebabCase Attributes Generate strings in snake_case or kebab-case format. F# C# [<Property>] let ``snake case uses underscores`` ([<SnakeCase>] s: string) = not (s.Contains(\"-\")) [<Property>] let ``kebab case uses hyphens`` ([<KebabCase>] s: string) = not (s.Contains(\"_\")) // With custom parameters (maxWordLength, maxWordsCount) [<Property>] let ``short snake case`` ([<SnakeCase(3, 2)>] s: string) = true [Property] public bool SnakeCaseUsesUnderscores([SnakeCase] string s) { return !s.Contains(\"-\"); } [Property] public bool KebabCaseUsesHyphens([KebabCase] string s) { return !s.Contains(\"_\"); } // With custom parameters (maxWordLength, maxWordsCount) [Property] public bool ShortSnakeCase([SnakeCase(3, 2)] string s) { return true; } AlphaNumString Attribute Generates strings containing only alphanumeric characters. F# C# [<Property>] let ``alphanumeric strings contain no special chars`` ([<AlphaNumString>] s: string) = s |> Seq.forall Char.IsLetterOrDigit // With length constraints (minLength, maxLength) [<Property>] let ``bounded alphanumeric`` ([<AlphaNumString(5, 20)>] s: string) = s.Length >= 5 && s.Length <= 20 [Property] public bool AlphanumericStringsContainNoSpecialChars([AlphaNumString] string s) { return s.All(char.IsLetterOrDigit); } // With length constraints (minLength, maxLength) [Property] public bool BoundedAlphanumeric([AlphaNumString(5, 20)] string s) { return s.Length >= 5 && s.Length <= 20; } UnicodeString Attribute Generates strings with Unicode characters. F# C# [<Property>] let ``unicode strings can contain emoji`` ([<UnicodeString(1, 50)>] s: string) = s.Length >= 1 && s.Length <= 50 [Property] public bool UnicodeStringsCanContainEmoji([UnicodeString(1, 50)] string s) { return s.Length >= 1 && s.Length <= 50; } Network Attributes DomainName Attribute Generates valid domain names. F# C# [<Property>] let ``domain names contain dots`` ([<DomainName>] domain: string) = domain.Contains(\".\") [Property] public bool DomainNamesContainDots([DomainName] string domain) { return domain.Contains(\".\"); } Email Attribute Generates valid email addresses. F# C# [<Property>] let ``emails contain @ symbol`` ([<Email>] email: string) = email.Contains(\"@\") [Property] public bool EmailsContainAtSymbol([Email] string email) { return email.Contains(\"@\"); } Ipv4Address and Ipv6Address Attributes Generate IP addresses (IPv4 or IPv6). F# C# open System.Net [<Property>] let ``IPv4 addresses are valid`` ([<Ipv4Address>] ip: IPAddress) = ip.AddressFamily = Sockets.AddressFamily.InterNetwork [<Property>] let ``IPv6 addresses are valid`` ([<Ipv6Address>] ip: IPAddress) = ip.AddressFamily = Sockets.AddressFamily.InterNetworkV6 using System.Net; using System.Net.Sockets; [Property] public bool IPv4AddressesAreValid([Ipv4Address] IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetwork; } [Property] public bool IPv6AddressesAreValid([Ipv6Address] IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetworkV6; } Date and Time Attributes DateTime Attribute Generates DateTime values. F# C# open System [<Property>] let ``dates are in default range`` ([<DateTime>] dt: DateTime) = dt >= DateTime(2000, 1, 1) && dt < DateTime(2010, 1, 1) // With custom range (from, duration) [<Property>] let ``recent dates`` ([<DateTime(DateTime(2020, 1, 1), TimeSpan.FromDays(365))>] dt: DateTime) = dt.Year >= 2020 // With specific DateTimeKind [<Property>] let ``UTC dates`` ([<DateTime(DateTimeKind.Utc)>] dt: DateTime) = dt.Kind = DateTimeKind.Utc using System; [Property] public bool DatesAreInDefaultRange([DateTime] DateTime dt) { return dt >= new DateTime(2000, 1, 1) && dt < new DateTime(2010, 1, 1); } // With custom range (from, duration) [Property] public bool RecentDates([DateTime(typeof(DateTime), \"2020-01-01\", \"365.00:00:00\")] DateTime dt) { return dt.Year >= 2020; } // With specific DateTimeKind [Property] public bool UtcDates([DateTime(DateTimeKind.Utc)] DateTime dt) { return dt.Kind == DateTimeKind.Utc; } DateTimeOffset Attribute Generates DateTimeOffset values. F# C# [<Property>] let ``date offsets preserve timezone`` ([<DateTimeOffset>] dto: DateTimeOffset) = dto.Offset.TotalHours >= -14.0 && dto.Offset.TotalHours <= 14.0 [Property] public bool DateOffsetsPreserveTimezone([DateTimeOffset] DateTimeOffset dto) { return dto.Offset.TotalHours >= -14.0 && dto.Offset.TotalHours <= 14.0; } Combining Multiple Attributes You can use multiple attributes in a single test to generate different types of data: F# C# [<Property>] let ``user registration with generated data`` ([<Identifier>] username: string) ([<Email>] email: string) ([<PositiveInt(150)>] age: int) ([<LatinName>] firstName: string) ([<LatinName>] lastName: string) = // Test user registration logic let user = createUser username email age firstName lastName user.Username = username && user.Email = email && user.Age > 0 [Property] public bool UserRegistrationWithGeneratedData( [Identifier] string username, [Email] string email, [PositiveInt(150)] int age, [LatinName] string firstName, [LatinName] string lastName) { // Test user registration logic var user = CreateUser(username, email, age, firstName, lastName); return user.Username == username && user.Email == email && user.Age > 0; } Creating Custom Attributes You can create your own generator attributes by inheriting from GenAttribute<'T>: F# C# open Hedgehog open Hedgehog.FSharp /// Generates a valid US phone number type UsPhoneNumberAttribute() = inherit GenAttribute<string>() override _.Generator = gen { let! areaCode = Gen.int32 (Range.constant 200 999) let! exchange = Gen.int32 (Range.constant 200 999) let! number = Gen.int32 (Range.constant 0 9999) return sprintf \"(%03d) %03d-%04d\" areaCode exchange number } [<Property>] let ``phone numbers are formatted correctly`` ([<UsPhoneNumber>] phone: string) = phone.Length = 14 && phone.[0] = '(' && phone.[4] = ')' using Hedgehog; using Hedgehog.Linq; using Range = Hedgehog.Linq.Range; /// <summary>Generates a valid US phone number</summary> public class UsPhoneNumberAttribute : GenAttribute<string> { public override Gen<string> Generator => from areaCode in Gen.Int32(Range.Constant(200, 999)) from exchange in Gen.Int32(Range.Constant(200, 999)) from number in Gen.Int32(Range.Constant(0, 9999)) select $\"({areaCode:000}) {exchange:000}-{number:0000}\"; } [Property] public bool PhoneNumbersAreFormattedCorrectly([UsPhoneNumber] string phone) { return phone.Length == 14 && phone[0] == '(' && phone[4] == ')'; } Best Practices Use Specific Attributes: Choose the most specific attribute for your needs (e.g., [<PositiveInt>] instead of [<NonNegativeInt>] when you need values > 0) Set Reasonable Ranges: Use constructor parameters to limit ranges to realistic values for your domain Combine with Property Attribute: Always use generator attributes with [<Property>] or [<Properties>] attributes Document Custom Attributes: When creating custom attributes, add XML documentation to explain what they generate"
  },
  "xunit/best-practices.html": {
    "href": "xunit/best-practices.html",
    "title": "Best Practices | Hedgehog .NET",
    "summary": "Best Practices This page provides tips for effective property-based testing with xUnit integration. Start Simple Begin with simple [<Property>] attributes and auto-generated data. Only add custom configuration when you need it. F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``basic property`` (x: int) (y: int) = x + y = y + x using Hedgehog.Xunit; public class BasicTests { [Property] public bool BasicProperty(int x, int y) { return x + y == y + x; } } Use Descriptive Test Names Good test names describe the property being tested: F# C# [<Property>] let ``addition is commutative`` (x: int) (y: int) = x + y = y + x [<Property>] let ``reversing twice gives original list`` (xs: int list) = List.rev (List.rev xs) = xs using Hedgehog.Xunit; using System.Linq; public class PropertyTests { [Property] public bool AdditionIsCommutative(int x, int y) { return x + y == y + x; } [Property] public bool ReversingTwiceGivesOriginalList(int[] xs) { return xs.Reverse().Reverse().SequenceEqual(xs); } } Use Module/Class Level Config for Related Tests Group related tests with similar configuration needs. This is particularly useful for sharing AutoGenConfig settings or test counts across multiple related properties: F# C# open Hedgehog open Hedgehog.Xunit [<Properties(1000<tests>, AutoGenConfig = \"autoGenConfig\")>] module ``Performance critical properties`` = let autoGenConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 1000)) [<Property>] let ``property 1`` (x: int) = x + 1 > x [<Property>] let ``property 2`` (x: int) = x * 2 >= x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Properties(Tests = 1000, AutoGenConfig = nameof(AutoGenConfig))] public class PerformanceCriticalProperties { public static IAutoGenConfig AutoGenConfig { get; } = Hedgehog.AutoGenConfig.defaults .AddGenerator(Gen.Int32(Range.Constant(1, 1000))); [Property] public bool Property1(int x) => x + 1 > x; [Property] public bool Property2(int x) => x * 2 >= x; } Comparison with Manual Integration F# C# Without Hedgehog.Xunit: open Xunit open Hedgehog open Hedgehog.FSharp [<Fact>] let ``manual property test`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.int32 return List.rev (List.rev xs) = xs } |> Property.check With Hedgehog.Xunit: open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``automatic property test`` (xs: int list) = List.rev (List.rev xs) = xs Without Hedgehog.Xunit: using Xunit; using Hedgehog; using Hedgehog.Linq; using System.Linq; public class ManualTests { [Fact] public void ManualPropertyTest() { var property = from xs in Gen.Int32().List(Range.Linear(0, 100)) select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } } With Hedgehog.Xunit: using Hedgehog.Xunit; using System.Linq; public class AutomaticTests { [Property] public bool AutomaticPropertyTest(int[] xs) { return xs.Reverse().Reverse().SequenceEqual(xs); } } The [<Property>] attribute eliminates boilerplate while providing more features like rechecking, custom generators per parameter, and class/module-level configuration."
  },
  "xunit/configuration.html": {
    "href": "xunit/configuration.html",
    "title": "Configuration | Hedgehog .NET",
    "summary": "Configuration This page covers how to configure property tests using the Property and Properties attributes. Test Parameters Number of Tests Control how many test cases to run: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property(1000<tests>)>] let ``run 1000 times`` (x: int) = x + 0 = x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Property(Tests = 1000)] public bool Run1000Times(int x) { return x + 0 == x; } Number of Shrinks Limit the number of shrinking attempts: F# C# [<Property(100<tests>, 50<shrinks>)>] let ``limited shrinking`` (x: int) = x < 1000 [Property(Tests = 100, Shrinks = 50)] public bool LimitedShrinking(int x) { return x < 1000; } Size Parameter Control the size of generated data: F# C# [<Property(Size = 50)>] let ``with specific size`` (xs: int list) = xs.Length <= 50 [Property(Size = 50)] public bool WithSpecificSize(List<int> xs) { return xs.Count <= 50; } Class and Module Level Configuration Use [<Properties>] to set defaults for all properties in a class or module: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Properties(1000<tests>)>] module ``Fast running tests`` = [<Property>] let ``uses 1000 tests`` (x: int) = x + 0 = x [<Property(500<tests>)>] let ``overrides with 500 tests`` (x: int) = x * 1 = x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Properties(Tests = 1000)] public class FastRunningTests { [Property] public bool Uses1000Tests(int x) { return x + 0 == x; } [Property(Tests = 500)] public bool OverridesWith500Tests(int x) { return x * 1 == x; } } Individual [<Property>] attributes can override settings from [<Properties>]."
  },
  "xunit/generators.html": {
    "href": "xunit/generators.html",
    "title": "Custom Generators | Hedgehog .NET",
    "summary": "Custom Generators This page covers how to customize data generation using AutoGenConfig and GenAttribute. Using AutoGenConfig For complete control over generation, provide a custom AutoGenConfig: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit type PositiveInts = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 100)) [<Property(typeof<PositiveInts>)>] let ``only positive integers`` (x: int) = x > 0 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; public class PositiveInts { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 100))); } public class MyTests { [Property(AutoGenConfig = typeof(PositiveInts))] public bool OnlyPositiveIntegers(int x) { return x > 0; } } Using GenAttribute For parameter-level control, inherit from GenAttribute: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit type SmallPositiveInt() = inherit GenAttribute<int>() override _.Generator = Gen.int32 (Range.constant 1 20) [<Property>] let ``custom parameter generator`` ([<SmallPositiveInt>] x) = x >= 1 && x <= 20 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; public class SmallPositiveIntAttribute : GenAttribute<int> { public override Gen<int> Generator => Gen.Int32(Range.Constant(1, 20)); } [Property] public bool CustomParameterGenerator([SmallPositiveInt] int x) { return x >= 1 && x <= 20; } Parameter-level generators override any AutoGenConfig settings: F# C# type AlwaysThirteen = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.constant 13) type AlwaysFive() = inherit GenAttribute<int>() override _.Generator = Gen.constant 5 [<Property(typeof<AlwaysThirteen>)>] let ``GenAttribute overrides AutoGenConfig`` ([<AlwaysFive>] i) = i = 5 public class AlwaysThirteen { public static AutoGenConfig Config => AutoGenConfig.Empty.AddGenerator(Gen.Constant(13)); } public class AlwaysFiveAttribute : GenAttribute<int> { public override Gen<int> Generator => Gen.Constant(5); } [Property(AutoGenConfig = typeof(AlwaysThirteen))] public bool GenAttributeOverridesAutoGenConfig([AlwaysFive] int i) { return i == 5; } Understanding AutoGenConfig Layering Hedgehog merges AutoGenConfig settings from multiple levels, creating a layered configuration system: Default generators - Hedgehog's built-in generators for common types (base layer) PropertiesAttribute level - Configurations applied to all properties in a class/module PropertyAttribute level - Configurations for individual property tests GenAttribute level - Generators for specific parameters (highest priority) When merging layers, generators at more specific levels override those from outer levels. For example, if you configure an int generator at the Properties level and another int generator at the Property level, the Property one wins. Why Use AutoGenConfig.empty? When creating custom AutoGenConfig instances, always start with AutoGenConfig.empty rather than AutoGenConfig.defaults: F# C# //  Recommended: Add only what you need type CustomConfig = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 100)) //  Avoid: Contains all default generators type ProblematicConfig = static member __ = AutoGenConfig.defaults // Includes default generators for all types! |> AutoGenConfig.addGenerator (Gen.string (Range.constant 5 10) Gen.alpha) //  Recommended: Add only what you need public class CustomConfig { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 100))); } //  Avoid: Contains all default generators public class ProblematicConfig { public static AutoGenConfig Config => AutoGenConfig.Defaults // Includes default generators for all types! .AddGenerator(Gen.String(Range.Constant(5, 10), Gen.Alpha)); } The problem: When you start with AutoGenConfig.defaults, it includes generators for all built-in types. During merging, these will override any generators configured at outer layers. For example: Properties level configures a custom int generator (1-10) Property level uses AutoGenConfig.defaults.AddGenerator(...) Result: The default int generator (from defaults) overrides your custom one! By starting with AutoGenConfig.empty, you only include the generators you explicitly add. Since defaults are already used as the base layer, there's rarely a reason to start from AutoGenConfig.defaults. Layering Example Here's how configurations merge across levels: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit // Class-level config: integers 1-10 type SmallInts = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 10)) // Method-level config: add string generator type WithStrings = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.string (Range.constant 5 10) Gen.alpha) [<Properties(typeof<SmallInts>)>] module ``Layering example`` = [<Property>] let ``uses class-level config`` (x: int) = // x will be 1-10 from SmallInts x >= 1 && x <= 10 [<Property(typeof<WithStrings>)>] let ``merges class and method config`` (x: int) (s: string) = // x still 1-10 from SmallInts (class level) // s is 5-10 chars from WithStrings (method level) x >= 1 && x <= 10 && s.Length >= 5 && s.Length <= 10 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; // Class-level config: integers 1-10 public class SmallInts { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 10))); } // Method-level config: add string generator public class WithStrings { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.String(Range.Constant(5, 10), Gen.Alpha)); } [Properties(AutoGenConfig = typeof(SmallInts))] public class LayeringExample { [Property] public bool UsesClassLevelConfig(int x) { // x will be 1-10 from SmallInts return x >= 1 && x <= 10; } [Property(AutoGenConfig = typeof(WithStrings))] public bool MergesClassAndMethodConfig(int x, string s) { // x still 1-10 from SmallInts (class level) // s is 5-10 chars from WithStrings (method level) return x >= 1 && x <= 10 && s.Length >= 5 && s.Length <= 10; } } Working with AutoGenConfig Arguments For more dynamic configurations, you can pass arguments to your AutoGenConfig: F# C# type ConfigWithArgs = static member __ (minValue: int) (maxValue: int) = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant minValue maxValue)) [<Property( AutoGenConfig = typeof<ConfigWithArgs>, AutoGenConfigArgs = [|10; 20|])>] let ``uses config arguments`` (x: int) = x >= 10 && x <= 20 public class ConfigWithArgs { public static AutoGenConfig Config(int minValue, int maxValue) => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(minValue, maxValue))); } [Property( AutoGenConfig = typeof(ConfigWithArgs), AutoGenConfigArgs = new object[] { 10, 20 })] public bool UsesConfigArguments(int x) { return x >= 10 && x <= 20; }"
  },
  "xunit/index.html": {
    "href": "xunit/index.html",
    "title": "xUnit Integration | Hedgehog .NET",
    "summary": "xUnit Integration The Hedgehog.Xunit package provides seamless integration with xUnit, making it easy to write property-based tests that fit naturally into your existing xUnit test suite. Note We integrate with xUnit V3, so please make sure that your test project references xunit.v3 nuget package the older xunit. Installation Install Hedgehog.Xunit from NuGet: dotnet add package Hedgehog.Xunit.v3 Quick Start The simplest way to write a property test with xUnit is to use the [<Property>] attribute: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``reverse twice is identity`` (xs: int list) = List.rev (List.rev xs) = xs using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; public class MyTests { [Property] public bool ReverseTwiceIsIdentity(List<int> xs) { return xs.AsEnumerable().Reverse().Reverse().SequenceEqual(xs); } } The Property attribute automatically: Generates test data for all parameters Runs the property 100 times by default Shrinks failing cases to minimal examples Reports results through xUnit's test runner Property Return Types Properties can return various types to indicate success or failure: Supported return types: bool - false indicates failure unit / void - any exception indicates failure Result<'T, 'Error> (F#) - Error case indicates failure Property<unit> / Property<bool> (F#) - for using the property computation expression Task, Task<bool>, Task<T> - async versions of the above Async<unit>, Async<bool>, Async<Result<'T, 'Error>> (F#) - F# async versions"
  },
  "xunit/rechecking.html": {
    "href": "xunit/rechecking.html",
    "title": "Rechecking Failures | Hedgehog .NET",
    "summary": "Rechecking Failures When a property fails, Hedgehog provides recheck data that allows you to reproduce the exact failure. This is invaluable for debugging and creating regression tests. Using the Recheck Attribute When a property test fails, Hedgehog outputs recheck data that you can use to reproduce the failure: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``might fail`` (x: int) = x < 1000 // When the above fails, Hedgehog outputs: // *** Failed! Falsifiable (after 45 tests and 3 shrinks): // 1000 // This failure can be reproduced by running: // > Property.recheck \"0_16700074754810023652_2867022503662193831_\" // Use the recheck string to reproduce the exact failure: [<Property>] [<Recheck(\"0_16700074754810023652_2867022503662193831_\")>] let ``reproduce the failure`` (x: int) = x < 1000 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Property] public bool MightFail(int x) { return x < 1000; } // When the above fails, Hedgehog outputs: // *** Failed! Falsifiable (after 45 tests and 3 shrinks): // 1000 // This failure can be reproduced by running: // > Property.recheck \"0_16700074754810023652_2867022503662193831_\" // Use the recheck string to reproduce the exact failure: [Property] [Recheck(\"0_16700074754810023652_2867022503662193831_\")] public bool ReproduceTheFailure(int x) { return x < 1000; } The Recheck attribute runs the test exactly once with the specific seed and shrink path that caused the original failure, making it a perfect regression test."
  }
}