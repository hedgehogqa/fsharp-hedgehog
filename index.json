{
  "api/Hedgehog.AutoGen.DefaultGenerators.html": {
    "href": "api/Hedgehog.AutoGen.DefaultGenerators.html",
    "title": "Class DefaultGenerators | Hedgehog .NET",
    "summary": "Class DefaultGenerators Namespace Hedgehog.AutoGen Assembly Hedgehog.dll F# C# type DefaultGenerators = member Bool : Gen<bool> member Byte : Gen<byte> member Char : Gen<char> member DateTime : Gen<DateTime> member DateTimeOffset : Gen<DateTimeOffset> member Decimal : Gen<decimal> member Dictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<Dictionary<'k, 'v>> member Double : Gen<double> member FSharpList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a list> member Guid : Gen<Guid> member IDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<IDictionary<'k, 'v>> member IImmutableList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IImmutableList<'a>> member IImmutableSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IImmutableSet<'a>> member IList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IList<'a>> member IReadOnlyDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<IReadOnlyDictionary<'k, 'v>> member IReadOnlyList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IReadOnlyList<'a>> member ImmutableArray : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableArray<'a>> member ImmutableHashSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableHashSet<'a>> member ImmutableList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableList<'a>> member ImmutableSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableSortedSet<'a>> member Int16 : Gen<int16> member Int32 : Gen<int32> member Int64 : Gen<int64> member IpAddress : Gen<IPAddress> member List : context:AutoGenContext * valueGen:Gen<'a> -> Gen<List<'a>> member Map : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<Map<'k, 'v>> member Nullable : context:AutoGenContext * valueGen:Gen<'a> -> Gen<Nullable<'a>> member Option : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a option> member ReadOnlyDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<ReadOnlyDictionary<'k, 'v>> member Seq : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a seq> member Set : context:AutoGenContext * valueGen:Gen<'a> -> Gen<Set<'a>> member Single : Gen<single> member String : Gen<string> member UInt16 : Gen<uint16> member UInt32 : Gen<uint32> member UInt64 : Gen<uint64> member Uri : Gen<Uri> public class DefaultGenerators { public static Gen<bool> Bool() public static Gen<byte> Byte() public static Gen<char> Char() public static Gen<DateTime> DateTime() public static Gen<DateTimeOffset> DateTimeOffset() public static Gen<decimal> Decimal() public static Gen<Dictionary<k, v>> Dictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) public static Gen<double> Double() public static Gen<a[]> FSharpList(AutoGenContext context, Gen<a> valueGen) public static Gen<Guid> Guid() public static Gen<IDictionary<k, v>> IDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) public static Gen<IImmutableList<a>> IImmutableList(AutoGenContext context, Gen<a> valueGen) public static Gen<IImmutableSet<a>> IImmutableSet(AutoGenContext context, Gen<a> valueGen) public static Gen<IList<a>> IList(AutoGenContext context, Gen<a> valueGen) public static Gen<IReadOnlyDictionary<k, v>> IReadOnlyDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) public static Gen<IReadOnlyList<a>> IReadOnlyList(AutoGenContext context, Gen<a> valueGen) public static Gen<ImmutableArray<a>> ImmutableArray(AutoGenContext context, Gen<a> valueGen) public static Gen<ImmutableHashSet<a>> ImmutableHashSet(AutoGenContext context, Gen<a> valueGen) public static Gen<ImmutableList<a>> ImmutableList(AutoGenContext context, Gen<a> valueGen) public static Gen<ImmutableSortedSet<a>> ImmutableSet(AutoGenContext context, Gen<a> valueGen) public static Gen<int16> Int16() public static Gen<int32> Int32() public static Gen<int64> Int64() public static Gen<IPAddress> IpAddress() public static Gen<List<a>> List(AutoGenContext context, Gen<a> valueGen) public static Gen<Map<k, v>> Map(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) public static Gen<Nullable<a>> Nullable(AutoGenContext context, Gen<a> valueGen) public static Gen<a?> Option(AutoGenContext context, Gen<a> valueGen) public static Gen<ReadOnlyDictionary<k, v>> ReadOnlyDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) public static Gen<aIEnumerable> Seq(AutoGenContext context, Gen<a> valueGen) public static Gen<Set<a>> Set(AutoGenContext context, Gen<a> valueGen) public static Gen<single> Single() public static Gen<string> String() public static Gen<uint16> UInt16() public static Gen<uint32> UInt32() public static Gen<uint64> UInt64() public static Gen<Uri> Uri() } Methods Bool F# C# member Bool : Gen<bool> public static Gen<bool> Bool() Byte F# C# member Byte : Gen<byte> public static Gen<byte> Byte() Char F# C# member Char : Gen<char> public static Gen<char> Char() DateTime F# C# member DateTime : Gen<DateTime> public static Gen<DateTime> DateTime() DateTimeOffset F# C# member DateTimeOffset : Gen<DateTimeOffset> public static Gen<DateTimeOffset> DateTimeOffset() Decimal F# C# member Decimal : Gen<decimal> public static Gen<decimal> Decimal() Dictionary F# C# member Dictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<Dictionary<'k, 'v>> public static Gen<Dictionary<k, v>> Dictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) Double F# C# member Double : Gen<double> public static Gen<double> Double() FSharpList F# C# member FSharpList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a list> public static Gen<a[]> FSharpList(AutoGenContext context, Gen<a> valueGen) Guid F# C# member Guid : Gen<Guid> public static Gen<Guid> Guid() IDictionary F# C# member IDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<IDictionary<'k, 'v>> public static Gen<IDictionary<k, v>> IDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) IImmutableList F# C# member IImmutableList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IImmutableList<'a>> public static Gen<IImmutableList<a>> IImmutableList(AutoGenContext context, Gen<a> valueGen) IImmutableSet F# C# member IImmutableSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IImmutableSet<'a>> public static Gen<IImmutableSet<a>> IImmutableSet(AutoGenContext context, Gen<a> valueGen) IList F# C# member IList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IList<'a>> public static Gen<IList<a>> IList(AutoGenContext context, Gen<a> valueGen) IReadOnlyDictionary F# C# member IReadOnlyDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<IReadOnlyDictionary<'k, 'v>> public static Gen<IReadOnlyDictionary<k, v>> IReadOnlyDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) IReadOnlyList F# C# member IReadOnlyList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<IReadOnlyList<'a>> public static Gen<IReadOnlyList<a>> IReadOnlyList(AutoGenContext context, Gen<a> valueGen) ImmutableArray F# C# member ImmutableArray : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableArray<'a>> public static Gen<ImmutableArray<a>> ImmutableArray(AutoGenContext context, Gen<a> valueGen) ImmutableHashSet F# C# member ImmutableHashSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableHashSet<'a>> public static Gen<ImmutableHashSet<a>> ImmutableHashSet(AutoGenContext context, Gen<a> valueGen) ImmutableList F# C# member ImmutableList : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableList<'a>> public static Gen<ImmutableList<a>> ImmutableList(AutoGenContext context, Gen<a> valueGen) ImmutableSet F# C# member ImmutableSet : context:AutoGenContext * valueGen:Gen<'a> -> Gen<ImmutableSortedSet<'a>> public static Gen<ImmutableSortedSet<a>> ImmutableSet(AutoGenContext context, Gen<a> valueGen) Int16 F# C# member Int16 : Gen<int16> public static Gen<int16> Int16() Int32 F# C# member Int32 : Gen<int32> public static Gen<int32> Int32() Int64 F# C# member Int64 : Gen<int64> public static Gen<int64> Int64() List F# C# member List : context:AutoGenContext * valueGen:Gen<'a> -> Gen<List<'a>> public static Gen<List<a>> List(AutoGenContext context, Gen<a> valueGen) Map F# C# member Map : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<Map<'k, 'v>> public static Gen<Map<k, v>> Map(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) Nullable F# C# member Nullable : context:AutoGenContext * valueGen:Gen<'a> -> Gen<Nullable<'a>> public static Gen<Nullable<a>> Nullable(AutoGenContext context, Gen<a> valueGen) Option F# C# member Option : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a option> public static Gen<a?> Option(AutoGenContext context, Gen<a> valueGen) ReadOnlyDictionary F# C# member ReadOnlyDictionary : context:AutoGenContext * keyGen:Gen<'k> * valueGen:Gen<'v> -> Gen<ReadOnlyDictionary<'k, 'v>> public static Gen<ReadOnlyDictionary<k, v>> ReadOnlyDictionary(AutoGenContext context, Gen<k> keyGen, Gen<v> valueGen) Seq F# C# member Seq : context:AutoGenContext * valueGen:Gen<'a> -> Gen<'a seq> public static Gen<aIEnumerable> Seq(AutoGenContext context, Gen<a> valueGen) Set F# C# member Set : context:AutoGenContext * valueGen:Gen<'a> -> Gen<Set<'a>> public static Gen<Set<a>> Set(AutoGenContext context, Gen<a> valueGen) Single F# C# member Single : Gen<single> public static Gen<single> Single() String F# C# member String : Gen<string> public static Gen<string> String() UInt16 F# C# member UInt16 : Gen<uint16> public static Gen<uint16> UInt16() UInt32 F# C# member UInt32 : Gen<uint32> public static Gen<uint32> UInt32() UInt64 F# C# member UInt64 : Gen<uint64> public static Gen<uint64> UInt64() IpAddress F# C# member IpAddress : Gen<IPAddress> public static Gen<IPAddress> IpAddress() Uri F# C# member Uri : Gen<Uri> public static Gen<Uri> Uri()"
  },
  "api/Hedgehog.AutoGenConfig.html": {
    "href": "api/Hedgehog.AutoGenConfig.html",
    "title": "Class AutoGenConfig | Hedgehog .NET",
    "summary": "Class AutoGenConfig Namespace Hedgehog Assembly Hedgehog.dll C#-friendly entry points for automatic generator configuration. This module provides compiled names for F# functions to make them more accessible from C#. F# C# type AutoGenConfig = member defaults : IAutoGenConfig member empty : IAutoGenConfig public class AutoGenConfig { public static IAutoGenConfig defaults() public static IAutoGenConfig empty() } Methods empty Creates an empty configuration with no custom settings. Use this as a starting point to build a custom configuration. F# C# member empty : IAutoGenConfig public static IAutoGenConfig empty() defaults Creates a default configuration with standard generators for common types. This configuration includes generators for standard collection types such as List, Array, Dictionary, ImmutableList, ImmutableArray, and other common .NET types. Use this as a base configuration and add your own custom generators as needed. F# C# member defaults : IAutoGenConfig public static IAutoGenConfig defaults()"
  },
  "api/Hedgehog.AutoGenContext.html": {
    "href": "api/Hedgehog.AutoGenContext.html",
    "title": "Class AutoGenContext | Hedgehog .NET",
    "summary": "Class AutoGenContext Namespace Hedgehog Assembly Hedgehog.dll F# C# type AutoGenContext = member AutoGenerate : Gen<'a> member CanRecurse : bool member CollectionRange : Range<int> member CurrentRecursionDepth : int public class AutoGenContext { public static Gen<a> AutoGenerate() public static bool CanRecurse() public static Range<int> CollectionRange() public static int CurrentRecursionDepth() } Methods AutoGenerate F# C# member AutoGenerate : Gen<'a> public static Gen<a> AutoGenerate() CanRecurse F# C# member CanRecurse : bool public static bool CanRecurse() CollectionRange F# C# member CollectionRange : Range<int> public static Range<int> CollectionRange() CurrentRecursionDepth F# C# member CurrentRecursionDepth : int public static int CurrentRecursionDepth()"
  },
  "api/Hedgehog.Exceptions.html": {
    "href": "api/Hedgehog.Exceptions.html",
    "title": "Class Exceptions | Hedgehog .NET",
    "summary": "Class Exceptions Namespace Hedgehog Assembly Hedgehog.dll F# C# type Exceptions = member unwrap : exn -> exn public class Exceptions { public static exn unwrap(exn e) } Methods unwrap Recursively unwraps wrapper exceptions to get to the actual meaningful exception. Unwraps single-inner AggregateException (from async/tasks). F# C# member unwrap : exn -> exn public static exn unwrap(exn e)"
  },
  "api/Hedgehog.FSharp.AutoGenConfig.html": {
    "href": "api/Hedgehog.FSharp.AutoGenConfig.html",
    "title": "Class AutoGenConfig | Hedgehog .NET",
    "summary": "Class AutoGenConfig Namespace Hedgehog.FSharp Assembly Hedgehog.dll Functions for configuring automatic generator discovery and registration. This module provides an F#-friendly API for customizing how generators are automatically created for your types. Use these functions to set collection ranges, recursion depth, and register custom generators. F# C# type AutoGenConfig = member addGenerator : Gen<'a> -> IAutoGenConfig -> IAutoGenConfig member addGenerators : IAutoGenConfig -> IAutoGenConfig member merge : IAutoGenConfig -> IAutoGenConfig -> IAutoGenConfig member recursionDepth : IAutoGenConfig -> int member seqRange : IAutoGenConfig -> Range<int> member setRecursionDepth : int -> IAutoGenConfig -> IAutoGenConfig member setSeqRange : Range<int> -> IAutoGenConfig -> IAutoGenConfig public class AutoGenConfig { public static IAutoGenConfig -> IAutoGenConfig addGenerator(Gen<a> gen) public static IAutoGenConfig addGenerators(IAutoGenConfig config) public static IAutoGenConfig merge(IAutoGenConfig baseConfig, IAutoGenConfig extraConfig) public static int recursionDepth(IAutoGenConfig config) public static Range<int> seqRange(IAutoGenConfig config) public static IAutoGenConfig setRecursionDepth(int depth, IAutoGenConfig config) public static IAutoGenConfig setSeqRange(Range<int> range, IAutoGenConfig config) } Methods seqRange Gets the collection range from the configuration, or the default if not set. Parameters: config: The configuration to query. F# C# member seqRange : IAutoGenConfig -> Range<int> public static Range<int> seqRange(IAutoGenConfig config) setSeqRange Sets the range for collection sizes. This controls how many elements are generated when creating collections like lists, arrays, and sets. Parameters: range: The range defining minimum and maximum collection sizes. config: The configuration to modify. F# C# member setSeqRange : Range<int> -> IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig setSeqRange(Range<int> range, IAutoGenConfig config) recursionDepth Gets the recursion depth from the configuration, or the default if not set. Parameters: config: The configuration to query. F# C# member recursionDepth : IAutoGenConfig -> int public static int recursionDepth(IAutoGenConfig config) setRecursionDepth Sets the maximum recursion depth for nested type generation. This controls how deeply nested structures can be generated. Use this to prevent infinite recursion when generating recursive data structures or to control the complexity of generated values. Parameters: depth: The maximum recursion depth. A depth of 0 means no recursion is allowed. config: The configuration to modify. F# C# member setRecursionDepth : int -> IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig setRecursionDepth(int depth, IAutoGenConfig config) merge Merges two configurations, with values from the second configuration taking precedence. This is useful for creating configuration hierarchies where you can have a base configuration and override specific settings with another configuration. Parameters: baseConfig: The base configuration. extraConfig: The configuration whose values take precedence when set. F# C# member merge : IAutoGenConfig -> IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig merge(IAutoGenConfig baseConfig, IAutoGenConfig extraConfig) addGenerator Adds a custom generator for a specific type to the configuration. Use this function to override or provide a generator for a specific type. This is useful when you want to customize how instances of a particular type are generated. Parameters: gen: The generator to register. F# C# member addGenerator : Gen<'a> -> IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig -> IAutoGenConfig addGenerator(Gen<a> gen) addGenerators Registers all generator methods defined in a given type. The type is expected to have static methods that return Gen. These methods can have parameters which will be automatically injected: Hedgehog.AutoGenContext - provides context information such as recursion depth and collection range Hedgehog.IAutoGenConfig - the current auto-generation configuration Hedgehog.Gen1` - other generators that have been registered This enables dependency injection of generators, allowing you to compose complex generators from simpler ones. The system will use reflection to discover methods and automatically wire up their dependencies. Parameters: config: The configuration to modify. Example: // a type containing generators for generic types // methods should return Gen<_> and are allowed to take Gen<_> and AutoGenContext as parameters type GenericGenerators = // Generate generic types static member MyGenericType<'a>(valueGen : Gen<'a>) : Gen<MyGenericType<'a>> = valueGen | Gen.map (fun x -> MyGenericType(x)) // Generate generic types with recursion support and access to AutoGenContext static member ImmutableList<'a>(context: AutoGenContext, valueGen: Gen<'a>) : Gen<ImmutableList<'a>> = if context.CanRecurse then valueGen |> Gen.list context.CollectionRange |> Gen.map ImmutableList.CreateRange else Gen.constant ImmutableList<'a>.Empty // register the generic generators in AutoGenConfig let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<GenericGenerators> 'a val valueGen: obj val context: obj val config: obj type GenericGenerators = static member ImmutableList: context: obj * valueGen: obj -> obj static member MyGenericType: valueGen: obj -> obj F# C# member addGenerators : IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig addGenerators(IAutoGenConfig config)"
  },
  "api/Hedgehog.FSharp.Gen.Builder.html": {
    "href": "api/Hedgehog.FSharp.Gen.Builder.html",
    "title": "Class Builder | Hedgehog .NET",
    "summary": "Class Builder Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Builder = member Bind : g:Gen<'a> * f:'a -> Gen<'b> -> Gen<'b> member BindReturn : g:Gen<'a> * f:'a -> 'b -> Gen<'b> member Combine : m:Gen<unit> * n:Gen<'a> -> Gen<'a> member Delay : unit -> Gen<'a> -> Gen<'a> member For : xs:'a seq * k:'a -> Gen<'a0> -> Gen<unit> member MergeSources : ga:Gen<'a> * gb:Gen<'b> -> Gen<'a * 'b> member Return : 'a -> Gen<'a> member ReturnFrom : Gen<'a> -> Gen<'a> member Zero : Gen<unit> public class Builder { public static Gen<b> Bind(Gen<a> g, a -> Gen<b> f) public static Gen<b> BindReturn(Gen<a> g, a -> b f) public static Gen<a> Combine(Gen<void> m, Gen<a> n) public static Gen<a> Delay(void -> Gen<a> f) public static Gen<void> For(aIEnumerable xs, a -> Gen<a0> k) public static Gen<(a, b)> MergeSources(Gen<a> ga, Gen<b> gb) public static Gen<a> Return(a a) public static Gen<a> ReturnFrom(Gen<a> g) public static Gen<void> Zero() } Methods Bind F# C# member Bind : g:Gen<'a> * f:'a -> Gen<'b> -> Gen<'b> public static Gen<b> Bind(Gen<a> g, a -> Gen<b> f) BindReturn F# C# member BindReturn : g:Gen<'a> * f:'a -> 'b -> Gen<'b> public static Gen<b> BindReturn(Gen<a> g, a -> b f) Combine F# C# member Combine : m:Gen<unit> * n:Gen<'a> -> Gen<'a> public static Gen<a> Combine(Gen<void> m, Gen<a> n) Delay F# C# member Delay : unit -> Gen<'a> -> Gen<'a> public static Gen<a> Delay(void -> Gen<a> f) For F# C# member For : xs:'a seq * k:'a -> Gen<'a0> -> Gen<unit> public static Gen<void> For(aIEnumerable xs, a -> Gen<a0> k) MergeSources F# C# member MergeSources : ga:Gen<'a> * gb:Gen<'b> -> Gen<'a * 'b> public static Gen<(a, b)> MergeSources(Gen<a> ga, Gen<b> gb) Return F# C# member Return : 'a -> Gen<'a> public static Gen<a> Return(a a) ReturnFrom F# C# member ReturnFrom : Gen<'a> -> Gen<'a> public static Gen<a> ReturnFrom(Gen<a> g) Zero F# C# member Zero : Gen<unit> public static Gen<void> Zero()"
  },
  "api/Hedgehog.FSharp.Gen.Operators.html": {
    "href": "api/Hedgehog.FSharp.Gen.Operators.html",
    "title": "Class Operators | Hedgehog .NET",
    "summary": "Class Operators Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Operators = member (<!>) : 'a -> 'b -> Gen<'a> -> Gen<'b> member (<*>) : Gen<('a -> 'b)> -> Gen<'a> -> Gen<'b> member (>>=) : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b> public class Operators { public static Gen<b> (<!>)(a -> b f, Gen<a> g) public static Gen<b> (<*>)(Gen<(a -> b)> gf, Gen<a> g) public static Gen<b> (>>=)(Gen<a> g, a -> Gen<b> f) } Methods (<!>) F# C# member (<!>) : 'a -> 'b -> Gen<'a> -> Gen<'b> public static Gen<b> (<!>)(a -> b f, Gen<a> g) (<*>) F# C# member (<*>) : Gen<('a -> 'b)> -> Gen<'a> -> Gen<'b> public static Gen<b> (<*>)(Gen<(a -> b)> gf, Gen<a> g) (>>=) F# C# member (>>=) : Gen<'a> -> 'a -> Gen<'b> -> Gen<'b> public static Gen<b> (>>=)(Gen<a> g, a -> Gen<b> f)"
  },
  "api/Hedgehog.FSharp.Gen.html": {
    "href": "api/Hedgehog.FSharp.Gen.html",
    "title": "Class Gen | Hedgehog .NET",
    "summary": "Class Gen Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Gen = member addElement : 'a -> Gen<'a list> -> Gen<'a list> member alpha : Gen<char> member alphaNum : Gen<char> member apply : Gen<'a> -> Gen<('a -> 'b)> -> Gen<'b> member array : Range<int> -> Gen<'a> -> Gen<'a array> member ascii : Gen<char> member auto : Gen<'a> member autoWith : IAutoGenConfig -> Gen<'a> member bigint : Range<bigint> -> Gen<bigint> member bind : 'a -> Gen<'b> -> Gen<'a> -> Gen<'b> member bool : Gen<bool> member byte : Range<byte> -> Gen<byte> member char : char -> char -> Gen<char> member choice : Gen<'a> seq -> Gen<'a> member choiceRec : Gen<'a> seq -> Gen<'a> seq -> Gen<'a> member constant : 'a -> Gen<'a> member create : 'a -> 'a seq -> Random<'a> -> Gen<'a> member dateTime : Range<DateTime> -> Gen<DateTime> member dateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> member decimal : Range<decimal> -> Gen<decimal> member delay : unit -> Gen<'a> -> Gen<'a> member digit : Gen<char> member domainName : Gen<string> member double : Range<double> -> Gen<double> member email : Gen<string> member filter : 'a -> bool -> Gen<'a> -> Gen<'a> member frequency : (int * Gen<'a>) seq -> Gen<'a> member generateTree : Gen<'a> -> Tree<'a> member guid : Gen<Guid> member identifier : int -> Gen<string> member int16 : Range<int16> -> Gen<int16> member int32 : Range<int32> -> Gen<int32> member int64 : Range<int64> -> Gen<int64> member integral : Range<^a> -> Gen<^a> member ipAddress : Gen<IPAddress> member ipv4Address : Gen<IPAddress> member ipv6Address : Gen<IPAddress> member item : 'a seq -> Gen<'a> member kebabCase : Range<int> -> Range<int> -> Gen<string> member latin1 : Gen<char> member latinName : int -> Gen<string> member list : Range<int> -> Gen<'a> -> Gen<List<'a>> member lower : Gen<char> member map : 'a -> 'b -> Gen<'a> -> Gen<'b> member map2 : 'a -> 'b -> 'c -> Gen<'a> -> Gen<'b> -> Gen<'c> member map3 : 'a -> 'b -> 'c -> 'd -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> member map4 : 'a -> 'b -> 'c -> 'd -> 'e -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'e> member mapRandom : Random<Tree<'a>> -> Random<Tree<'b>> -> Gen<'a> -> Gen<'b> member mapTree : Tree<'a> -> Tree<'b> -> Gen<'a> -> Gen<'b> member noShrink : Gen<'a> -> Gen<'a> member notContains : 'a -> Gen<'a list> -> Gen<'a list> member notIn : 'a list -> Gen<'a> -> Gen<'a> member notNull : Gen<'a> -> Gen<'a> member ofRandom : Random<Tree<'a>> -> Gen<'a> member option : Gen<'a> -> Gen<'a option> member renderSample : Gen<'a> -> string member resize : int -> Gen<'a> -> Gen<'a> member sample : Size -> int -> Gen<'a> -> 'a seq member sampleFrom : Size -> int -> Gen<'a> -> 'a seq member sampleTree : Size -> int -> Gen<'a> -> Tree<'a> seq member sbyte : Range<sbyte> -> Gen<sbyte> member scale : int -> int -> Gen<'a> -> Gen<'a> member seq : Range<int> -> Gen<'a> -> Gen<'a seq> member sequence : 'a -> Gen<'a0 seq> member sequenceList : List<Gen<'a>> -> Gen<List<'a>> member shrink : 'a -> List<'a> -> Gen<'a> -> Gen<'a> member shrinkLazy : 'a -> 'a seq -> Gen<'a> -> Gen<'a> member shuffle : 'a list -> Gen<'a list> member shuffleCase : string -> Gen<string> member single : Range<single> -> Gen<single> member sized : Size -> Gen<'a> -> Gen<'a> member snakeCase : Range<int> -> Range<int> -> Gen<string> member some : Gen<'a option> -> Gen<'a> member string : Range<int> -> Gen<char> -> Gen<string> member subsetOf : 'a -> Gen<'T seq> member timeSpan : Range<TimeSpan> -> Gen<TimeSpan> member toRandom : Gen<'a> -> Random<Tree<'a>> member traverse : 'a -> Gen<'b> -> 'a0 -> Gen<'b seq> member traverseList : 'a -> Gen<'b> -> List<'a> -> Gen<List<'b>> member tryFilter : 'a -> bool -> Gen<'a> -> Gen<'a option> member tryFinally : unit -> unit -> Gen<'a> -> Gen<'a> member tryWith : exn -> Gen<'a> -> Gen<'a> -> Gen<'a> member tuple : Gen<'a> -> Gen<'a * 'a> member tuple3 : Gen<'a> -> Gen<'a * 'a * 'a> member tuple4 : Gen<'a> -> Gen<'a * 'a * 'a * 'a> member uint16 : Range<uint16> -> Gen<uint16> member uint32 : Range<uint32> -> Gen<uint32> member uint64 : Range<uint64> -> Gen<uint64> member unicode : Gen<char> member unicodeAll : Gen<char> member upper : Gen<char> member uri : Gen<Uri> member withDistinctMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> member withMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> member withNull : Gen<'a> -> Gen<'a> member zip : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> member zip3 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'a * 'b * 'c> member zip4 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'a * 'b * 'c * 'd> public class Gen { public static Gen<a[]> addElement(a x, Gen<a[]> g) public static Gen<char> alpha() public static Gen<char> alphaNum() public static Gen<b> apply(Gen<a> ga, Gen<(a -> b)> gf) public static Gen<a array> array(Range<int> range, Gen<a> gen) public static Gen<char> ascii() public static Gen<a> auto() public static Gen<a> autoWith(IAutoGenConfig config) public static Gen<bigint> bigint(Range<bigint> range) public static Gen<b> bind(a -> Gen<b> k, Gen<a> m) public static Gen<bool> bool() public static Gen<byte> byte(Range<byte> range) public static Gen<char> char(char lo, char hi) public static Gen<a> choice(Gen<a>IEnumerable xs0) public static Gen<a> choiceRec(Gen<a>IEnumerable nonrecs, Gen<a>IEnumerable recs) public static Gen<a> constant(a value) public static Gen<a> create(a -> aIEnumerable shrink, Random<a> random) public static Gen<DateTime> dateTime(Range<DateTime> range) public static Gen<DateTimeOffset> dateTimeOffset(Range<DateTimeOffset> range) public static Gen<decimal> decimal(Range<decimal> range) public static Gen<a> delay(void -> Gen<a> f) public static Gen<char> digit() public static Gen<string> domainName() public static Gen<double> double(Range<double> range) public static Gen<string> email() public static Gen<a> filter(a -> bool p, Gen<a> g) public static Gen<a> frequency(((int, Gen)<a>)IEnumerable xs0) public static Tree<a> generateTree(Gen<a> g) public static Gen<Guid> guid() public static Gen<string> identifier(int maxLen) public static Gen<int16> int16(Range<int16> range) public static Gen<int32> int32(Range<int32> range) public static Gen<int64> int64(Range<int64> range) public static Gen<^a> integral(Range<^a> range) public static Gen<IPAddress> ipAddress() public static Gen<IPAddress> ipv4Address() public static Gen<IPAddress> ipv6Address() public static Gen<a> item(aIEnumerable items) public static Gen<string> kebabCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<char> latin1() public static Gen<string> latinName(int maxLength) public static Gen<List<a>> list(Range<int> range, Gen<a> gen) public static Gen<char> lower() public static Gen<b> map(a -> b f, Gen<a> g) public static Gen<c> map2(a -> b -> c f, Gen<a> ga, Gen<b> gb) public static Gen<d> map3(a -> b -> c -> d f, Gen<a> ga, Gen<b> gb, Gen<c> gc) public static Gen<e> map4(a -> b -> c -> d -> e f, Gen<a> ga, Gen<b> gb, Gen<c> gc, Gen<d> gd) public static Gen<b> mapRandom(Random<Tree<a>> -> Random<Tree<b>> f, Gen<a> g) public static Gen<b> mapTree(Tree<a> -> Tree<b> f, Gen<a> g) public static Gen<a> noShrink(Gen<a> g) public static Gen<a[]> -> Gen<a[]> notContains(a x) public static Gen<a> notIn(a[] list, Gen<a> g) public static Gen<a> notNull(Gen<a> g) public static Gen<a> ofRandom(Random<Tree<a>> r) public static Gen<a?> option(Gen<a> gen) public static string renderSample(Gen<a> gen) public static Gen<a> resize(int n, Gen<a> g) public static aIEnumerable sample(Size size, int count, Gen<a> g) public static aIEnumerable sampleFrom(Size startSize, int count, Gen<a> g) public static Tree<a>IEnumerable sampleTree(Size size, int count, Gen<a> g) public static Gen<sbyte> sbyte(Range<sbyte> range) public static Gen<a> scale(int -> int f, Gen<a> g) public static Gen<aIEnumerable> seq(Range<int> range, Gen<a> gen) public static Gen<a0IEnumerable> sequence(a gens) public static Gen<List<a>> sequenceList(List<Gen<a>> gens) public static Gen<a> shrink(a -> List<a> f, Gen<a> g) public static Gen<a> shrinkLazy(a -> aIEnumerable f, Gen<a> g) public static Gen<a[]> shuffle(a[] xs) public static Gen<string> shuffleCase(string s) public static Gen<single> single(Range<single> range) public static Gen<a> sized(Size -> Gen<a> f) public static Gen<string> snakeCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<a> some(Gen<a?> g) public static Gen<string> string(Range<int> range, Gen<char> g) public static Gen<TIEnumerable> subsetOf(a items) public static Gen<TimeSpan> timeSpan(Range<TimeSpan> range) public static Random<Tree<a>> toRandom(Gen<a> arg0) public static Gen<bIEnumerable> traverse(a -> Gen<b> f, a0 ma) public static Gen<List<b>> traverseList(a -> Gen<b> f, List<a> ma) public static Gen<a?> tryFilter(a -> bool p, Gen<a> g) public static Gen<a> tryFinally(void -> void after, Gen<a> m) public static Gen<a> tryWith(exn -> Gen<a> k, Gen<a> m) public static Gen<(a, a)> tuple(Gen<a> g) public static Gen<(a, a, a)> tuple3(Gen<a> g) public static Gen<(a, a, a, a)> tuple4(Gen<a> g) public static Gen<uint16> uint16(Range<uint16> range) public static Gen<uint32> uint32(Range<uint32> range) public static Gen<uint64> uint64(Range<uint64> range) public static Gen<char> unicode() public static Gen<char> unicodeAll() public static Gen<char> upper() public static Gen<Uri> uri() public static Gen<a[] * (a -> b)> withDistinctMapTo(Gen<b> outGen, Gen<a[]> inpGen) public static Gen<a[] * (a -> b)> withMapTo(Gen<b> outGen, Gen<a[]> inpGen) public static Gen<a> withNull(Gen<a> g) public static Gen<(a, b)> zip(Gen<a> ga, Gen<b> gb) public static Gen<(a, b, c)> zip3(Gen<a> ga, Gen<b> gb, Gen<c> gc) public static Gen<(a, b, c, d)> zip4(Gen<a> ga, Gen<b> gb, Gen<c> gc, Gen<d> gd) } Methods auto Automatically generates a value of the specified type using the default configuration. F# C# member auto : Gen<'a> public static Gen<a> auto() autoWith Automatically generates a value of the specified type using the provided configuration. F# C# member autoWith : IAutoGenConfig -> Gen<'a> public static Gen<a> autoWith(IAutoGenConfig config) ofRandom F# C# member ofRandom : Random<Tree<'a>> -> Gen<'a> public static Gen<a> ofRandom(Random<Tree<a>> r) toRandom F# C# member toRandom : Gen<'a> -> Random<Tree<'a>> public static Random<Tree<a>> toRandom(Gen<a> arg0) delay F# C# member delay : unit -> Gen<'a> -> Gen<'a> public static Gen<a> delay(void -> Gen<a> f) tryFinally Ensures a cleanup function runs after a generator executes, even if it throws an exception. F# C# member tryFinally : unit -> unit -> Gen<'a> -> Gen<'a> public static Gen<a> tryFinally(void -> void after, Gen<a> m) tryWith Catches exceptions thrown by a generator and handles them with a recovery function. F# C# member tryWith : exn -> Gen<'a> -> Gen<'a> -> Gen<'a> public static Gen<a> tryWith(exn -> Gen<a> k, Gen<a> m) create F# C# member create : 'a -> 'a seq -> Random<'a> -> Gen<'a> public static Gen<a> create(a -> aIEnumerable shrink, Random<a> random) constant Create a generator that always yields a constant value. Parameters: value: The constant value the generator always returns. F# C# member constant : 'a -> Gen<'a> public static Gen<a> constant(a value) mapRandom F# C# member mapRandom : Random<Tree<'a>> -> Random<Tree<'b>> -> Gen<'a> -> Gen<'b> public static Gen<b> mapRandom(Random<Tree<a>> -> Random<Tree<b>> f, Gen<a> g) mapTree F# C# member mapTree : Tree<'a> -> Tree<'b> -> Gen<'a> -> Gen<'b> public static Gen<b> mapTree(Tree<a> -> Tree<b> f, Gen<a> g) map F# C# member map : 'a -> 'b -> Gen<'a> -> Gen<'b> public static Gen<b> map(a -> b f, Gen<a> g) bind F# C# member bind : 'a -> Gen<'b> -> Gen<'a> -> Gen<'b> public static Gen<b> bind(a -> Gen<b> k, Gen<a> m) apply F# C# member apply : Gen<'a> -> Gen<('a -> 'b)> -> Gen<'b> public static Gen<b> apply(Gen<a> ga, Gen<(a -> b)> gf) map2 F# C# member map2 : 'a -> 'b -> 'c -> Gen<'a> -> Gen<'b> -> Gen<'c> public static Gen<c> map2(a -> b -> c f, Gen<a> ga, Gen<b> gb) map3 F# C# member map3 : 'a -> 'b -> 'c -> 'd -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> public static Gen<d> map3(a -> b -> c -> d f, Gen<a> ga, Gen<b> gb, Gen<c> gc) map4 F# C# member map4 : 'a -> 'b -> 'c -> 'd -> 'e -> Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'e> public static Gen<e> map4(a -> b -> c -> d -> e f, Gen<a> ga, Gen<b> gb, Gen<c> gc, Gen<d> gd) zip F# C# member zip : Gen<'a> -> Gen<'b> -> Gen<'a * 'b> public static Gen<(a, b)> zip(Gen<a> ga, Gen<b> gb) zip3 F# C# member zip3 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'a * 'b * 'c> public static Gen<(a, b, c)> zip3(Gen<a> ga, Gen<b> gb, Gen<c> gc) zip4 F# C# member zip4 : Gen<'a> -> Gen<'b> -> Gen<'c> -> Gen<'d> -> Gen<'a * 'b * 'c * 'd> public static Gen<(a, b, c, d)> zip4(Gen<a> ga, Gen<b> gb, Gen<c> gc, Gen<d> gd) tuple F# C# member tuple : Gen<'a> -> Gen<'a * 'a> public static Gen<(a, a)> tuple(Gen<a> g) tuple3 F# C# member tuple3 : Gen<'a> -> Gen<'a * 'a * 'a> public static Gen<(a, a, a)> tuple3(Gen<a> g) tuple4 F# C# member tuple4 : Gen<'a> -> Gen<'a * 'a * 'a * 'a> public static Gen<(a, a, a, a)> tuple4(Gen<a> g) noShrink Prevent a 'Gen' from shrinking. F# C# member noShrink : Gen<'a> -> Gen<'a> public static Gen<a> noShrink(Gen<a> g) shrinkLazy Apply an additional shrinker to all generated trees. F# C# member shrinkLazy : 'a -> 'a seq -> Gen<'a> -> Gen<'a> public static Gen<a> shrinkLazy(a -> aIEnumerable f, Gen<a> g) shrink Apply an additional shrinker to all generated trees. F# C# member shrink : 'a -> List<'a> -> Gen<'a> -> Gen<'a> public static Gen<a> shrink(a -> List<a> f, Gen<a> g) sized Used to construct generators that depend on the size parameter. F# C# member sized : Size -> Gen<'a> -> Gen<'a> public static Gen<a> sized(Size -> Gen<a> f) resize Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. F# C# member resize : int -> Gen<'a> -> Gen<'a> public static Gen<a> resize(int n, Gen<a> g) scale Adjust the size parameter, by transforming it with the given function. F# C# member scale : int -> int -> Gen<'a> -> Gen<'a> public static Gen<a> scale(int -> int f, Gen<a> g) integral Generates a random number in the given inclusive range. F# C# member integral : Range<^a> -> Gen<^a> public static Gen<^a> integral(Range<^a> range) item Randomly selects one of the values in the list. The input list must be non-empty. Parameters: items: A non-empty IEnumerable of the Gen's possible values F# C# member item : 'a seq -> Gen<'a> public static Gen<a> item(aIEnumerable items) frequency Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. F# C# member frequency : (int * Gen<'a>) seq -> Gen<'a> public static Gen<a> frequency(((int, Gen)<a>)IEnumerable xs0) choice Randomly selects one of the gens in the list. The input list must be non-empty. F# C# member choice : Gen<'a> seq -> Gen<'a> public static Gen<a> choice(Gen<a>IEnumerable xs0) choiceRec Randomly selects from one of the gens in either the non-recursive or the recursive list. When a selection is made from the recursive list, the size is halved. When the size gets to one or less, selections are no longer made from the recursive list. The first argument (i.e. the non-recursive input list) must be non-empty. F# C# member choiceRec : Gen<'a> seq -> Gen<'a> seq -> Gen<'a> public static Gen<a> choiceRec(Gen<a>IEnumerable nonrecs, Gen<a>IEnumerable recs) filter Generates a value that satisfies a predicate. F# C# member filter : 'a -> bool -> Gen<'a> -> Gen<'a> public static Gen<a> filter(a -> bool p, Gen<a> g) tryFilter Tries to generate a value that satisfies a predicate. F# C# member tryFilter : 'a -> bool -> Gen<'a> -> Gen<'a option> public static Gen<a?> tryFilter(a -> bool p, Gen<a> g) some Runs an option generator until it produces a 'Some'. F# C# member some : Gen<'a option> -> Gen<'a> public static Gen<a> some(Gen<a?> g) option Generates a 'None' or a 'Some'. 'None' becomes less common with larger Sizes. F# C# member option : Gen<'a> -> Gen<'a option> public static Gen<a?> option(Gen<a> gen) list Generates a list using a 'Range' to determine the length and a 'Gen' to produce the elements. Parameters: gen: Generates the items in the list. range: Range determining the length of the list. F# C# member list : Range<int> -> Gen<'a> -> Gen<List<'a>> public static Gen<List<a>> list(Range<int> range, Gen<a> gen) array Generates an array using a 'Range' to determine the length. Parameters: range: Range determining the length of the array. F# C# member array : Range<int> -> Gen<'a> -> Gen<'a array> public static Gen<a array> array(Range<int> range, Gen<a> gen) seq Generates an enumerable using a 'Range' to determine the length. F# C# member seq : Range<int> -> Gen<'a> -> Gen<'a seq> public static Gen<aIEnumerable> seq(Range<int> range, Gen<a> gen) withNull Generates null part of the time. F# C# member withNull : Gen<'a> -> Gen<'a> public static Gen<a> withNull(Gen<a> g) notNull Generates a value that is not null. F# C# member notNull : Gen<'a> -> Gen<'a> public static Gen<a> notNull(Gen<a> g) sampleTree F# C# member sampleTree : Size -> int -> Gen<'a> -> Tree<'a> seq public static Tree<a>IEnumerable sampleTree(Size size, int count, Gen<a> g) sample Returns a seq of values produced by the generator. Parameters: size: The size parameter for the generator. count: The number of samples to produce, i.e. the length of the seq. F# C# member sample : Size -> int -> Gen<'a> -> 'a seq public static aIEnumerable sample(Size size, int count, Gen<a> g) sampleFrom Returns a sample sequence of values by scaling through sizes from startSize. This is useful for visualizing how a range scales across different sizes. Uses a random seed for generating output. Parameters: startSize: The starting size parameter. count: The number of samples to produce (sizes will increment from startSize). g: The generator to sample from. F# C# member sampleFrom : Size -> int -> Gen<'a> -> 'a seq public static aIEnumerable sampleFrom(Size startSize, int count, Gen<a> g) generateTree Run a generator. The size passed to the generator is always 30; if you want another size then you should explicitly use 'resize'. F# C# member generateTree : Gen<'a> -> Tree<'a> public static Tree<a> generateTree(Gen<a> g) renderSample Samples the gen 5 times with a Size of 10, called the \"Outcome\" in the returned string. Then the shrink path to each Outcome is produced. This may be useful in debugging shrink paths in complex Gens. F# C# member renderSample : Gen<'a> -> string public static string renderSample(Gen<a> gen) notIn F# C# member notIn : 'a list -> Gen<'a> -> Gen<'a> public static Gen<a> notIn(a[] list, Gen<a> g) notContains Generates a list that does not contain the specified element. Shortcut for Gen.filter (not << List.contains x). F# C# member notContains : 'a -> Gen<'a list> -> Gen<'a list> public static Gen<a[]> -> Gen<a[]> notContains(a x) addElement Inserts the given element at a random place in the list. F# C# member addElement : 'a -> Gen<'a list> -> Gen<'a list> public static Gen<a[]> addElement(a x, Gen<a[]> g) identifier Generates a random identifier string that starts with a lowercase letter, followed by alphanumeric characters or underscores, up to the specified maximum length. F# C# member identifier : int -> Gen<string> public static Gen<string> identifier(int maxLen) snakeCase Generates a snake_case string composed of random words of specified lengths and counts. F# C# member snakeCase : Range<int> -> Range<int> -> Gen<string> public static Gen<string> snakeCase(Range<int> wordLength, Range<int> wordsCount) kebabCase Generates a kebab-case string composed of random words of specified lengths and counts. F# C# member kebabCase : Range<int> -> Range<int> -> Gen<string> public static Gen<string> kebabCase(Range<int> wordLength, Range<int> wordsCount) latinName Generates a Latin-style name starting with an uppercase letter followed by lowercase letters, F# C# member latinName : int -> Gen<string> public static Gen<string> latinName(int maxLength) dateTime Generates a random DateTime using the given range. Parameters: range: Range determining the bounds of the DateTime that can be generated. Example: let range = Range.constantFrom (DateTime (2000, 1, 1)) DateTime.MinValue DateTime.MaxValue Gen.dateTime range val range: obj F# C# member dateTime : Range<DateTime> -> Gen<DateTime> public static Gen<DateTime> dateTime(Range<DateTime> range) dateTimeOffset Generates a random DateTimeOffset using the given range. F# C# member dateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> public static Gen<DateTimeOffset> dateTimeOffset(Range<DateTimeOffset> range) timeSpan Generates a random TimeSpan using the specified range. F# C# member timeSpan : Range<TimeSpan> -> Gen<TimeSpan> public static Gen<TimeSpan> timeSpan(Range<TimeSpan> range) withMapTo Generates a list using inpGen together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list may map to the same output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'] or ['A'; 'A'; 'A'], but never ['A'; 'B'; 'C']. The generated function throws if called with values not present in the input list. F# C# member withMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> public static Gen<a[] * (a -> b)> withMapTo(Gen<b> outGen, Gen<a[]> inpGen) withDistinctMapTo Generates a list using inpGen together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list are guaranteed to map to distinct output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'], but never ['A'; 'A'; 'A'] or ['A'; 'B'; 'C']. Only use this if the output space is large enough that the required number of distinct output values are likely to be generated. The generated function throws if called with values not present in the input list. F# C# member withDistinctMapTo : Gen<'b> -> Gen<'a list> -> Gen<'a list * ('a -> 'b)> public static Gen<a[] * (a -> b)> withDistinctMapTo(Gen<b> outGen, Gen<a[]> inpGen) char Generates a random character in the given range. F# C# member char : char -> char -> Gen<char> public static Gen<char> char(char lo, char hi) unicodeAll Generates a Unicode character, including invalid standalone surrogates, i.e. from '\\000' to '\\65535'. F# C# member unicodeAll : Gen<char> public static Gen<char> unicodeAll() digit Generates a random numerical character, i.e. from '0' to '9'. Example: Combine with string to create strings of a desired length. Gen.digit |> Gen.string (Range.constant 5 10) F# C# member digit : Gen<char> public static Gen<char> digit() lower Generates a random lowercase character, i.e. from 'a' to 'z'. Example: Combine with string to create strings of a desired length. Gen.lower |> Gen.string (Range.constant 5 10) F# C# member lower : Gen<char> public static Gen<char> lower() upper Generates a random uppercase character, i.e. from 'A' to 'Z'. Example: Combine with string to create strings of a desired length. Gen.upper |> Gen.string (Range.constant 5 10) F# C# member upper : Gen<char> public static Gen<char> upper() ascii Generates a random ASCII character, i.e. from '\\000' to '\\127', i.e. any 7 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with string to create strings of a desired length. Gen.ascii |> Gen.string (Range.constant 5 10) F# C# member ascii : Gen<char> public static Gen<char> ascii() latin1 Generates a random Latin-1 character, i.e. from '\\000' to '\\255', i.e. any 8 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with string to create strings of a desired length. Gen.latin1 |> Gen.string (Range.constant 5 10) F# C# member latin1 : Gen<char> public static Gen<char> latin1() unicode Generates a Unicode character, excluding non-characters ('\\65534' and '\\65535') and invalid standalone surrogates (from '\\55296' to '\\57343'). Example: Combine with string to create strings of a desired length. Gen.unicode |> Gen.string (Range.constant 5 10) F# C# member unicode : Gen<char> public static Gen<char> unicode() alpha Generates an alphabetic character, i.e. 'a' to 'z' or 'A' to 'Z'. Example: Combine with string to create strings of a desired length. Gen.alpha |> Gen.string (Range.constant 5 10) This generates strings such as Ldklk or aFDG F# C# member alpha : Gen<char> public static Gen<char> alpha() alphaNum Generates an alphanumeric character, i.e. 'a' to 'z', 'A' to 'Z', or '0' to '9'. Example: Combine with string to create strings of a desired length. Gen.alphaNum |> Gen.string (Range.constant 5 10) This generates strings such as Ld5lk or 4dFDG F# C# member alphaNum : Gen<char> public static Gen<char> alphaNum() string Generates a random string using 'Range' to determine the length and the given character generator. F# C# member string : Range<int> -> Gen<char> -> Gen<string> public static Gen<string> string(Range<int> range, Gen<char> g) bool Generates a random boolean. F# C# member bool : Gen<bool> public static Gen<bool> bool() byte Generates a random byte. F# C# member byte : Range<byte> -> Gen<byte> public static Gen<byte> byte(Range<byte> range) sbyte Generates a random signed byte. F# C# member sbyte : Range<sbyte> -> Gen<sbyte> public static Gen<sbyte> sbyte(Range<sbyte> range) int16 Generates a random signed 16-bit integer. F# C# member int16 : Range<int16> -> Gen<int16> public static Gen<int16> int16(Range<int16> range) uint16 Generates a random unsigned 16-bit integer. F# C# member uint16 : Range<uint16> -> Gen<uint16> public static Gen<uint16> uint16(Range<uint16> range) int32 Generates a random signed 32-bit integer. F# C# member int32 : Range<int32> -> Gen<int32> public static Gen<int32> int32(Range<int32> range) uint32 Generates a random unsigned 32-bit integer. F# C# member uint32 : Range<uint32> -> Gen<uint32> public static Gen<uint32> uint32(Range<uint32> range) int64 Generates a random signed 64-bit integer. F# C# member int64 : Range<int64> -> Gen<int64> public static Gen<int64> int64(Range<int64> range) uint64 Generates a random unsigned 64-bit integer. F# C# member uint64 : Range<uint64> -> Gen<uint64> public static Gen<uint64> uint64(Range<uint64> range) double Generates a random 64-bit floating point number. F# C# member double : Range<double> -> Gen<double> public static Gen<double> double(Range<double> range) single Generates a random 32-bit floating point number. F# C# member single : Range<single> -> Gen<single> public static Gen<single> single(Range<single> range) decimal Generates a random decimal floating-point number. F# C# member decimal : Range<decimal> -> Gen<decimal> public static Gen<decimal> decimal(Range<decimal> range) bigint Generates a random big integer. F# C# member bigint : Range<bigint> -> Gen<bigint> public static Gen<bigint> bigint(Range<bigint> range) guid Generates a random globally unique identifier. F# C# member guid : Gen<Guid> public static Gen<Guid> guid() shuffle Generates a permutation of the given list. F# C# member shuffle : 'a list -> Gen<'a list> public static Gen<a[]> shuffle(a[] xs) shuffleCase Shuffles the case of the given string. F# C# member shuffleCase : string -> Gen<string> public static Gen<string> shuffleCase(string s) subsetOf Generates the subset of the provided items. The generated subset will be in the same order as the input items. F# C# member subsetOf : 'a -> Gen<'T seq> public static Gen<TIEnumerable> subsetOf(a items) traverse Apply a generator-producing function to each element and collect the results. F# C# member traverse : 'a -> Gen<'b> -> 'a0 -> Gen<'b seq> public static Gen<bIEnumerable> traverse(a -> Gen<b> f, a0 ma) sequence Turn a sequence of generators into a generator of a sequence. F# C# member sequence : 'a -> Gen<'a0 seq> public static Gen<a0IEnumerable> sequence(a gens) traverseList Apply a generator-producing function to each list element and collect the results. F# C# member traverseList : 'a -> Gen<'b> -> List<'a> -> Gen<List<'b>> public static Gen<List<b>> traverseList(a -> Gen<b> f, List<a> ma) sequenceList Turn a list of generators into a generator of a list. F# C# member sequenceList : List<Gen<'a>> -> Gen<List<'a>> public static Gen<List<a>> sequenceList(List<Gen<a>> gens) domainName Generates a random valid domain name. F# C# member domainName : Gen<string> public static Gen<string> domainName() uri Generates a random URI. F# C# member uri : Gen<Uri> public static Gen<Uri> uri() ipv4Address Generates a random IPv4 address. F# C# member ipv4Address : Gen<IPAddress> public static Gen<IPAddress> ipv4Address() ipv6Address Generates a random IPv6 address. F# C# member ipv6Address : Gen<IPAddress> public static Gen<IPAddress> ipv6Address() ipAddress Generates a random IP address (either IPv4 or IPv6) with a higher chance of generating an IPv4 address. F# C# member ipAddress : Gen<IPAddress> public static Gen<IPAddress> ipAddress() email Generates a random email address. F# C# member email : Gen<string> public static Gen<string> email()"
  },
  "api/Hedgehog.FSharp.Property.html": {
    "href": "api/Hedgehog.FSharp.Property.html",
    "title": "Class Property | Hedgehog .NET",
    "summary": "Class Property Namespace Hedgehog.FSharp Assembly Hedgehog.dll Functions for building and executing property-based tests. Properties represent testable specifications that should hold true for all generated inputs. F# C# type Property = member bind : 'a -> Property<'b> -> Property<'a> -> Property<'b> member bindReturnWith : 'a -> Journal -> 'a -> 'b -> Gen<'a> -> Property<'b> member bindWith : 'a -> Journal -> 'a -> Property<'b> -> Gen<'a> -> Property<'b> member check : Property<unit> -> unit member checkAsync : Property<unit> -> Async<unit> member checkAsyncWith : IPropertyConfig -> Property<unit> -> Async<unit> member checkBool : Property<bool> -> unit member checkBoolAsync : Property<bool> -> Async<unit> member checkBoolAsyncWith : IPropertyConfig -> Property<bool> -> Async<unit> member checkBoolTask : Property<bool> -> Task<unit> member checkBoolTaskWith : IPropertyConfig -> Property<bool> -> Task<unit> member checkBoolWith : IPropertyConfig -> Property<bool> -> unit member checkTask : Property<unit> -> Task<unit> member checkTaskWith : IPropertyConfig -> Property<unit> -> Task<unit> member checkWith : IPropertyConfig -> Property<unit> -> unit member counterexample : unit -> string -> Property<unit> member delay : unit -> Property<'a> -> Property<'a> member discard : Property<unit> member exn : exn -> Property<unit> member failure : Property<unit> member falseToFailure : Property<bool> -> Property<unit> member filter : 'a -> bool -> Property<'a> -> Property<'a> member forAll : 'a -> Property<'b> -> Gen<'a> -> Property<'b> member forAll' : Gen<'a> -> Property<'a> member ignoreResult : Property<'a> -> Property<unit> member map : 'a -> 'b -> Property<'a> -> Property<'b> member ofAsync : Async<'T> -> Property<'T> member ofBool : bool -> Property<unit> member ofGen : Gen<Lazy<Journal * Outcome<'a>>> -> Property<'a> member ofOutcome : Outcome<'a> -> Property<'a> member ofTask : Task<'T> -> Property<'T> member ofTaskUnit : Task -> Property<unit> member recheck : string -> Property<unit> -> unit member recheckBool : string -> Property<bool> -> unit member recheckBoolWith : string -> IPropertyConfig -> Property<bool> -> unit member recheckWith : string -> IPropertyConfig -> Property<unit> -> unit member render : Property<unit> -> string member renderBool : Property<bool> -> string member renderBoolWith : IPropertyConfig -> Property<bool> -> string member renderWith : IPropertyConfig -> Property<unit> -> string member report : Property<unit> -> Report member reportAsync : Property<unit> -> Async<Report> member reportAsyncWith : IPropertyConfig -> Property<unit> -> Async<Report> member reportBool : Property<bool> -> Report member reportBoolAsync : Property<bool> -> Async<Report> member reportBoolAsyncWith : IPropertyConfig -> Property<bool> -> Async<Report> member reportBoolTask : Property<bool> -> Task<Report> member reportBoolTaskWith : IPropertyConfig -> Property<bool> -> Task<Report> member reportBoolWith : IPropertyConfig -> Property<bool> -> Report member reportRecheck : string -> Property<unit> -> Report member reportRecheckBool : string -> Property<bool> -> Report member reportRecheckBoolWith : string -> IPropertyConfig -> Property<bool> -> Report member reportRecheckWith : string -> IPropertyConfig -> Property<unit> -> Report member reportTask : Property<unit> -> Task<Report> member reportTaskWith : IPropertyConfig -> Property<unit> -> Task<Report> member reportWith : IPropertyConfig -> Property<unit> -> Report member success : 'a -> Property<'a> member toGen : Property<'a> -> Gen<Lazy<Journal * Outcome<'a>>> member tryFinally : unit -> unit -> Property<'a> -> Property<'a> member tryWith : exn -> Property<'a> -> Property<'a> -> Property<'a> member using : 'a -> 'a -> Property<'b> -> Property<'b> public class Property { public static Property<b> bind(a -> Property<b> k, Property<a> m) public static Property<b> bindReturnWith(a -> Journal journalFrom, a -> b f, Gen<a> m) public static Property<b> bindWith(a -> Journal journalFrom, a -> Property<b> k, Gen<a> m) public static void check(Property<void> p) public static Async<void> checkAsync(Property<void> p) public static Async<void> checkAsyncWith(IPropertyConfig config, Property<void> p) public static void checkBool(Property<bool> g) public static Async<void> checkBoolAsync(Property<bool> p) public static Async<void> checkBoolAsyncWith(IPropertyConfig config, Property<bool> p) public static Task<void> checkBoolTask(Property<bool> p) public static Task<void> checkBoolTaskWith(IPropertyConfig config, Property<bool> p) public static void checkBoolWith(IPropertyConfig config, Property<bool> g) public static Task<void> checkTask(Property<void> p) public static Task<void> checkTaskWith(IPropertyConfig config, Property<void> p) public static void checkWith(IPropertyConfig config, Property<void> p) public static Property<void> counterexample(void -> string msg) public static Property<a> delay(void -> Property<a> f) public static Property<void> discard() public static Property<void> exn(exn ex) public static Property<void> failure() public static Property<void> falseToFailure(Property<bool> p) public static Property<a> filter(a -> bool p, Property<a> m) public static Property<b> forAll(a -> Property<b> k, Gen<a> gen) public static Property<a> forAll'(Gen<a> gen) public static Property<void> ignoreResult(Property<a> property) public static Property<b> map(a -> b f, Property<a> x) public static Property<T> ofAsync(Async<T> asyncComputation) public static Property<void> ofBool(bool x) public static Property<a> ofGen(Gen<Lazy<(Journal, Outcome)<a>>> x) public static Property<a> ofOutcome(Outcome<a> x) public static Property<T> ofTask(Task<T> inputTask) public static Property<void> ofTaskUnit(Task inputTask) public static void recheck(string recheckData, Property<void> p) public static void recheckBool(string recheckData, Property<bool> g) public static void recheckBoolWith(string recheckData, IPropertyConfig config, Property<bool> g) public static void recheckWith(string recheckData, IPropertyConfig config, Property<void> p) public static string render(Property<void> p) public static string renderBool(Property<bool> property) public static string renderBoolWith(IPropertyConfig config, Property<bool> p) public static string renderWith(IPropertyConfig n, Property<void> p) public static Report report(Property<void> p) public static Async<Report> reportAsync(Property<void> p) public static Async<Report> reportAsyncWith(IPropertyConfig config, Property<void> p) public static Report reportBool(Property<bool> p) public static Async<Report> reportBoolAsync(Property<bool> p) public static Async<Report> reportBoolAsyncWith(IPropertyConfig config, Property<bool> p) public static Task<Report> reportBoolTask(Property<bool> p) public static Task<Report> reportBoolTaskWith(IPropertyConfig config, Property<bool> p) public static Report reportBoolWith(IPropertyConfig config, Property<bool> p) public static Report reportRecheck(string recheckData, Property<void> p) public static Report reportRecheckBool(string recheckData, Property<bool> p) public static Report reportRecheckBoolWith(string recheckData, IPropertyConfig config, Property<bool> p) public static Report reportRecheckWith(string recheckData, IPropertyConfig arg1, Property<void> p) public static Task<Report> reportTask(Property<void> p) public static Task<Report> reportTaskWith(IPropertyConfig config, Property<void> p) public static Report reportWith(IPropertyConfig config, Property<void> p) public static Property<a> success(a x) public static Gen<Lazy<(Journal, Outcome)<a>>> toGen(Property<a> arg0) public static Property<a> tryFinally(void -> void after, Property<a> m) public static Property<a> tryWith(exn -> Property<a> k, Property<a> m) public static Property<b> using(a x, a -> Property<b> k) } Methods ofGen Creates a property from a generator that produces journaled outcomes. This is a low-level function primarily used internally. F# C# member ofGen : Gen<Lazy<Journal * Outcome<'a>>> -> Property<'a> public static Property<a> ofGen(Gen<Lazy<(Journal, Outcome)<a>>> x) toGen Extracts the underlying generator from a property. This is a low-level function primarily used internally. F# C# member toGen : Property<'a> -> Gen<Lazy<Journal * Outcome<'a>>> public static Gen<Lazy<(Journal, Outcome)<a>>> toGen(Property<a> arg0) tryFinally Ensures cleanup code runs after a property executes, whether it succeeds or fails. Useful for releasing resources like file handles or database connections. F# C# member tryFinally : unit -> unit -> Property<'a> -> Property<'a> public static Property<a> tryFinally(void -> void after, Property<a> m) tryWith Handles exceptions thrown during property execution by converting them into alternative properties. This allows graceful error handling and custom failure messages. F# C# member tryWith : exn -> Property<'a> -> Property<'a> -> Property<'a> public static Property<a> tryWith(exn -> Property<a> k, Property<a> m) delay Delays the evaluation of a property until it's actually needed. This enables recursive property definitions and lazy construction. F# C# member delay : unit -> Property<'a> -> Property<'a> public static Property<a> delay(void -> Property<a> f) using Safely uses a disposable resource within a property, ensuring it's properly disposed after use. The resource is automatically disposed even if the property fails. F# C# member using : 'a -> 'a -> Property<'b> -> Property<'b> public static Property<b> using(a x, a -> Property<b> k) ofTask Converts a Task into a property that can be used in property-based tests. The property succeeds when the task completes successfully, and fails if the task throws an exception or is canceled. This enables testing of async/await code using C# Tasks. F# C# member ofTask : Task<'T> -> Property<'T> public static Property<T> ofTask(Task<T> inputTask) ofTaskUnit Converts a non-generic Task into a property. Use this for Tasks that don't return a value (void async methods in C#). F# C# member ofTaskUnit : Task -> Property<unit> public static Property<void> ofTaskUnit(Task inputTask) ofAsync Converts an F# async computation into a property that can be used in property-based tests. The property succeeds when the async computation completes successfully, and fails if it throws an exception. This enables testing of asynchronous F# code. F# C# member ofAsync : Async<'T> -> Property<'T> public static Property<T> ofAsync(Async<T> asyncComputation) filter Discards test cases where the predicate returns false, causing Hedgehog to generate a new test case. Use sparingly as excessive filtering can lead to \"gave up\" results when too many cases are discarded. F# C# member filter : 'a -> bool -> Property<'a> -> Property<'a> public static Property<a> filter(a -> bool p, Property<a> m) ofOutcome Creates a property from an explicit test outcome (Success, Failure, or Discard). This is a low-level function primarily used internally or for custom property combinators. F# C# member ofOutcome : Outcome<'a> -> Property<'a> public static Property<a> ofOutcome(Outcome<a> x) failure A property that always fails. Use this to explicitly fail a test. F# C# member failure : Property<unit> public static Property<void> failure() exn F# C# member exn : exn -> Property<unit> public static Property<void> exn(exn ex) discard A property that discards the current test case, causing a new one to be generated. Use sparingly to avoid \"gave up\" results. F# C# member discard : Property<unit> public static Property<void> discard() success A property that always succeeds with the given value. This is the property monad's return/pure operation. F# C# member success : 'a -> Property<'a> public static Property<a> success(a x) ofBool Converts a boolean into a property: true becomes success, false becomes failure. Useful for asserting simple boolean conditions in property tests. F# C# member ofBool : bool -> Property<unit> public static Property<void> ofBool(bool x) counterexample Adds a message to the test journal that will be displayed if the test fails. Use this to provide context about generated values or intermediate results that led to a failure. The message function is only evaluated if the test fails. F# C# member counterexample : unit -> string -> Property<unit> public static Property<void> counterexample(void -> string msg) map Transforms the successful result of a property using the provided function. If the function throws an exception, the property fails with the exception message. This is the functor map operation for properties. F# C# member map : 'a -> 'b -> Property<'a> -> Property<'b> public static Property<b> map(a -> b f, Property<a> x) ignoreResult Discards the result of a property, converting it to Property . This is useful when using assertion libraries that return non-unit types (e.g., fluent assertions). Assertions that throw exceptions will still cause the property to fail. F# C# member ignoreResult : Property<'a> -> Property<unit> public static Property<void> ignoreResult(Property<a> property) bind Sequences two properties together, passing the result of the first to a function that produces the second. This is the monadic bind operation that enables property composition and dependent testing. The journals from both properties are combined in the final result. F# C# member bind : 'a -> Property<'b> -> Property<'a> -> Property<'b> public static Property<b> bind(a -> Property<b> k, Property<a> m) bindWith Binds a generator to a property-returning function while adding custom journal entries. This allows you to add contextual information (like formatted parameter names and values) that will appear in test failure reports before the property's own journal entries. Use this when the property function returns Property<'b> and you want to enhance the failure output with information about the generated input values. F# C# member bindWith : 'a -> Journal -> 'a -> Property<'b> -> Gen<'a> -> Property<'b> public static Property<b> bindWith(a -> Journal journalFrom, a -> Property<b> k, Gen<a> m) bindReturnWith Binds a generator to a value-returning function while adding custom journal entries. This allows you to add contextual information (like formatted parameter names and values) that will appear in test failure reports. The function's return value is automatically checked for success (e.g., awaiting tasks, validating booleans/Results, handling exceptions). Use this for test functions that don't return Property<'b> - instead they return plain values, Task, Async, bool, Result, etc. The function is wrapped with exception handling via Property.map. F# C# member bindReturnWith : 'a -> Journal -> 'a -> 'b -> Gen<'a> -> Property<'b> public static Property<b> bindReturnWith(a -> Journal journalFrom, a -> b f, Gen<a> m) falseToFailure Converts a boolean property to a unit property, treating false as a failure. This is used internally to support boolean property testing. F# C# member falseToFailure : Property<bool> -> Property<unit> public static Property<void> falseToFailure(Property<bool> p) forAll Creates a property that tests whether a condition holds for all values generated by the given generator. Generated values are automatically added to the test journal and will be shown if the test fails. This is the primary way to introduce generated test data into your properties. F# C# member forAll : 'a -> Property<'b> -> Gen<'a> -> Property<'b> public static Property<b> forAll(a -> Property<b> k, Gen<a> gen) forAll' Creates a property that succeeds with the generated value, logging it to the journal. Useful when you just want to generate a value and return it without additional assertions. F# C# member forAll' : Gen<'a> -> Property<'a> public static Property<a> forAll'(Gen<a> gen) reportWith Runs a property test with custom configuration and returns a detailed report. The report includes the number of tests run, discards, and failure information with shrunk counterexamples. This blocks until all tests complete. F# C# member reportWith : IPropertyConfig -> Property<unit> -> Report public static Report reportWith(IPropertyConfig config, Property<void> p) report Runs a property test with default configuration and returns a detailed report. By default, runs 100 tests. This blocks until all tests complete. F# C# member report : Property<unit> -> Report public static Report report(Property<void> p) reportBoolWith Runs a boolean property test with custom configuration and returns a detailed report. Converts false results to failures. This blocks until all tests complete. F# C# member reportBoolWith : IPropertyConfig -> Property<bool> -> Report public static Report reportBoolWith(IPropertyConfig config, Property<bool> p) reportBool Runs a boolean property test with default configuration and returns a detailed report. Converts false results to failures. This blocks until all tests complete. F# C# member reportBool : Property<bool> -> Report public static Report reportBool(Property<bool> p) checkWith Runs a property test with custom configuration and throws an exception if it fails. This blocks until all tests complete. Use this in test frameworks that expect exceptions on failure. F# C# member checkWith : IPropertyConfig -> Property<unit> -> unit public static void checkWith(IPropertyConfig config, Property<void> p) check Runs a property test with default configuration and throws an exception if it fails. This blocks until all tests complete. This is the most common way to run property tests. F# C# member check : Property<unit> -> unit public static void check(Property<void> p) checkBool Runs a boolean property test with default configuration and throws an exception if it fails. Converts false results to failures. This blocks until all tests complete. F# C# member checkBool : Property<bool> -> unit public static void checkBool(Property<bool> g) checkBoolWith Runs a boolean property test with custom configuration and throws an exception if it fails. Converts false results to failures. This blocks until all tests complete. F# C# member checkBoolWith : IPropertyConfig -> Property<bool> -> unit public static void checkBoolWith(IPropertyConfig config, Property<bool> g) reportRecheckWith Re-runs a previously failed test case using the recheck data from a failure report. This is useful for debugging specific failures by reproducing them exactly. The config parameter is currently ignored but kept for API consistency. F# C# member reportRecheckWith : string -> IPropertyConfig -> Property<unit> -> Report public static Report reportRecheckWith(string recheckData, IPropertyConfig arg1, Property<void> p) reportRecheck Re-runs a previously failed test case using the recheck data from a failure report. This uses default configuration and is useful for quickly reproducing specific failures. F# C# member reportRecheck : string -> Property<unit> -> Report public static Report reportRecheck(string recheckData, Property<void> p) reportRecheckBoolWith Re-runs a previously failed boolean property test using recheck data with custom configuration. Converts false results to failures. F# C# member reportRecheckBoolWith : string -> IPropertyConfig -> Property<bool> -> Report public static Report reportRecheckBoolWith(string recheckData, IPropertyConfig config, Property<bool> p) reportRecheckBool Re-runs a previously failed boolean property test using recheck data with default configuration. Converts false results to failures. F# C# member reportRecheckBool : string -> Property<bool> -> Report public static Report reportRecheckBool(string recheckData, Property<bool> p) recheckWith Re-runs a previously failed test case and throws an exception if it still fails. Uses custom configuration. This is useful for debugging failures in test frameworks. F# C# member recheckWith : string -> IPropertyConfig -> Property<unit> -> unit public static void recheckWith(string recheckData, IPropertyConfig config, Property<void> p) recheck Re-runs a previously failed test case and throws an exception if it still fails. Uses default configuration. This is the most common way to reproduce specific failures. F# C# member recheck : string -> Property<unit> -> unit public static void recheck(string recheckData, Property<void> p) recheckBoolWith Re-runs a previously failed boolean property test and throws an exception if it still fails. Uses custom configuration. Converts false results to failures. F# C# member recheckBoolWith : string -> IPropertyConfig -> Property<bool> -> unit public static void recheckBoolWith(string recheckData, IPropertyConfig config, Property<bool> g) recheckBool Re-runs a previously failed boolean property test and throws an exception if it still fails. Uses default configuration. Converts false results to failures. F# C# member recheckBool : string -> Property<bool> -> unit public static void recheckBool(string recheckData, Property<bool> g) renderWith Runs a property test with custom configuration and returns the report as a formatted string. This is useful for custom test result formatting or logging. F# C# member renderWith : IPropertyConfig -> Property<unit> -> string public static string renderWith(IPropertyConfig n, Property<void> p) render Runs a property test with default configuration and returns the report as a formatted string. This is useful for custom test result formatting or logging. F# C# member render : Property<unit> -> string public static string render(Property<void> p) renderBool Runs a boolean property test with default configuration and returns the report as a formatted string. Converts false results to failures. F# C# member renderBool : Property<bool> -> string public static string renderBool(Property<bool> property) renderBoolWith Runs a boolean property test with custom configuration and returns the report as a formatted string. Converts false results to failures. F# C# member renderBoolWith : IPropertyConfig -> Property<bool> -> string public static string renderBoolWith(IPropertyConfig config, Property<bool> p) reportAsyncWith Runs a property test asynchronously with custom configuration, returning an F# Async that produces a report. This is non-blocking and properly handles async properties without blocking threads. Use this when testing async code or when you need non-blocking test execution. F# C# member reportAsyncWith : IPropertyConfig -> Property<unit> -> Async<Report> public static Async<Report> reportAsyncWith(IPropertyConfig config, Property<void> p) reportAsync Runs a property test asynchronously with default configuration, returning an F# Async that produces a report. This is non-blocking and properly handles async properties without blocking threads. F# C# member reportAsync : Property<unit> -> Async<Report> public static Async<Report> reportAsync(Property<void> p) checkAsyncWith Runs a property test asynchronously with custom configuration, throwing an exception if it fails. This is non-blocking and properly handles async properties. Returns an F# Async computation. F# C# member checkAsyncWith : IPropertyConfig -> Property<unit> -> Async<unit> public static Async<void> checkAsyncWith(IPropertyConfig config, Property<void> p) checkAsync Runs a property test asynchronously with default configuration, throwing an exception if it fails. This is non-blocking and properly handles async properties. This is the recommended way to test async code. F# C# member checkAsync : Property<unit> -> Async<unit> public static Async<void> checkAsync(Property<void> p) reportBoolAsyncWith Runs a boolean property test asynchronously with custom configuration, returning an F# Async that produces a report. Converts false results to failures. This is non-blocking and properly handles async properties. F# C# member reportBoolAsyncWith : IPropertyConfig -> Property<bool> -> Async<Report> public static Async<Report> reportBoolAsyncWith(IPropertyConfig config, Property<bool> p) reportBoolAsync Runs a boolean property test asynchronously with default configuration, returning an F# Async that produces a report. Converts false results to failures. This is non-blocking and properly handles async properties. F# C# member reportBoolAsync : Property<bool> -> Async<Report> public static Async<Report> reportBoolAsync(Property<bool> p) checkBoolAsyncWith Runs a boolean property test asynchronously with custom configuration, throwing an exception if it fails. Converts false results to failures. Returns an F# Async computation. F# C# member checkBoolAsyncWith : IPropertyConfig -> Property<bool> -> Async<unit> public static Async<void> checkBoolAsyncWith(IPropertyConfig config, Property<bool> p) checkBoolAsync Runs a boolean property test asynchronously with default configuration, throwing an exception if it fails. Converts false results to failures. This is the recommended way to test async boolean properties. F# C# member checkBoolAsync : Property<bool> -> Async<unit> public static Async<void> checkBoolAsync(Property<bool> p) reportTaskWith Runs a property test asynchronously with custom configuration, returning a C# Task that produces a report. This is non-blocking and properly handles async properties. Use this from C# or when you need Task-based APIs. F# C# member reportTaskWith : IPropertyConfig -> Property<unit> -> Task<Report> public static Task<Report> reportTaskWith(IPropertyConfig config, Property<void> p) reportTask Runs a property test asynchronously with default configuration, returning a C# Task that produces a report. This is non-blocking and properly handles async properties. Use this from C# or when you need Task-based APIs. F# C# member reportTask : Property<unit> -> Task<Report> public static Task<Report> reportTask(Property<void> p) checkTaskWith Runs a property test asynchronously with custom configuration, throwing an exception if it fails. Returns a C# Task. This is non-blocking and properly handles async properties. Use this from C# test frameworks. F# C# member checkTaskWith : IPropertyConfig -> Property<unit> -> Task<unit> public static Task<void> checkTaskWith(IPropertyConfig config, Property<void> p) checkTask Runs a property test asynchronously with default configuration, throwing an exception if it fails. Returns a C# Task. This is non-blocking and recommended for testing async C# code. F# C# member checkTask : Property<unit> -> Task<unit> public static Task<void> checkTask(Property<void> p) reportBoolTaskWith Runs a boolean property test asynchronously with custom configuration, returning a C# Task that produces a report. Converts false results to failures. Use this from C# or when you need Task-based APIs. F# C# member reportBoolTaskWith : IPropertyConfig -> Property<bool> -> Task<Report> public static Task<Report> reportBoolTaskWith(IPropertyConfig config, Property<bool> p) reportBoolTask Runs a boolean property test asynchronously with default configuration, returning a C# Task that produces a report. Converts false results to failures. Use this from C# or when you need Task-based APIs. F# C# member reportBoolTask : Property<bool> -> Task<Report> public static Task<Report> reportBoolTask(Property<bool> p) checkBoolTaskWith Runs a boolean property test asynchronously with custom configuration, throwing an exception if it fails. Converts false results to failures. Returns a C# Task. Use this from C# test frameworks. F# C# member checkBoolTaskWith : IPropertyConfig -> Property<bool> -> Task<unit> public static Task<void> checkBoolTaskWith(IPropertyConfig config, Property<bool> p) checkBoolTask Runs a boolean property test asynchronously with default configuration, throwing an exception if it fails. Converts false results to failures. Returns a C# Task. Recommended for testing async boolean C# code. F# C# member checkBoolTask : Property<bool> -> Task<unit> public static Task<void> checkBoolTask(Property<bool> p)"
  },
  "api/Hedgehog.FSharp.PropertyBuilder.Builder.html": {
    "href": "api/Hedgehog.FSharp.PropertyBuilder.Builder.html",
    "title": "Class Builder | Hedgehog .NET",
    "summary": "Class Builder Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Builder = member Bind : m:Property<Task<'a>> * k:'a -> Property<'b> -> Property<'b> member Bind : m:Task<'a> * k:'a -> Property<'b> -> Property<'b> member Bind : m:Property<Async<'a>> * k:'a -> Property<'b> -> Property<'b> member Bind : m:Async<'a> * k:'a -> Property<'b> -> Property<'b> member Bind : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> member Bind : m:Gen<'a> * k:'a -> Property<'b> -> Property<'b> member BindReturn : m:Task<'a> * f:'a -> 'b -> Property<'b> member BindReturn : m:Async<'a> * f:'a -> 'b -> Property<'b> member BindReturn : m:Property<'a> * f:'a -> 'b -> Property<'b> member BindReturn : m:Gen<'a> * f:'a -> 'b -> Property<'b> member Combine : m:Property<unit> * n:Property<'a> -> Property<'a> member Counterexample : f:'a -> string -> Property<'a> member Delay : unit -> Property<'a> -> Property<'a> member For : xs:'a * k:'a0 -> Property<unit> -> Property<unit> member For : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> member MergeSources : ga:Gen<'a> * gb:Gen<'b> -> Gen<'a * 'b> member Return : Task -> Property<unit> member Return : Task<unit> -> Property<unit> member Return : Async<unit> -> Property<unit> member Return : bool -> Property<unit> member ReturnFrom : Task -> Property<unit> member ReturnFrom : Task<'a> -> Property<'a> member ReturnFrom : Async<'a> -> Property<'a> member ReturnFrom : Property<'a> -> Property<'a> member TryFinally : m:Property<'a> * after:unit -> unit -> Property<'a> member TryWith : m:Property<'a> * k:exn -> Property<'a> -> Property<'a> member Using : a:'a * k:'a -> Property<'b> -> Property<'b> member Where : p:'a -> bool -> Property<'a> member While : p:unit -> bool * m:Property<unit> -> Property<unit> member Yield : 'a -> Property<'a> member Zero : Property<unit> public class Builder { public static Property<b> Bind(Property<Task<a>> m, a -> Property<b> k) public static Property<b> Bind(Task<a> m, a -> Property<b> k) public static Property<b> Bind(Property<Async<a>> m, a -> Property<b> k) public static Property<b> Bind(Async<a> m, a -> Property<b> k) public static Property<b> Bind(Property<a> m, a -> Property<b> k) public static Property<b> Bind(Gen<a> m, a -> Property<b> k) public static Property<b> BindReturn(Task<a> m, a -> b f) public static Property<b> BindReturn(Async<a> m, a -> b f) public static Property<b> BindReturn(Property<a> m, a -> b f) public static Property<b> BindReturn(Gen<a> m, a -> b f) public static Property<a> Combine(Property<void> m, Property<a> n) public static Property<a> Counterexample(a -> string f) public static Property<a> Delay(void -> Property<a> f) public static Property<void> For(a xs, a0 -> Property<void> k) public static Property<b> For(Property<a> m, a -> Property<b> k) public static Gen<(a, b)> MergeSources(Gen<a> ga, Gen<b> gb) public static Property<void> Return(Task task) public static Property<void> Return(Task<void> taskUnit) public static Property<void> Return(Async<void> asyncUnit) public static Property<void> Return(bool b) public static Property<void> ReturnFrom(Task task) public static Property<a> ReturnFrom(Task<a> taskValue) public static Property<a> ReturnFrom(Async<a> asyncValue) public static Property<a> ReturnFrom(Property<a> m) public static Property<a> TryFinally(Property<a> m, void -> void after) public static Property<a> TryWith(Property<a> m, exn -> Property<a> k) public static Property<b> Using(a a, a -> Property<b> k) public static Property<a> Where(a -> bool p) public static Property<void> While(void -> bool p, Property<void> m) public static Property<a> Yield(a x) public static Property<void> Zero() } Methods Bind F# C# member Bind : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Property<a> m, a -> Property<b> k) Bind F# C# member Bind : m:Task<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Task<a> m, a -> Property<b> k) Bind F# C# member Bind : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Property<a> m, a -> Property<b> k) Bind F# C# member Bind : m:Async<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Async<a> m, a -> Property<b> k) Bind F# C# member Bind : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Property<a> m, a -> Property<b> k) Bind F# C# member Bind : m:Gen<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> Bind(Gen<a> m, a -> Property<b> k) BindReturn F# C# member BindReturn : m:Task<'a> * f:'a -> 'b -> Property<'b> public static Property<b> BindReturn(Task<a> m, a -> b f) BindReturn F# C# member BindReturn : m:Async<'a> * f:'a -> 'b -> Property<'b> public static Property<b> BindReturn(Async<a> m, a -> b f) BindReturn F# C# member BindReturn : m:Property<'a> * f:'a -> 'b -> Property<'b> public static Property<b> BindReturn(Property<a> m, a -> b f) BindReturn F# C# member BindReturn : m:Gen<'a> * f:'a -> 'b -> Property<'b> public static Property<b> BindReturn(Gen<a> m, a -> b f) Combine F# C# member Combine : m:Property<unit> * n:Property<'a> -> Property<'a> public static Property<a> Combine(Property<void> m, Property<a> n) Counterexample F# C# member Counterexample : f:'a -> string -> Property<'a> public static Property<a> Counterexample(a -> string f) Delay F# C# member Delay : unit -> Property<'a> -> Property<'a> public static Property<a> Delay(void -> Property<a> f) For F# C# member For : xs:'a * k:'a0 -> Property<unit> -> Property<unit> public static Property<void> For(a xs, a0 -> Property<void> k) For F# C# member For : m:Property<'a> * k:'a -> Property<'b> -> Property<'b> public static Property<b> For(Property<a> m, a -> Property<b> k) MergeSources F# C# member MergeSources : ga:Gen<'a> * gb:Gen<'b> -> Gen<'a * 'b> public static Gen<(a, b)> MergeSources(Gen<a> ga, Gen<b> gb) Return F# C# member Return : Task<unit> -> Property<unit> public static Property<void> Return(Task<void> taskUnit) Return F# C# member Return : Task<unit> -> Property<unit> public static Property<void> Return(Task<void> taskUnit) Return F# C# member Return : Async<unit> -> Property<unit> public static Property<void> Return(Async<void> asyncUnit) Return F# C# member Return : bool -> Property<unit> public static Property<void> Return(bool b) ReturnFrom F# C# member ReturnFrom : Task<'a> -> Property<'a> public static Property<a> ReturnFrom(Task<a> taskValue) ReturnFrom F# C# member ReturnFrom : Task<'a> -> Property<'a> public static Property<a> ReturnFrom(Task<a> taskValue) ReturnFrom F# C# member ReturnFrom : Async<'a> -> Property<'a> public static Property<a> ReturnFrom(Async<a> asyncValue) ReturnFrom F# C# member ReturnFrom : Property<'a> -> Property<'a> public static Property<a> ReturnFrom(Property<a> m) TryFinally F# C# member TryFinally : m:Property<'a> * after:unit -> unit -> Property<'a> public static Property<a> TryFinally(Property<a> m, void -> void after) TryWith F# C# member TryWith : m:Property<'a> * k:exn -> Property<'a> -> Property<'a> public static Property<a> TryWith(Property<a> m, exn -> Property<a> k) Using F# C# member Using : a:'a * k:'a -> Property<'b> -> Property<'b> public static Property<b> Using(a a, a -> Property<b> k) Where F# C# member Where : p:'a -> bool -> Property<'a> public static Property<a> Where(a -> bool p) While F# C# member While : p:unit -> bool * m:Property<unit> -> Property<unit> public static Property<void> While(void -> bool p, Property<void> m) Yield F# C# member Yield : 'a -> Property<'a> public static Property<a> Yield(a x) Zero F# C# member Zero : Property<unit> public static Property<void> Zero()"
  },
  "api/Hedgehog.FSharp.Random.html": {
    "href": "api/Hedgehog.FSharp.Random.html",
    "title": "Class Random | Hedgehog .NET",
    "summary": "Class Random Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Random = member bind : 'a -> Random<'b> -> Random<'a> -> Random<'b> member constant : 'a -> Random<'a> member delay : unit -> Random<'a> -> Random<'a> member double : Range<double> -> Random<double> member integral : Range<^a> -> Random<^a> member map : 'a -> 'b -> Random<'a> -> Random<'b> member replicate : int -> Random<'a> -> Random<'a seq> member resize : Size -> Random<'a> -> Random<'a> member run : Seed -> Size -> Random<'a> -> 'a member sized : Size -> Random<'a> -> Random<'a> member tryFinally : unit -> unit -> Random<'a> -> Random<'a> member tryWith : exn -> Random<'a> -> Random<'a> -> Random<'a> public class Random { public static Random<b> bind(a -> Random<b> k, Random<a> r) public static Random<a> constant(a x) public static Random<a> delay(void -> Random<a> f) public static Random<double> double(Range<double> range) public static Random<^a> integral(Range<^a> range) public static Random<b> map(a -> b f, Random<a> r) public static Random<aIEnumerable> replicate(int times, Random<a> r) public static Random<a> resize(Size newSize, Random<a> r) public static a run(Seed seed, Size size, Random<a> r) public static Random<a> sized(Size -> Random<a> f) public static Random<a> tryFinally(void -> void after, Random<a> r) public static Random<a> tryWith(exn -> Random<a> k, Random<a> r) } Methods run F# C# member run : Seed -> Size -> Random<'a> -> 'a public static a run(Seed seed, Size size, Random<a> r) delay F# C# member delay : unit -> Random<'a> -> Random<'a> public static Random<a> delay(void -> Random<a> f) tryFinally F# C# member tryFinally : unit -> unit -> Random<'a> -> Random<'a> public static Random<a> tryFinally(void -> void after, Random<a> r) tryWith F# C# member tryWith : exn -> Random<'a> -> Random<'a> -> Random<'a> public static Random<a> tryWith(exn -> Random<a> k, Random<a> r) constant F# C# member constant : 'a -> Random<'a> public static Random<a> constant(a x) map F# C# member map : 'a -> 'b -> Random<'a> -> Random<'b> public static Random<b> map(a -> b f, Random<a> r) bind F# C# member bind : 'a -> Random<'b> -> Random<'a> -> Random<'b> public static Random<b> bind(a -> Random<b> k, Random<a> r) replicate F# C# member replicate : int -> Random<'a> -> Random<'a seq> public static Random<aIEnumerable> replicate(int times, Random<a> r) sized Used to construct generators that depend on the size parameter. F# C# member sized : Size -> Random<'a> -> Random<'a> public static Random<a> sized(Size -> Random<a> f) resize Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. F# C# member resize : Size -> Random<'a> -> Random<'a> public static Random<a> resize(Size newSize, Random<a> r) integral Generates a random integral number in the given inclusive range. F# C# member integral : Range<^a> -> Random<^a> public static Random<^a> integral(Range<^a> range) double Generates a random floating point number in the given inclusive range. F# C# member double : Range<double> -> Random<double> public static Random<double> double(Range<double> range)"
  },
  "api/Hedgehog.FSharp.Range.html": {
    "href": "api/Hedgehog.FSharp.Range.html",
    "title": "Class Range | Hedgehog .NET",
    "summary": "Class Range Namespace Hedgehog.FSharp Assembly Hedgehog.dll F# C# type Range = member bounds : Size -> Range<'a> -> 'a * 'a member constant : 'a -> 'a -> Range<'a> member constantBounded : unit -> Range<^a> member constantFrom : 'a -> 'a -> 'a -> Range<'a> member exponential : ^a -> ^a -> Range<^a> member exponentialBounded : unit -> Range<^a> member exponentialFrom : ^a -> ^a -> ^a -> Range<^a> member linear : ^a -> ^a -> Range<^a> member linearBounded : unit -> Range<^a> member linearFrom : ^a -> ^a -> ^a -> Range<^a> member lowerBound : Size -> Range<'a> -> 'a member map : 'a -> 'b -> Range<'a> -> Range<'b> member origin : Range<'a> -> 'a member singleton : 'a -> Range<'a> member upperBound : Size -> Range<'a> -> 'a public class Range { public static (a, a) bounds(Size sz, Range<a> arg1) public static Range<a> constant(a lowerBound, a upperBound) public static Range<^a> constantBounded(void ()) public static Range<a> constantFrom(a origin, a lowerBound, a upperBound) public static Range<^a> exponential(^a lowerBound, ^a upperBound) public static Range<^a> exponentialBounded(void ()) public static Range<^a> exponentialFrom(^a origin, ^a lowerBound, ^a upperBound) public static Range<^a> linear(^a lowerBound, ^a upperBound) public static Range<^a> linearBounded(void ()) public static Range<^a> linearFrom(^a origin, ^a lowerBound, ^a upperBound) public static a lowerBound(Size sz, Range<a> range) public static Range<b> map(a -> b f, Range<a> arg1) public static a origin(Range<a> arg0) public static Range<a> singleton(a x) public static a upperBound(Size sz, Range<a> range) } Methods origin Get the origin of a range. This might be the mid-point or the lower bound, depending on what the range represents. The 'bounds' of a range are scaled around this value when using the 'linear' family of combinators. When using a 'Range' to generate numbers, the shrinking function will shrink towards the origin. F# C# member origin : Range<'a> -> 'a public static a origin(Range<a> arg0) map Map a modification function over a Range. F# C# member map : 'a -> 'b -> Range<'a> -> Range<'b> public static Range<b> map(a -> b f, Range<a> arg1) bounds Get the extents of a range, for a given size. F# C# member bounds : Size -> Range<'a> -> 'a * 'a public static (a, a) bounds(Size sz, Range<a> arg1) lowerBound Get the lower bound of a range for the given size. F# C# member lowerBound : Size -> Range<'a> -> 'a public static a lowerBound(Size sz, Range<a> range) upperBound Get the upper bound of a range for the given size. F# C# member upperBound : Size -> Range<'a> -> 'a public static a upperBound(Size sz, Range<a> range) singleton Construct a range which represents a constant single value. F# C# member singleton : 'a -> Range<'a> public static Range<a> singleton(a x) constantFrom Construct a range which is unaffected by the size parameter with a origin point which may differ from the bounds. F# C# member constantFrom : 'a -> 'a -> 'a -> Range<'a> public static Range<a> constantFrom(a origin, a lowerBound, a upperBound) constant Construct a range which is unaffected by the size parameter. F# C# member constant : 'a -> 'a -> Range<'a> public static Range<a> constant(a lowerBound, a upperBound) constantBounded Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member constantBounded : unit -> Range<^a> public static Range<^a> constantBounded(void ()) linearFrom Construct a range which scales the bounds relative to the size parameter. F# C# member linearFrom : ^a -> ^a -> ^a -> Range<^a> public static Range<^a> linearFrom(^a origin, ^a lowerBound, ^a upperBound) linear Construct a range which scales the second bound relative to the size parameter. F# C# member linear : ^a -> ^a -> Range<^a> public static Range<^a> linear(^a lowerBound, ^a upperBound) linearBounded Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member linearBounded : unit -> Range<^a> public static Range<^a> linearBounded(void ()) exponentialFrom Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member exponentialFrom : ^a -> ^a -> ^a -> Range<^a> public static Range<^a> exponentialFrom(^a origin, ^a lowerBound, ^a upperBound) exponential Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member exponential : ^a -> ^a -> Range<^a> public static Range<^a> exponential(^a lowerBound, ^a upperBound) exponentialBounded Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member exponentialBounded : unit -> Range<^a> public static Range<^a> exponentialBounded(void ())"
  },
  "api/Hedgehog.FailureData.html": {
    "href": "api/Hedgehog.FailureData.html",
    "title": "Class FailureData | Hedgehog .NET",
    "summary": "Class FailureData Namespace Hedgehog Assembly Hedgehog.dll F# C# type FailureData public class FailureData"
  },
  "api/Hedgehog.FromBigInt.html": {
    "href": "api/Hedgehog.FromBigInt.html",
    "title": "Class FromBigInt | Hedgehog .NET",
    "summary": "Class FromBigInt Namespace Hedgehog Assembly Hedgehog.dll F# C# type FromBigInt = member FromBigInt : arg0:unativeint * arg1:FromBigInt -> bigint -> unativeint member FromBigInt : arg0:nativeint * arg1:FromBigInt -> bigint -> nativeint member FromBigInt : arg0:decimal * arg1:FromBigInt -> bigint -> decimal member FromBigInt : arg0:double * arg1:FromBigInt -> bigint -> double member FromBigInt : arg0:single * arg1:FromBigInt -> bigint -> single member FromBigInt : arg0:int64 * arg1:FromBigInt -> bigint -> int64 member FromBigInt : arg0:int32 * arg1:FromBigInt -> bigint -> int32 member FromBigInt : arg0:int16 * arg1:FromBigInt -> bigint -> int16 member FromBigInt : arg0:int8 * arg1:FromBigInt -> bigint -> int8 member FromBigInt : arg0:uint64 * arg1:FromBigInt -> bigint -> uint64 member FromBigInt : arg0:uint32 * arg1:FromBigInt -> bigint -> uint32 member FromBigInt : arg0:uint16 * arg1:FromBigInt -> bigint -> uint16 member FromBigInt : arg0:uint8 * arg1:FromBigInt -> bigint -> uint8 member FromBigInt : arg0:bigint * arg1:FromBigInt -> bigint -> bigint member Invoke : bigint -> ^Num public class FromBigInt { public static bigint -> unativeint FromBigInt(unativeint arg0, FromBigInt arg1) public static bigint -> nativeint FromBigInt(nativeint arg0, FromBigInt arg1) public static bigint -> decimal FromBigInt(decimal arg0, FromBigInt arg1) public static bigint -> double FromBigInt(double arg0, FromBigInt arg1) public static bigint -> single FromBigInt(single arg0, FromBigInt arg1) public static bigint -> int64 FromBigInt(int64 arg0, FromBigInt arg1) public static bigint -> int32 FromBigInt(int32 arg0, FromBigInt arg1) public static bigint -> int16 FromBigInt(int16 arg0, FromBigInt arg1) public static bigint -> int8 FromBigInt(int8 arg0, FromBigInt arg1) public static bigint -> uint64 FromBigInt(uint64 arg0, FromBigInt arg1) public static bigint -> uint32 FromBigInt(uint32 arg0, FromBigInt arg1) public static bigint -> uint16 FromBigInt(uint16 arg0, FromBigInt arg1) public static bigint -> uint8 FromBigInt(uint8 arg0, FromBigInt arg1) public static bigint -> bigint FromBigInt(bigint arg0, FromBigInt arg1) public static ^Num Invoke(bigint x) } Methods FromBigInt F# C# member FromBigInt : arg0:unativeint * arg1:FromBigInt -> bigint -> unativeint public static bigint -> unativeint FromBigInt(unativeint arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:nativeint * arg1:FromBigInt -> bigint -> nativeint public static bigint -> nativeint FromBigInt(nativeint arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:decimal * arg1:FromBigInt -> bigint -> decimal public static bigint -> decimal FromBigInt(decimal arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:double * arg1:FromBigInt -> bigint -> double public static bigint -> double FromBigInt(double arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:single * arg1:FromBigInt -> bigint -> single public static bigint -> single FromBigInt(single arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:int64 * arg1:FromBigInt -> bigint -> int64 public static bigint -> int64 FromBigInt(int64 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:int32 * arg1:FromBigInt -> bigint -> int32 public static bigint -> int32 FromBigInt(int32 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:int16 * arg1:FromBigInt -> bigint -> int16 public static bigint -> int16 FromBigInt(int16 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:int8 * arg1:FromBigInt -> bigint -> int8 public static bigint -> int8 FromBigInt(int8 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:uint64 * arg1:FromBigInt -> bigint -> uint64 public static bigint -> uint64 FromBigInt(uint64 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:uint32 * arg1:FromBigInt -> bigint -> uint32 public static bigint -> uint32 FromBigInt(uint32 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:uint16 * arg1:FromBigInt -> bigint -> uint16 public static bigint -> uint16 FromBigInt(uint16 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:uint8 * arg1:FromBigInt -> bigint -> uint8 public static bigint -> uint8 FromBigInt(uint8 arg0, FromBigInt arg1) FromBigInt F# C# member FromBigInt : arg0:bigint * arg1:FromBigInt -> bigint -> bigint public static bigint -> bigint FromBigInt(bigint arg0, FromBigInt arg1) Invoke F# C# member Invoke : bigint -> ^Num public static ^Num Invoke(bigint x)"
  },
  "api/Hedgehog.Gen_a_.html": {
    "href": "api/Hedgehog.Gen_a_.html",
    "title": "Class Gen<'a> | Hedgehog .NET",
    "summary": "Class Gen<'a> Namespace Hedgehog Assembly Hedgehog.dll A generator for values and shrink trees of type 'a. F# C# type Gen<'a> public class Gen<a>"
  },
  "api/Hedgehog.IAutoGenConfig.html": {
    "href": "api/Hedgehog.IAutoGenConfig.html",
    "title": "Class IAutoGenConfig | Hedgehog .NET",
    "summary": "Class IAutoGenConfig Namespace Hedgehog Assembly Hedgehog.dll Configuration for automatic generator discovery and registration. This interface provides settings that control how generators are automatically created for custom types. It manages collection size ranges, recursion depth limits, and registered custom generators. F# C# type IAutoGenConfig public class IAutoGenConfig"
  },
  "api/Hedgehog.IPropertyConfig.html": {
    "href": "api/Hedgehog.IPropertyConfig.html",
    "title": "Class IPropertyConfig | Hedgehog .NET",
    "summary": "Class IPropertyConfig Namespace Hedgehog Assembly Hedgehog.dll F# C# type IPropertyConfig public class IPropertyConfig"
  },
  "api/Hedgehog.Journal.html": {
    "href": "api/Hedgehog.Journal.html",
    "title": "Class Journal | Hedgehog .NET",
    "summary": "Class Journal Namespace Hedgehog Assembly Hedgehog.dll F# C# type Journal = member append : Journal -> Journal -> Journal member empty : Journal member eval : Journal -> JournalLine seq member exn : exn -> Journal member ofSeq : (unit -> JournalLine) seq -> Journal member singleton : unit -> JournalLine -> Journal member singletonMessage : string -> Journal public class Journal { public static Journal append(Journal arg0, Journal arg1) public static Journal empty() public static JournalLineIEnumerable eval(Journal arg0) public static Journal exn(exn error) public static Journal ofSeq((void -> JournalLine)IEnumerable entries) public static Journal singleton(void -> JournalLine entry) public static Journal singletonMessage(string message) } Methods ofSeq Creates a journal from a sequence of entries. F# C# member ofSeq : (unit -> JournalLine) seq -> Journal public static Journal ofSeq((void -> JournalLine)IEnumerable entries) eval Evaluates all entries in the journal, returning their journal lines. F# C# member eval : Journal -> JournalLine seq public static JournalLineIEnumerable eval(Journal arg0) empty Represents a journal with no entries. F# C# member empty : Journal public static Journal empty() singletonMessage Creates a single entry journal from a given message as Text. F# C# member singletonMessage : string -> Journal public static Journal singletonMessage(string message) exn Adds exception to the journal as a single entry. F# C# member exn : exn -> Journal public static Journal exn(exn error) singleton Creates a single entry journal from a given entry. F# C# member singleton : unit -> JournalLine -> Journal public static Journal singleton(void -> JournalLine entry) append Creates a journal composed of entries from two journals. F# C# member append : Journal -> Journal -> Journal public static Journal append(Journal arg0, Journal arg1)"
  },
  "api/Hedgehog.JournalLine.html": {
    "href": "api/Hedgehog.JournalLine.html",
    "title": "Class JournalLine | Hedgehog .NET",
    "summary": "Class JournalLine Namespace Hedgehog Assembly Hedgehog.dll Represents a single line in a property test journal with semantic meaning F# C# type JournalLine public class JournalLine"
  },
  "api/Hedgehog.Language.html": {
    "href": "api/Hedgehog.Language.html",
    "title": "Class Language | Hedgehog .NET",
    "summary": "Class Language Namespace Hedgehog Assembly Hedgehog.dll F# C# type Language public class Language"
  },
  "api/Hedgehog.Linq.AutoGenExtensions.html": {
    "href": "api/Hedgehog.Linq.AutoGenExtensions.html",
    "title": "Class AutoGenExtensions | Hedgehog .NET",
    "summary": "Class AutoGenExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll Extension methods for IAutoGenConfig to support fluent API for C#. This class provides a C#-friendly interface for configuring automatic generator discovery and registration. Use these methods to customize how generators are created for your custom types when using Auto.Gen (). F# C# type AutoGenExtensions = member AddGenerator : self:IAutoGenConfig * generator:Gen<'T> -> IAutoGenConfig member AddGenerators : IAutoGenConfig -> IAutoGenConfig member GetCollectionRange : IAutoGenConfig -> Range<int> member GetRecursionDepth : IAutoGenConfig -> int member SetCollectionRange : self:IAutoGenConfig * range:Range<int> -> IAutoGenConfig member SetRecursionDepth : self:IAutoGenConfig * depth:int -> IAutoGenConfig public class AutoGenExtensions { public static IAutoGenConfig AddGenerator(this IAutoGenConfig self, Gen<T> generator) public static IAutoGenConfig AddGenerators(this IAutoGenConfig self) public static Range<int> GetCollectionRange(this IAutoGenConfig self) public static int GetRecursionDepth(IAutoGenConfig self) public static IAutoGenConfig SetCollectionRange(this IAutoGenConfig self, Range<int> range) public static IAutoGenConfig SetRecursionDepth(this IAutoGenConfig self, int depth) } Methods AddGenerator(IAutoGenConfig, Gen) Registers a custom generator for type T. Use this method to override or provide a generator for a specific type. This is useful when you want to customize how instances of a particular type are generated. Parameters: self: The configuration to modify. generator: The generator to register for type T. F# C# member AddGenerator : self:IAutoGenConfig * generator:Gen<'T> -> IAutoGenConfig public static IAutoGenConfig AddGenerator(this IAutoGenConfig self, Gen<T> generator) AddGenerators(IAutoGenConfig) Registers all generator methods defined in a given type. The type is expected to have static methods returning Gen . These methods can take parameters that will be automatically injected: Hedgehog.AutoGenContext - provides context information such as recursion depth and collection range Hedgehog.IAutoGenConfig - the current auto-generation configuration Hedgehog.Gen&lt;U&gt; - other generators that have been registered for type U This enables dependency injection of generators, allowing you to compose complex generators from simpler ones. Parameters: self: The configuration to modify. Example: public sealed class MyGenerators { public static Gen<ImmutableList<T>> ImmutableListGen<T>( AutoGenContext ctx, // context can be injected Gen<T> valueGen // value generator is injected ) { if (ctx.CanRecurse) // if recursion is possible then construct a list of values // respecting the configured collection range return valueGen.List(ctx.CollectionRange).Select(ImmutableList.CreateRange); else // cannot recurse anymore, return the base case return ImmutableList.Empty<T>(); } } F# C# member AddGenerators : IAutoGenConfig -> IAutoGenConfig public static IAutoGenConfig AddGenerators(this IAutoGenConfig self) GetCollectionRange(IAutoGenConfig) Gets the currently configured collection range. Parameters: self: The configuration to query. F# C# member GetCollectionRange : IAutoGenConfig -> Range<int> public static Range<int> GetCollectionRange(this IAutoGenConfig self) GetRecursionDepth(IAutoGenConfig) Gets the currently configured recursion depth. Parameters: self: The configuration to query. F# C# member GetRecursionDepth : IAutoGenConfig -> int public static int GetRecursionDepth(IAutoGenConfig self) SetCollectionRange(IAutoGenConfig, Range) Sets the range for collection sizes when generating collections (lists, arrays, sets, etc.). This setting controls how many elements are generated when creating collections. The default range is exponential from 0 to 50. Use this to generate smaller or larger collections as needed. Parameters: self: The configuration to modify. range: The range defining minimum and maximum collection sizes. F# C# member SetCollectionRange : self:IAutoGenConfig * range:Range<int> -> IAutoGenConfig public static IAutoGenConfig SetCollectionRange(this IAutoGenConfig self, Range<int> range) SetRecursionDepth(IAutoGenConfig, int) Sets the maximum recursion depth for nested type generation. This controls how deeply nested structures can be generated. A depth of 0 means no recursion is allowed. A depth of 1 allows one level of recursion, and so on. Use this to prevent infinite recursion when generating recursive data structures or to control the complexity of generated values. Higher values create more complex nested structures. Parameters: self: The configuration to modify. depth: The maximum recursion depth. Default is 1. F# C# member SetRecursionDepth : self:IAutoGenConfig * depth:int -> IAutoGenConfig public static IAutoGenConfig SetRecursionDepth(this IAutoGenConfig self, int depth)"
  },
  "api/Hedgehog.Linq.Gen.html": {
    "href": "api/Hedgehog.Linq.Gen.html",
    "title": "Class Gen | Hedgehog .NET",
    "summary": "Class Gen Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type Gen = member Alpha : Gen<char> member AlphaNumeric : Gen<char> member Ascii : Gen<char> member Auto : Gen<'T> member AutoWith : IAutoGenConfig -> Gen<'T> member Bool : Gen<bool> member Byte : Range<byte> -> Gen<byte> member Char : lo:char * hi:char -> Gen<char> member Choice : Gen<'T> array -> Gen<'T> member ChoiceRecursive : nonrecs:Gen<'T> seq * recs:Gen<'T> seq -> Gen<'T> member Constant : 'T -> Gen<'T> member Create : shrink:Func<'T, 'T seq> * random:Random<'T> -> Gen<'T> member DateTime : Range<DateTime> -> Gen<DateTime> member DateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> member Decimal : Range<decimal> -> Gen<decimal> member Delay : Func<Gen<'T>> -> Gen<'T> member Digit : Gen<char> member DomainName : Gen<string> member Double : Range<double> -> Gen<double> member Email : Gen<string> member Frequency : (int * Gen<'T>) array -> Gen<'T> member Frequency : (int * Gen<'T>) array -> Gen<'T> member FromRandom : Random<Tree<'T>> -> Gen<'T> member FromValue : 'T -> Gen<'T> member Guid : Gen<Guid> member Identifier : int -> Gen<string> member Int16 : Range<int16> -> Gen<int16> member Int32 : Range<int32> -> Gen<int32> member Int64 : Range<int64> -> Gen<int64> member Integral : Range<decimal> -> Gen<decimal> member Integral : Range<double> -> Gen<double> member Integral : Range<uint64> -> Gen<uint64> member Integral : Range<int64> -> Gen<int64> member Integral : Range<uint32> -> Gen<uint32> member Integral : Range<int32> -> Gen<int32> member Integral : Range<uint16> -> Gen<uint16> member Integral : Range<int16> -> Gen<int16> member Integral : Range<sbyte> -> Gen<sbyte> member Integral : Range<byte> -> Gen<byte> member IpAddress : Gen<IPAddress> member Ipv4Address : Gen<IPAddress> member Ipv6Address : Gen<IPAddress> member Item : 'T array -> Gen<'T> member KebabCase : maxWordLength:int * maxWordsCount:int -> Gen<string> member KebabCase : wordLength:Range<int> * wordsCount:Range<int> -> Gen<string> member Latin1 : Gen<char> member LatinName : int -> Gen<string> member Lower : Gen<char> member SByte : Range<sbyte> -> Gen<sbyte> member Shuffle : 'T seq -> Gen<'T seq> member ShuffleCase : string -> Gen<string> member Single : Range<single> -> Gen<single> member Sized : Func<Size, Gen<'T>> -> Gen<'T> member SnakeCase : maxWordLength:int * maxWordsCount:int -> Gen<string> member SnakeCase : wordLength:Range<int> * wordsCount:Range<int> -> Gen<string> member SubsetOf : 'T seq -> Gen<'T seq> member UInt16 : Range<uint16> -> Gen<uint16> member UInt32 : Range<uint32> -> Gen<uint32> member UInt64 : Range<uint64> -> Gen<uint64> member Unicode : Gen<char> member UnicodeAll : Gen<char> member Upper : Gen<char> member Uri : Gen<Uri> public class Gen { public static Gen<char> Alpha() public static Gen<char> AlphaNumeric() public static Gen<char> Ascii() public static Gen<T> Auto() public static Gen<T> AutoWith(IAutoGenConfig config) public static Gen<bool> Bool() public static Gen<byte> Byte(Range<byte> range) public static Gen<char> Char(char lo, char hi) public static Gen<T> Choice(Gen<T> array gens) public static Gen<T> ChoiceRecursive(Gen<T>IEnumerable nonrecs, Gen<T>IEnumerable recs) public static Gen<T> Constant(T value) public static Gen<T> Create(Func<T, TIEnumerable> shrink, Random<T> random) public static Gen<DateTime> DateTime(Range<DateTime> range) public static Gen<DateTimeOffset> DateTimeOffset(Range<DateTimeOffset> range) public static Gen<decimal> Decimal(Range<decimal> range) public static Gen<T> Delay(Func<Gen<T>> func) public static Gen<char> Digit() public static Gen<string> DomainName() public static Gen<double> Double(Range<double> range) public static Gen<string> Email() public static Gen<T> Frequency(((int, Gen)<T>) array values) public static Gen<T> Frequency(((int, Gen)<T>) array gens) public static Gen<T> FromRandom(Random<Tree<T>> random) public static Gen<T> FromValue(T value) public static Gen<Guid> Guid() public static Gen<string> Identifier(int maxLen) public static Gen<int16> Int16(Range<int16> range) public static Gen<int32> Int32(Range<int32> range) public static Gen<int64> Int64(Range<int64> range) public static Gen<decimal> Integral(Range<decimal> range) public static Gen<double> Integral(Range<double> range) public static Gen<uint64> Integral(Range<uint64> range) public static Gen<int64> Integral(Range<int64> range) public static Gen<uint32> Integral(Range<uint32> range) public static Gen<int32> Integral(Range<int32> range) public static Gen<uint16> Integral(Range<uint16> range) public static Gen<int16> Integral(Range<int16> range) public static Gen<sbyte> Integral(Range<sbyte> range) public static Gen<byte> Integral(Range<byte> range) public static Gen<IPAddress> IpAddress() public static Gen<IPAddress> Ipv4Address() public static Gen<IPAddress> Ipv6Address() public static Gen<T> Item(T array items) public static Gen<string> KebabCase(int maxWordLength, int maxWordsCount) public static Gen<string> KebabCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<char> Latin1() public static Gen<string> LatinName(int maxLength) public static Gen<char> Lower() public static Gen<sbyte> SByte(Range<sbyte> range) public static Gen<TIEnumerable> Shuffle(TIEnumerable items) public static Gen<string> ShuffleCase(string value) public static Gen<single> Single(Range<single> range) public static Gen<T> Sized(Func<Size, Gen<T>> scaler) public static Gen<string> SnakeCase(int maxWordLength, int maxWordsCount) public static Gen<string> SnakeCase(Range<int> wordLength, Range<int> wordsCount) public static Gen<TIEnumerable> SubsetOf(TIEnumerable items) public static Gen<uint16> UInt16(Range<uint16> range) public static Gen<uint32> UInt32(Range<uint32> range) public static Gen<uint64> UInt64(Range<uint64> range) public static Gen<char> Unicode() public static Gen<char> UnicodeAll() public static Gen<char> Upper() public static Gen<Uri> Uri() } Methods Auto Create a generator that automatically generates values of the specified type. F# C# member Auto : Gen<'T> public static Gen<T> Auto() AutoWith(IAutoGenConfig) Create a generator that automatically generates values of the specified type, using the provided configuration. Parameters: config: The configuration to use for automatic generation. F# C# member AutoWith : IAutoGenConfig -> Gen<'T> public static Gen<T> AutoWith(IAutoGenConfig config) Byte(Range) Generates a random byte. F# C# member Byte : Range<byte> -> Gen<byte> public static Gen<byte> Byte(Range<byte> range) Char(char, char) Generates a random character in the given range. F# C# member Char : lo:char * hi:char -> Gen<char> public static Gen<char> Char(char lo, char hi) Choice(Gen) Randomly selects one of the gens in the list. The input list must be non-empty. F# C# member Choice : Gen<'T> array -> Gen<'T> public static Gen<T> Choice(Gen<T> array gens) ChoiceRecursive(Gen, Gen) Randomly selects from one of the gens in either the non-recursive or the recursive list. When a selection is made from the recursive list, the size is halved. When the size gets to one or less, selections are no longer made from the recursive list. The first argument (i.e. the non-recursive input list) must be non-empty. F# C# member ChoiceRecursive : nonrecs:Gen<'T> seq * recs:Gen<'T> seq -> Gen<'T> public static Gen<T> ChoiceRecursive(Gen<T>IEnumerable nonrecs, Gen<T>IEnumerable recs) Constant('T) Create a generator that always yields a constant value. Parameters: value: The constant value the generator always returns. F# C# member Constant : 'T -> Gen<'T> public static Gen<T> Constant(T value) Create(Func, Random) F# C# member Create : shrink:Func<'T, 'T seq> * random:Random<'T> -> Gen<'T> public static Gen<T> Create(Func<T, TIEnumerable> shrink, Random<T> random) DateTime(Range) Generates a random DateTime using the given range. Parameters: range: Range determining the bounds of the DateTime that can be generated. Example: var TwentiethCentury = Gen.DateTime( Range.Constant( new DateTime(1900, 1, 1), new DateTime(1999, 12, 31))); F# C# member DateTime : Range<DateTime> -> Gen<DateTime> public static Gen<DateTime> DateTime(Range<DateTime> range) DateTimeOffset(Range) Generates a random DateTimeOffset using the given range. F# C# member DateTimeOffset : Range<DateTimeOffset> -> Gen<DateTimeOffset> public static Gen<DateTimeOffset> DateTimeOffset(Range<DateTimeOffset> range) Decimal(Range) Generates a random decimal floating-point number. F# C# member Decimal : Range<decimal> -> Gen<decimal> public static Gen<decimal> Decimal(Range<decimal> range) Delay(Func) F# C# member Delay : Func<Gen<'T>> -> Gen<'T> public static Gen<T> Delay(Func<Gen<T>> func) Double(Range) Generates a random 64-bit floating point number. F# C# member Double : Range<double> -> Gen<double> public static Gen<double> Double(Range<double> range) Frequency((int) Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. F# C# member Frequency : (int * Gen<'T>) array -> Gen<'T> public static Gen<T> Frequency(((int, Gen)<T>) array gens) Frequency((int) Uses a weighted distribution to randomly select one of the gens in the list. This generator shrinks towards the first generator in the list. The input list must be non-empty. F# C# member Frequency : (int * Gen<'T>) array -> Gen<'T> public static Gen<T> Frequency(((int, Gen)<T>) array gens) FromRandom(Random) F# C# member FromRandom : Random<Tree<'T>> -> Gen<'T> public static Gen<T> FromRandom(Random<Tree<T>> random) FromValue('T) Create a generator that always yields a constant value. Parameters: value: The constant value the generator always returns. F# C# member FromValue : 'T -> Gen<'T> public static Gen<T> FromValue(T value) Identifier(int) Generates a random identifier string (starts with a lowercase letter, followed by lowercase letters, digits, or underscores) of up to the specified maximum length F# C# member Identifier : int -> Gen<string> public static Gen<string> Identifier(int maxLen) Int16(Range) Generates a random signed 16-bit integer. F# C# member Int16 : Range<int16> -> Gen<int16> public static Gen<int16> Int16(Range<int16> range) Int32(Range) Generates a random signed 32-bit integer. F# C# member Int32 : Range<int32> -> Gen<int32> public static Gen<int32> Int32(Range<int32> range) Int64(Range) Generates a random signed 64-bit integer. F# C# member Int64 : Range<int64> -> Gen<int64> public static Gen<int64> Int64(Range<int64> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Integral(Range) Generates a random number in the given inclusive range. F# C# member Integral : Range<byte> -> Gen<byte> public static Gen<byte> Integral(Range<byte> range) Item('T) Randomly selects one of the values in the list. The input list must be non-empty. Parameters: items: A non-empty IEnumerable of the Gen's possible values F# C# member Item : 'T array -> Gen<'T> public static Gen<T> Item(T array items) KebabCase(int, int) Generates a random kebab-case string composed of words with the specified maximum word length and maximum words count. F# C# member KebabCase : maxWordLength:int * maxWordsCount:int -> Gen<string> public static Gen<string> KebabCase(int maxWordLength, int maxWordsCount) KebabCase(Range, Range) Generates a random kebab-case string composed of words with the specified word length and words count ranges. F# C# member KebabCase : wordLength:Range<int> * wordsCount:Range<int> -> Gen<string> public static Gen<string> KebabCase(Range<int> wordLength, Range<int> wordsCount) LatinName(int) Generates a random Latin-style name starting with an uppercase letter, followed by lowercase letters, of up to the specified maximum length. F# C# member LatinName : int -> Gen<string> public static Gen<string> LatinName(int maxLength) SByte(Range) Generates a random signed byte. F# C# member SByte : Range<sbyte> -> Gen<sbyte> public static Gen<sbyte> SByte(Range<sbyte> range) Shuffle('T) Generates a permutation of the given items. F# C# member Shuffle : 'T seq -> Gen<'T seq> public static Gen<TIEnumerable> Shuffle(TIEnumerable items) ShuffleCase(string) Shuffles the case of the given string. F# C# member ShuffleCase : string -> Gen<string> public static Gen<string> ShuffleCase(string value) Single(Range) Generates a random 32-bit floating point number. F# C# member Single : Range<single> -> Gen<single> public static Gen<single> Single(Range<single> range) Sized(Func) Used to construct generators that depend on the size parameter. F# C# member Sized : Func<Size, Gen<'T>> -> Gen<'T> public static Gen<T> Sized(Func<Size, Gen<T>> scaler) SnakeCase(int, int) Generates a random snake_case string composed of words with the specified maximum word length and maximum words count. F# C# member SnakeCase : maxWordLength:int * maxWordsCount:int -> Gen<string> public static Gen<string> SnakeCase(int maxWordLength, int maxWordsCount) SnakeCase(Range, Range) Generates a random snake_case string composed of words with the specified word length and words count ranges. F# C# member SnakeCase : wordLength:Range<int> * wordsCount:Range<int> -> Gen<string> public static Gen<string> SnakeCase(Range<int> wordLength, Range<int> wordsCount) SubsetOf('T) Generates the subset of the provided items. The generated subset will be in the same order as the input items. F# C# member SubsetOf : 'T seq -> Gen<'T seq> public static Gen<TIEnumerable> SubsetOf(TIEnumerable items) UInt16(Range) Generates a random unsigned 16-bit integer. F# C# member UInt16 : Range<uint16> -> Gen<uint16> public static Gen<uint16> UInt16(Range<uint16> range) UInt32(Range) Generates a random unsigned 32-bit integer. F# C# member UInt32 : Range<uint32> -> Gen<uint32> public static Gen<uint32> UInt32(Range<uint32> range) UInt64(Range) Generates a random unsigned 64-bit integer. F# C# member UInt64 : Range<uint64> -> Gen<uint64> public static Gen<uint64> UInt64(Range<uint64> range) Digit Generates a random numerical character, i.e. from '0' to '9'. Example: Combine with String to create strings of a desired length. Gen.Digit.String(Range.Constant(5, 10)) F# C# member Digit : Gen<char> public static Gen<char> Digit() Email Generates a random email address. F# C# member Email : Gen<string> public static Gen<string> Email() IpAddress Generates a random IP address (either IPv4 or IPv6) with a higher chance of generating an IPv4 address. F# C# member IpAddress : Gen<IPAddress> public static Gen<IPAddress> IpAddress() Upper Generates a random uppercase character, i.e. from 'A' to 'Z'. Example: Combine with String to create strings of a desired length. Gen.Upper.String(Range.Constant(5, 10)) F# C# member Upper : Gen<char> public static Gen<char> Upper() AlphaNumeric Generates an alphanumeric character, i.e. 'a' to 'z', 'A' to 'Z', or '0' to '9'. Example: Combine with String to create strings of a desired length. Gen.AlphaNumeric.String(Range.Constant(5, 10)) This generates strings such as Ld5lk or 4dFDG F# C# member AlphaNumeric : Gen<char> public static Gen<char> AlphaNumeric() DomainName Generates a random valid domain name. F# C# member DomainName : Gen<string> public static Gen<string> DomainName() Lower Generates a random lowercase character, i.e. from 'a' to 'z'. Example: Combine with String to create strings of a desired length. Gen.Lower.String(Range.Constant(5, 10)) F# C# member Lower : Gen<char> public static Gen<char> Lower() Ipv4Address Generates a random IPv4 address. F# C# member Ipv4Address : Gen<IPAddress> public static Gen<IPAddress> Ipv4Address() Latin1 Generates a random Latin-1 character, i.e. from '\\000' to '\\255', i.e. any 8 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with String to create strings of a desired length. Gen.Latin1.String(Range.Constant(5, 10)) F# C# member Latin1 : Gen<char> public static Gen<char> Latin1() Ascii Generates a random ASCII character, i.e. from '\\000' to '\\127', i.e. any 7 bit character. Non-printable and control characters can be generated, e.g. NULL and BEL. Example: Combine with String to create strings of a desired length. Gen.Ascii.String(Range.Constant(5, 10)) F# C# member Ascii : Gen<char> public static Gen<char> Ascii() Ipv6Address Generates a random IPv6 address. F# C# member Ipv6Address : Gen<IPAddress> public static Gen<IPAddress> Ipv6Address() UnicodeAll Generates a Unicode character, including invalid standalone surrogates, i.e. from '\\000' to '\\65535'. F# C# member UnicodeAll : Gen<char> public static Gen<char> UnicodeAll() Bool Generates a random boolean. F# C# member Bool : Gen<bool> public static Gen<bool> Bool() Guid Generates a random globally unique identifier. F# C# member Guid : Gen<Guid> public static Gen<Guid> Guid() Unicode Generates a Unicode character, excluding non-characters ('\\65534' and '\\65535') and invalid standalone surrogates (from '\\55296' to '\\57343'). Example: Combine with String to create strings of a desired length. Gen.Unicode.String(Range.Constant(5, 10)) F# C# member Unicode : Gen<char> public static Gen<char> Unicode() Alpha Generates an alphabetic character, i.e. 'a' to 'z' or 'A' to 'Z'. Example: Combine with String to create strings of a desired length. Gen.Alpha.String(Range.Constant(5, 10)) This generates strings such as Ldklk or aFDG F# C# member Alpha : Gen<char> public static Gen<char> Alpha() Uri Generates a random URI F# C# member Uri : Gen<Uri> public static Gen<Uri> Uri()"
  },
  "api/Hedgehog.Linq.GenExtensions.html": {
    "href": "api/Hedgehog.Linq.GenExtensions.html",
    "title": "Class GenExtensions | Hedgehog .NET",
    "summary": "Class GenExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type GenExtensions = member Apply : genFunc:Gen<Func<'T, 'TResult>> * genArg:Gen<'T> -> Gen<'TResult> member Array : gen:Gen<'T> * range:Range<int> -> Gen<'T[]> member Enumerable : gen:Gen<'T> * range:Range<int> -> Gen<'T seq> member GenerateTree : Gen<'T> -> Tree<'T> member List : gen:Gen<'T> * range:Range<int> -> Gen<ResizeArray<'T>> member NoShrink : Gen<'T> -> Gen<'T> member NotNull : Gen<'T> -> Gen<'T> member NullReference : Gen<'T> -> Gen<'T> member NullValue : Gen<'T> -> Gen<Nullable<'T>> member RenderSample : Gen<'T> -> string member Resize : gen:Gen<'T> * size:Size -> Gen<'T> member Sample : gen:Gen<'T> * size:Size * count:int -> ResizeArray<'T> member SampleFrom : gen:Gen<'T> * size:Size * count:int -> ResizeArray<'T> member SampleTree : gen:Gen<'T> * size:Size * count:int -> ResizeArray<Tree<'T>> member Scale : gen:Gen<'T> * scaler:Func<int, int> -> Gen<'T> member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'V, 'W, 'TResult> * genB:Gen<'U> * genC:Gen<'V> * genD:Gen<'W> -> Gen<'TResult> member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'V, 'TResult> * genB:Gen<'U> * genC:Gen<'V> -> Gen<'TResult> member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'TResult> * genB:Gen<'U> -> Gen<'TResult> member Select : gen:Gen<'T> * mapper:Func<'T, 'TResult> -> Gen<'TResult> member SelectMany : gen:Gen<'T> * binder:Func<'T, Gen<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Gen<'TResult> member SelectMany : gen:Gen<'T> * binder:Func<'T, Gen<'U>> -> Gen<'U> member SelectRandom : gen:Gen<'T> * binder:Func<Random<Tree<'T>>, Random<Tree<'TResult>>> -> Gen<'TResult> member SelectTree : gen:Gen<'T> * binder:Func<Tree<'T>, Tree<'TResult>> -> Gen<'TResult> member Shrink : gen:Gen<'T> * shrinker:Func<'T, ResizeArray<'T>> -> Gen<'T> member ShrinkLazy : gen:Gen<'T> * shrinker:Func<'T, 'T seq> -> Gen<'T> member Some : Gen<Option<'T>> -> Gen<'T> member String : gen:Gen<char> * range:Range<int> -> Gen<string> member ToGen : Random<Tree<'T>> -> Gen<'T> member ToRandom : Gen<'T> -> Random<Tree<'T>> member TryFinally : gen:Gen<'T> * after:Action -> Gen<'T> member TryWith : gen:Gen<'T> * after:Func<exn, Gen<'T>> -> Gen<'T> member Tuple2 : Gen<'T> -> Gen<'T * 'T> member Tuple3 : Gen<'T> -> Gen<'T * 'T * 'T> member Tuple4 : Gen<'T> -> Gen<'T * 'T * 'T * 'T> member Where : gen:Gen<'T> * predicate:Func<'T, bool> -> Gen<'T> member WithNull : Gen<'T> -> Gen<'T> member Zip : genA:Gen<'T> * genB:Gen<'U> * genC:Gen<'V> * genD:Gen<'W> -> Gen<'T * 'U * 'V * 'W> member Zip : genA:Gen<'T> * genB:Gen<'U> * genC:Gen<'V> -> Gen<'T * 'U * 'V> member Zip : genA:Gen<'T> * genB:Gen<'U> -> Gen<'T * 'U> public class GenExtensions { public static Gen<TResult> Apply(this Gen<Func<T, TResult>> genFunc, Gen<T> genArg) public static Gen<T[]> Array(this Gen<T> gen, Range<int> range) public static Gen<TIEnumerable> Enumerable(this Gen<T> gen, Range<int> range) public static Tree<T> GenerateTree(this Gen<T> gen) public static Gen<ResizeArray<T>> List(this Gen<T> gen, Range<int> range) public static Gen<T> NoShrink(this Gen<T> gen) public static Gen<T> NotNull(this Gen<T> self) public static Gen<T> NullReference(this Gen<T> gen) public static Gen<Nullable<T>> NullValue(this Gen<T> gen) public static string RenderSample(this Gen<T> gen) public static Gen<T> Resize(this Gen<T> gen, Size size) public static ResizeArray<T> Sample(this Gen<T> gen, Size size, int count) public static ResizeArray<T> SampleFrom(this Gen<T> gen, Size size, int count) public static ResizeArray<Tree<T>> SampleTree(this Gen<T> gen, Size size, int count) public static Gen<T> Scale(this Gen<T> gen, Func<int, int> scaler) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, W, TResult> mapper, Gen<U> genB, Gen<V> genC, Gen<W> genD) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, TResult> mapper, Gen<U> genB, Gen<V> genC) public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, TResult> mapper, Gen<U> genB) public static Gen<TResult> Select(this Gen<T> gen, Func<T, TResult> mapper) public static Gen<TResult> SelectMany(this Gen<T> gen, Func<T, Gen<TCollection>> binder, Func<T, TCollection, TResult> projection) public static Gen<U> SelectMany(this Gen<T> gen, Func<T, Gen<U>> binder) public static Gen<TResult> SelectRandom(this Gen<T> gen, Func<Random<Tree<T>>, Random<Tree<TResult>>> binder) public static Gen<TResult> SelectTree(this Gen<T> gen, Func<Tree<T>, Tree<TResult>> binder) public static Gen<T> Shrink(this Gen<T> gen, Func<T, ResizeArray<T>> shrinker) public static Gen<T> ShrinkLazy(this Gen<T> gen, Func<T, TIEnumerable> shrinker) public static Gen<T> Some(this Gen<Option<T>> gen) public static Gen<string> String(this Gen<char> gen, Range<int> range) public static Gen<T> ToGen(this Random<Tree<T>> random) public static Random<Tree<T>> ToRandom(this Gen<T> gen) public static Gen<T> TryFinally(this Gen<T> gen, Action after) public static Gen<T> TryWith(this Gen<T> gen, Func<exn, Gen<T>> after) public static Gen<(T, T)> Tuple2(this Gen<T> gen) public static Gen<(T, T, T)> Tuple3(this Gen<T> gen) public static Gen<(T, T, T, T)> Tuple4(this Gen<T> gen) public static Gen<T> Where(this Gen<T> gen, Func<T, bool> predicate) public static Gen<T> WithNull(this Gen<T> self) public static Gen<(T, U, V, W)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC, Gen<W> genD) public static Gen<(T, U, V)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC) public static Gen<(T, U)> Zip(this Gen<T> genA, Gen<U> genB) } Methods Apply(Gen, Gen) F# C# member Apply : genFunc:Gen<Func<'T, 'TResult>> * genArg:Gen<'T> -> Gen<'TResult> public static Gen<TResult> Apply(this Gen<Func<T, TResult>> genFunc, Gen<T> genArg) Array(Gen, Range) Generates an array using a 'Range' to determine the length. Parameters: gen: Item generator. range: Range determining the length of the array. F# C# member Array : gen:Gen<'T> * range:Range<int> -> Gen<'T[]> public static Gen<T[]> Array(this Gen<T> gen, Range<int> range) Enumerable(Gen, Range) Generates an enumerable using a 'Range' to determine the length. Parameters: gen: Item generator. range: Range determining the length of the enumerable. F# C# member Enumerable : gen:Gen<'T> * range:Range<int> -> Gen<'T seq> public static Gen<TIEnumerable> Enumerable(this Gen<T> gen, Range<int> range) GenerateTree(Gen) Run a generator. The size passed to the generator is always 30; if you want another size then you should explicitly use 'resize'. F# C# member GenerateTree : Gen<'T> -> Tree<'T> public static Tree<T> GenerateTree(this Gen<T> gen) List(Gen, Range) Generates a List using a 'Range' to determine the length and a 'Gen' to produce the elements. Parameters: gen: Generates the items in the List. range: Range determining the length of the List. F# C# member List : gen:Gen<'T> * range:Range<int> -> Gen<ResizeArray<'T>> public static Gen<ResizeArray<T>> List(this Gen<T> gen, Range<int> range) NoShrink(Gen) Prevent a 'Gen' from shrinking. F# C# member NoShrink : Gen<'T> -> Gen<'T> public static Gen<T> NoShrink(this Gen<T> gen) NotNull(Gen) Generates a value that is not null. F# C# member NotNull : Gen<'T> -> Gen<'T> public static Gen<T> NotNull(this Gen<T> self) NullReference(Gen) Generates a null or a value from gen. Null becomes less common with larger Sizes. F# C# member NullReference : Gen<'T> -> Gen<'T> public static Gen<T> NullReference(this Gen<T> gen) NullValue(Gen) Generates a null or a value from gen. Null becomes less common with larger Sizes. F# C# member NullValue : Gen<'T> -> Gen<Nullable<'T>> public static Gen<Nullable<T>> NullValue(this Gen<T> gen) RenderSample(Gen) Samples the gen 5 times with a Size of 10, called the \"Outcome\" in the returned string. Then the shrink path to each Outcome is produced. This may be useful in debugging shrink paths in complex Gens. F# C# member RenderSample : Gen<'T> -> string public static string RenderSample(this Gen<T> gen) Resize(Gen, Size) Overrides the size parameter. Returns a generator which uses the given size instead of the runtime-size parameter. F# C# member Resize : gen:Gen<'T> * size:Size -> Gen<'T> public static Gen<T> Resize(this Gen<T> gen, Size size) Sample(Gen, Size, int) Returns a List of values produced by the generator. Parameters: gen: Value generator. size: The size parameter for the generator. count: The number of samples to produce, i.e. the length of the List. F# C# member Sample : gen:Gen<'T> * size:Size * count:int -> ResizeArray<'T> public static ResizeArray<T> Sample(this Gen<T> gen, Size size, int count) SampleFrom(Gen, Size, int) Returns a sample sequence of values by scaling through sizes from startSize. This is useful for visualizing how a range scales across different sizes. Uses a random seed for generating output. Parameters: gen: Value generator. size: The starting size parameter. count: The number of samples to produce (sizes will increment from startSize). F# C# member SampleFrom : gen:Gen<'T> * size:Size * count:int -> ResizeArray<'T> public static ResizeArray<T> SampleFrom(this Gen<T> gen, Size size, int count) SampleTree(Gen, Size, int) F# C# member SampleTree : gen:Gen<'T> * size:Size * count:int -> ResizeArray<Tree<'T>> public static ResizeArray<Tree<T>> SampleTree(this Gen<T> gen, Size size, int count) Scale(Gen, Func) Adjust the size parameter, by transforming it with the given function. F# C# member Scale : gen:Gen<'T> * scaler:Func<int, int> -> Gen<'T> public static Gen<T> Scale(this Gen<T> gen, Func<int, int> scaler) Select(Gen, Func, Gen, Gen, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); F# C# member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'V, 'W, 'TResult> * genB:Gen<'U> * genC:Gen<'V> * genD:Gen<'W> -> Gen<'TResult> public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, W, TResult> mapper, Gen<U> genB, Gen<V> genC, Gen<W> genD) Select(Gen, Func, Gen, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); F# C# member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'V, 'TResult> * genB:Gen<'U> * genC:Gen<'V> -> Gen<'TResult> public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, V, TResult> mapper, Gen<U> genB, Gen<V> genC) Select(Gen, Func, Gen) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); F# C# member Select : genA:Gen<'T> * mapper:Func<'T, 'U, 'TResult> * genB:Gen<'U> -> Gen<'TResult> public static Gen<TResult> Select(this Gen<T> genA, Func<T, U, TResult> mapper, Gen<U> genB) Select(Gen, Func) Projects each value of a generator into a new form. Similar to Enumerable.Select. Example: Gen<Point> pointGen = Gen.Int32(Range.Constant(0,200)) .Tuple2() .Select(tuple => new Point(tuple.Item1, tuple.Item2)); F# C# member Select : gen:Gen<'T> * mapper:Func<'T, 'TResult> -> Gen<'TResult> public static Gen<TResult> Select(this Gen<T> gen, Func<T, TResult> mapper) SelectMany(Gen, Func, Func) F# C# member SelectMany : gen:Gen<'T> * binder:Func<'T, Gen<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Gen<'TResult> public static Gen<TResult> SelectMany(this Gen<T> gen, Func<T, Gen<TCollection>> binder, Func<T, TCollection, TResult> projection) SelectMany(Gen, Func) F# C# member SelectMany : gen:Gen<'T> * binder:Func<'T, Gen<'U>> -> Gen<'U> public static Gen<U> SelectMany(this Gen<T> gen, Func<T, Gen<U>> binder) SelectRandom(Gen, Func) F# C# member SelectRandom : gen:Gen<'T> * binder:Func<Random<Tree<'T>>, Random<Tree<'TResult>>> -> Gen<'TResult> public static Gen<TResult> SelectRandom(this Gen<T> gen, Func<Random<Tree<T>>, Random<Tree<TResult>>> binder) SelectTree(Gen, Func) F# C# member SelectTree : gen:Gen<'T> * binder:Func<Tree<'T>, Tree<'TResult>> -> Gen<'TResult> public static Gen<TResult> SelectTree(this Gen<T> gen, Func<Tree<T>, Tree<TResult>> binder) Shrink(Gen, Func) Apply an additional shrinker to all generated trees. F# C# member Shrink : gen:Gen<'T> * shrinker:Func<'T, ResizeArray<'T>> -> Gen<'T> public static Gen<T> Shrink(this Gen<T> gen, Func<T, ResizeArray<T>> shrinker) ShrinkLazy(Gen, Func) Apply an additional shrinker to all generated trees. F# C# member ShrinkLazy : gen:Gen<'T> * shrinker:Func<'T, 'T seq> -> Gen<'T> public static Gen<T> ShrinkLazy(this Gen<T> gen, Func<T, TIEnumerable> shrinker) Some(Gen) Runs an option generator until it produces a 'Some'. F# C# member Some : Gen<Option<'T>> -> Gen<'T> public static Gen<T> Some(this Gen<Option<T>> gen) String(Gen, Range) Generates a random string using 'Range' to determine the length and the given character generator. F# C# member String : gen:Gen<char> * range:Range<int> -> Gen<string> public static Gen<string> String(this Gen<char> gen, Range<int> range) ToGen(Random) F# C# member ToGen : Random<Tree<'T>> -> Gen<'T> public static Gen<T> ToGen(this Random<Tree<T>> random) ToRandom(Gen) F# C# member ToRandom : Gen<'T> -> Random<Tree<'T>> public static Random<Tree<T>> ToRandom(this Gen<T> gen) TryFinally(Gen, Action) Ensures a cleanup action runs after the generator executes, even if an exception is thrown. Parameters: gen: The generator to wrap with cleanup logic. after: Action to execute after the generator completes or fails. F# C# member TryFinally : gen:Gen<'T> * after:Action -> Gen<'T> public static Gen<T> TryFinally(this Gen<T> gen, Action after) TryWith(Gen, Func) Catches exceptions thrown by a generator and handles them with a recovery function. Use this to provide fallback behavior when a generator might throw an exception. Parameters: gen: The generator that might throw an exception. after: Function that receives the exception and returns a recovery generator. Example: var gen = riskyGen.TryWith(ex => Gen.Constant(defaultValue)); F# C# member TryWith : gen:Gen<'T> * after:Func<exn, Gen<'T>> -> Gen<'T> public static Gen<T> TryWith(this Gen<T> gen, Func<exn, Gen<T>> after) Tuple2(Gen) F# C# member Tuple2 : Gen<'T> -> Gen<'T * 'T> public static Gen<(T, T)> Tuple2(this Gen<T> gen) Tuple3(Gen) F# C# member Tuple3 : Gen<'T> -> Gen<'T * 'T * 'T> public static Gen<(T, T, T)> Tuple3(this Gen<T> gen) Tuple4(Gen) F# C# member Tuple4 : Gen<'T> -> Gen<'T * 'T * 'T * 'T> public static Gen<(T, T, T, T)> Tuple4(this Gen<T> gen) Where(Gen, Func) Generates a value that satisfies a predicate. F# C# member Where : gen:Gen<'T> * predicate:Func<'T, bool> -> Gen<'T> public static Gen<T> Where(this Gen<T> gen, Func<T, bool> predicate) WithNull(Gen) F# C# member WithNull : Gen<'T> -> Gen<'T> public static Gen<T> WithNull(this Gen<T> self) Zip(Gen, Gen, Gen, Gen) F# C# member Zip : genA:Gen<'T> * genB:Gen<'U> * genC:Gen<'V> * genD:Gen<'W> -> Gen<'T * 'U * 'V * 'W> public static Gen<(T, U, V, W)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC, Gen<W> genD) Zip(Gen, Gen, Gen) F# C# member Zip : genA:Gen<'T> * genB:Gen<'U> * genC:Gen<'V> -> Gen<'T * 'U * 'V> public static Gen<(T, U, V)> Zip(this Gen<T> genA, Gen<U> genB, Gen<V> genC) Zip(Gen, Gen) F# C# member Zip : genA:Gen<'T> * genB:Gen<'U> -> Gen<'T * 'U> public static Gen<(T, U)> Zip(this Gen<T> genA, Gen<U> genB)"
  },
  "api/Hedgehog.Linq.GenFunctionExtensions.html": {
    "href": "api/Hedgehog.Linq.GenFunctionExtensions.html",
    "title": "Class GenFunctionExtensions | Hedgehog .NET",
    "summary": "Class GenFunctionExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type GenFunctionExtensions = member WithDistinctMapTo : inpGen:Gen<ResizeArray<'T>> * outGen:Gen<'TResult> -> Gen<ResizeArray<'T> * Func<'T, 'TResult>> member WithMapTo : inpGen:Gen<ResizeArray<'T>> * outGen:Gen<'TResult> -> Gen<ResizeArray<'T> * Func<'T, 'TResult>> public class GenFunctionExtensions { public static Gen<ResizeArray<T> * Func<T, TResult>> WithDistinctMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) public static Gen<ResizeArray<T> * Func<T, TResult>> WithMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) } Methods WithDistinctMapTo(Gen, Gen) Generates a list together with a function that maps each of the distinct elements in the list to distinct values generated by outGen. Distinct elements in the input list are guaranteed to map to distinct output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'], but never ['A'; 'A'; 'A'] or ['A'; 'B'; 'C']. Only use this if the output space is large enough that the required number of distinct output values are likely to be generated. The generated function throws if called with values not present in the input list. Parameters: inpGen: Generator for the input list. outGen: Generator for the output values. F# C# member WithDistinctMapTo : inpGen:Gen<ResizeArray<'T>> * outGen:Gen<'TResult> -> Gen<ResizeArray<'T> * Func<'T, 'TResult>> public static Gen<ResizeArray<T> * Func<T, TResult>> WithDistinctMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen) WithMapTo(Gen, Gen) Generates a list together with a function that maps each of the distinct elements in the list to values generated by outGen. Distinct elements in the input list may map to the same output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'] or ['A'; 'A'; 'A'], but never ['A'; 'B'; 'C']. The generated function throws if called with values not present in the input list. Parameters: inpGen: Generator for the input list. outGen: Generator for the output values. F# C# member WithMapTo : inpGen:Gen<ResizeArray<'T>> * outGen:Gen<'TResult> -> Gen<ResizeArray<'T> * Func<'T, 'TResult>> public static Gen<ResizeArray<T> * Func<T, TResult>> WithMapTo(this Gen<ResizeArray<T>> inpGen, Gen<TResult> outGen)"
  },
  "api/Hedgehog.Linq.GenListExtensions.html": {
    "href": "api/Hedgehog.Linq.GenListExtensions.html",
    "title": "Class GenListExtensions | Hedgehog .NET",
    "summary": "Class GenListExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type GenListExtensions = member AddElement : self:Gen<ResizeArray<'T>> * x:'T -> Gen<ResizeArray<'T>> member NotContains : self:Gen<ResizeArray<'T>> * value:'T -> Gen<ResizeArray<'T>> member NotIn : self:Gen<'T> * values:ResizeArray<'T> -> Gen<'T> member Sequence : Gen<'T> seq -> Gen<'T seq> member Traverse : self:'T seq * f:Func<'T, Gen<'TResult>> -> Gen<'TResult seq> public class GenListExtensions { public static Gen<ResizeArray<T>> AddElement(this Gen<ResizeArray<T>> self, T x) public static Gen<ResizeArray<T>> NotContains(this Gen<ResizeArray<T>> self, T value) public static Gen<T> NotIn(this Gen<T> self, ResizeArray<T> values) public static Gen<TIEnumerable> Sequence(this Gen<T>IEnumerable self) public static Gen<TResultIEnumerable> Traverse(this TIEnumerable self, Func<T, Gen<TResult>> f) } Methods AddElement(Gen, 'T) F# C# member AddElement : self:Gen<ResizeArray<'T>> * x:'T -> Gen<ResizeArray<'T>> public static Gen<ResizeArray<T>> AddElement(this Gen<ResizeArray<T>> self, T x) NotContains(Gen, 'T) Generates a list that does not contain the specified element. Shortcut for Gen.filter (not << List.contains x). F# C# member NotContains : self:Gen<ResizeArray<'T>> * value:'T -> Gen<ResizeArray<'T>> public static Gen<ResizeArray<T>> NotContains(this Gen<ResizeArray<T>> self, T value) NotIn(Gen, ResizeArray) Generates a value that is not contained in the specified list. F# C# member NotIn : self:Gen<'T> * values:ResizeArray<'T> -> Gen<'T> public static Gen<T> NotIn(this Gen<T> self, ResizeArray<T> values) Sequence(Gen) Turn a sequence of generators into a generator of a sequence. F# C# member Sequence : Gen<'T> seq -> Gen<'T seq> public static Gen<TIEnumerable> Sequence(this Gen<T>IEnumerable self) Traverse('T, Func) Apply a generator-producing function to each element and collect the results. F# C# member Traverse : self:'T seq * f:Func<'T, Gen<'TResult>> -> Gen<'TResult seq> public static Gen<TResultIEnumerable> Traverse(this TIEnumerable self, Func<T, Gen<TResult>> f)"
  },
  "api/Hedgehog.Linq.Property.html": {
    "href": "api/Hedgehog.Linq.Property.html",
    "title": "Class Property | Hedgehog .NET",
    "summary": "Class Property Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type Property = member CounterExample : Func<string> -> Property<unit> member Delay : Func<Property<'T>> -> Property<'T> member Discard : Property member Failure : Property member ForAll : Gen<'T> -> Property<'T> member ForAll : gen:Gen<'T> * k:Func<'T, Property<'TResult>> -> Property<'TResult> member FromBool : bool -> Property member FromGen : Gen<Lazy<Journal * Outcome<'T>>> -> Property<'T> member FromOutcome : Outcome<'T> -> Property<'T> member Success : 'T -> Property<'T> member Using : resource:'T * action:Func<'T, Property<'TResult>> -> Property<'TResult> public class Property { public static Property<void> CounterExample(Func<string> message) public static Property<T> Delay(Func<Property<T>> f) public static Property Discard() public static Property Failure() public static Property<T> ForAll(Gen<T> gen) public static Property<TResult> ForAll(Gen<T> gen, Func<T, Property<TResult>> k) public static Property FromBool(bool value) public static Property<T> FromGen(Gen<Lazy<(Journal, Outcome)<T>>> gen) public static Property<T> FromOutcome(Outcome<T> result) public static Property<T> Success(T value) public static Property<TResult> Using(T resource, Func<T, Property<TResult>> action) } Methods CounterExample(Func) Adds custom debug information that will be displayed when a property test fails. Use this to include variable values or other context to help diagnose failures. Parameters: message: A function that returns the debug message to display. Example: var property = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() from y in Gen.Int32(Range.Constant(-100, 1000)).ForAll() from _ in Property.CounterExample(() => $\"x = {x}, y = {y}, x * y = {x * y}\") select x * y >= 0; F# C# member CounterExample : Func<string> -> Property<unit> public static Property<void> CounterExample(Func<string> message) Delay(Func) F# C# member Delay : Func<Property<'T>> -> Property<'T> public static Property<T> Delay(Func<Property<T>> f) ForAll(Gen) F# C# member ForAll : Gen<'T> -> Property<'T> public static Property<T> ForAll(Gen<T> gen) ForAll(Gen, Func) F# C# member ForAll : gen:Gen<'T> * k:Func<'T, Property<'TResult>> -> Property<'TResult> public static Property<TResult> ForAll(Gen<T> gen, Func<T, Property<TResult>> k) FromBool(bool) F# C# member FromBool : bool -> Property public static Property FromBool(bool value) FromGen(Gen) F# C# member FromGen : Gen<Lazy<Journal * Outcome<'T>>> -> Property<'T> public static Property<T> FromGen(Gen<Lazy<(Journal, Outcome)<T>>> gen) FromOutcome(Outcome) F# C# member FromOutcome : Outcome<'T> -> Property<'T> public static Property<T> FromOutcome(Outcome<T> result) Success('T) F# C# member Success : 'T -> Property<'T> public static Property<T> Success(T value) Using('T, Func) F# C# member Using : resource:'T * action:Func<'T, Property<'TResult>> -> Property<'TResult> public static Property<TResult> Using(T resource, Func<T, Property<TResult>> action) Discard F# C# member Discard : Property public static Property Discard() Failure F# C# member Failure : Property public static Property Failure()"
  },
  "api/Hedgehog.Linq.PropertyConfigExtensions.html": {
    "href": "api/Hedgehog.Linq.PropertyConfigExtensions.html",
    "title": "Class PropertyConfigExtensions | Hedgehog .NET",
    "summary": "Class PropertyConfigExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type PropertyConfigExtensions = member WithShrinks : config:IPropertyConfig * shrinkLimit:int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig member WithTests : config:IPropertyConfig * testLimit:int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig member WithoutShrinks : IPropertyConfig -> IPropertyConfig public class PropertyConfigExtensions { public static IPropertyConfig WithShrinks(this IPropertyConfig config, int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit) public static IPropertyConfig WithTests(this IPropertyConfig config, int<MeasureProduct<tests, MeasureOne>> testLimit) public static IPropertyConfig WithoutShrinks(this IPropertyConfig config) } Methods WithShrinks(IPropertyConfig, int) Set the number of times a property is allowed to shrink before the test runner gives up and displays the counterexample. F# C# member WithShrinks : config:IPropertyConfig * shrinkLimit:int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig public static IPropertyConfig WithShrinks(this IPropertyConfig config, int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit) WithTests(IPropertyConfig, int) Set the number of times a property should be executed before it is considered successful. F# C# member WithTests : config:IPropertyConfig * testLimit:int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig public static IPropertyConfig WithTests(this IPropertyConfig config, int<MeasureProduct<tests, MeasureOne>> testLimit) WithoutShrinks(IPropertyConfig) Restores the default shrinking behavior. F# C# member WithoutShrinks : IPropertyConfig -> IPropertyConfig public static IPropertyConfig WithoutShrinks(this IPropertyConfig config)"
  },
  "api/Hedgehog.Linq.PropertyExtensions.html": {
    "href": "api/Hedgehog.Linq.PropertyExtensions.html",
    "title": "Class PropertyExtensions | Hedgehog .NET",
    "summary": "Class PropertyExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type PropertyExtensions = member Check : property:Property<bool> * config:IPropertyConfig -> unit member Check : Property<bool> -> unit member Check : property:Property<unit> * config:IPropertyConfig -> unit member Check : Property<unit> -> unit member Check : property:Property * config:IPropertyConfig -> unit member Check : Property -> unit member CheckAsync : property:Property<bool> * config:IPropertyConfig -> Task member CheckAsync : Property<bool> -> Task member CheckAsync : property:Property<unit> * config:IPropertyConfig -> Task member CheckAsync : Property<unit> -> Task member CheckAsync : property:Property * config:IPropertyConfig -> Task member CheckAsync : Property -> Task member ForAll : gen:Gen<'T> * bind:Func<'T, Property<'TResult>> -> Property<'TResult> member ForAll : Gen<'T> -> Property<'T> member IgnoreResult : Property<'T> -> Property member Recheck : property:Property<bool> * recheckData:string * config:IPropertyConfig -> unit member Recheck : property:Property<bool> * recheckData:string -> unit member Recheck : property:Property<unit> * recheckData:string * config:IPropertyConfig -> unit member Recheck : property:Property<unit> * recheckData:string -> unit member Recheck : property:Property * recheckData:string * config:IPropertyConfig -> unit member Recheck : property:Property * recheckData:string -> unit member RecheckAsync : property:Property<bool> * recheckData:string * config:IPropertyConfig -> Task member RecheckAsync : property:Property<bool> * recheckData:string -> Task member RecheckAsync : property:Property<unit> * recheckData:string * config:IPropertyConfig -> Task member RecheckAsync : property:Property<unit> * recheckData:string -> Task member RecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task member RecheckAsync : property:Property * recheckData:string -> Task member Render : property:Property<bool> * config:IPropertyConfig -> string member Render : Property<bool> -> string member Render : property:Property<unit> * config:IPropertyConfig -> string member Render : Property<unit> -> string member Render : property:Property * config:IPropertyConfig -> string member Render : Property -> string member Report : property:Property<bool> * config:IPropertyConfig -> Report member Report : Property<bool> -> Report member Report : property:Property<unit> * config:IPropertyConfig -> Report member Report : Property<unit> -> Report member Report : property:Property * config:IPropertyConfig -> Report member Report : Property -> Report member ReportAsync : property:Property<bool> * config:IPropertyConfig -> Task<Report> member ReportAsync : Property<bool> -> Task<Report> member ReportAsync : property:Property<unit> * config:IPropertyConfig -> Task<Report> member ReportAsync : Property<unit> -> Task<Report> member ReportAsync : property:Property * config:IPropertyConfig -> Task<Report> member ReportAsync : Property -> Task<Report> member ReportRecheck : property:Property<bool> * recheckData:string * config:IPropertyConfig -> Report member ReportRecheck : property:Property<bool> * recheckData:RecheckData -> Report member ReportRecheck : property:Property<bool> * recheckData:string -> Report member ReportRecheck : property:Property<unit> * recheckData:string * config:IPropertyConfig -> Report member ReportRecheck : property:Property<unit> * recheckData:string -> Report member ReportRecheck : property:Property * recheckData:string * config:IPropertyConfig -> Report member ReportRecheck : property:Property * recheckData:string -> Report member ReportRecheckAsync : property:Property<bool> * recheckData:string * config:IPropertyConfig -> Task<Report> member ReportRecheckAsync : property:Property<bool> * recheckData:string -> Task<Report> member ReportRecheckAsync : property:Property<unit> * recheckData:string * config:IPropertyConfig -> Task<Report> member ReportRecheckAsync : property:Property<unit> * recheckData:string -> Task<Report> member ReportRecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task<Report> member ReportRecheckAsync : property:Property * recheckData:string -> Task<Report> member Select : property:Property<'T> * mapper:Action<'T> -> Property member Select : property:Property<'T> * mapper:Func<'T, 'TResult> -> Property<'TResult> member SelectMany : property:Property<'T> * binder:Func<'T, Task> -> Property<unit> member SelectMany : property:Property<'T> * binder:Func<'T, Task> * projection:Action<'T, unit> -> Property member SelectMany : property:Property<'T> * binder:Func<'T, Task> * projection:Func<'T, unit, 'TResult> -> Property<'TResult> member SelectMany : property:Property<'T> * binder:Func<'T, Task<'TResult>> -> Property<'TResult> member SelectMany : property:Property<'T> * binder:Func<'T, Task<'TCollection>> * projection:Action<'T, 'TCollection> -> Property member SelectMany : property:Property<'T> * binder:Func<'T, Task<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Property<'TResult> member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Action<'T, 'TCollection> -> Property member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Property<'TResult> member ToGen : Property<'T> -> Gen<Lazy<Journal * Outcome<'T>>> member TryFinally : property:Property<'T> * onFinally:Action -> Property<'T> member TryWith : property:Property<'T> * onError:Func<exn, Property<'T>> -> Property<'T> member Where : property:Property<'T> * filter:Func<'T, bool> -> Property<'T> public class PropertyExtensions { public static void Check(this Property<bool> property, IPropertyConfig config) public static void Check(this Property<bool> property) public static void Check(this Property<void> property, IPropertyConfig config) public static void Check(this Property<void> property) public static void Check(this Property property, IPropertyConfig config) public static void Check(this Property property) public static Task CheckAsync(this Property<bool> property, IPropertyConfig config) public static Task CheckAsync(this Property<bool> property) public static Task CheckAsync(this Property<void> property, IPropertyConfig config) public static Task CheckAsync(this Property<void> property) public static Task CheckAsync(this Property property, IPropertyConfig config) public static Task CheckAsync(this Property property) public static Property<TResult> ForAll(this Gen<T> gen, Func<T, Property<TResult>> bind) public static Property<T> ForAll(this Gen<T> gen) public static Property IgnoreResult(this Property<T> property) public static void Recheck(this Property<bool> property, string recheckData, IPropertyConfig config) public static void Recheck(this Property<bool> property, string recheckData) public static void Recheck(this Property<void> property, string recheckData, IPropertyConfig config) public static void Recheck(this Property<void> property, string recheckData) public static void Recheck(this Property property, string recheckData, IPropertyConfig config) public static void Recheck(this Property property, string recheckData) public static Task RecheckAsync(this Property<bool> property, string recheckData, IPropertyConfig config) public static Task RecheckAsync(this Property<bool> property, string recheckData) public static Task RecheckAsync(this Property<void> property, string recheckData, IPropertyConfig config) public static Task RecheckAsync(this Property<void> property, string recheckData) public static Task RecheckAsync(this Property property, string recheckData, IPropertyConfig config) public static Task RecheckAsync(this Property property, string recheckData) public static string Render(this Property<bool> property, IPropertyConfig config) public static string Render(this Property<bool> property) public static string Render(this Property<void> property, IPropertyConfig config) public static string Render(this Property<void> property) public static string Render(this Property property, IPropertyConfig config) public static string Render(this Property property) public static Report Report(this Property<bool> property, IPropertyConfig config) public static Report Report(this Property<bool> property) public static Report Report(this Property<void> property, IPropertyConfig config) public static Report Report(this Property<void> property) public static Report Report(this Property property, IPropertyConfig config) public static Report Report(this Property property) public static Task<Report> ReportAsync(this Property<bool> property, IPropertyConfig config) public static Task<Report> ReportAsync(this Property<bool> property) public static Task<Report> ReportAsync(this Property<void> property, IPropertyConfig config) public static Task<Report> ReportAsync(this Property<void> property) public static Task<Report> ReportAsync(this Property property, IPropertyConfig config) public static Task<Report> ReportAsync(this Property property) public static Report ReportRecheck(this Property<bool> property, string recheckData, IPropertyConfig config) public static Report ReportRecheck(this Property<bool> property, RecheckData recheckData) public static Report ReportRecheck(this Property<bool> property, string recheckData) public static Report ReportRecheck(this Property<void> property, string recheckData, IPropertyConfig config) public static Report ReportRecheck(this Property<void> property, string recheckData) public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) public static Report ReportRecheck(this Property property, string recheckData) public static Task<Report> ReportRecheckAsync(this Property<bool> property, string recheckData, IPropertyConfig config) public static Task<Report> ReportRecheckAsync(this Property<bool> property, string recheckData) public static Task<Report> ReportRecheckAsync(this Property<void> property, string recheckData, IPropertyConfig config) public static Task<Report> ReportRecheckAsync(this Property<void> property, string recheckData) public static Task<Report> ReportRecheckAsync(this Property property, string recheckData, IPropertyConfig config) public static Task<Report> ReportRecheckAsync(this Property property, string recheckData) public static Property Select(this Property<T> property, Action<T> mapper) public static Property<TResult> Select(this Property<T> property, Func<T, TResult> mapper) public static Property<void> SelectMany(this Property<T> property, Func<T, Task> binder) public static Property SelectMany(this Property<T> property, Func<T, Task> binder, Action<T, void> projection) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Task> binder, Func<T, void, TResult> projection) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Task<TResult>> binder) public static Property SelectMany(this Property<T> property, Func<T, Task<TCollection>> binder, Action<T, TCollection> projection) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Task<TCollection>> binder, Func<T, TCollection, TResult> projection) public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) public static Gen<Lazy<(Journal, Outcome)<T>>> ToGen(this Property<T> property) public static Property<T> TryFinally(this Property<T> property, Action onFinally) public static Property<T> TryWith(this Property<T> property, Func<exn, Property<T>> onError) public static Property<T> Where(this Property<T> property, Func<T, bool> filter) } Methods Check(Property, IPropertyConfig) Runs the property test with custom configuration and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member Check : property:Property * config:IPropertyConfig -> unit public static void Check(this Property property, IPropertyConfig config) Check(Property) Runs the property test and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. F# C# member Check : Property -> unit public static void Check(this Property property) Check(Property, IPropertyConfig) Runs the property test with custom configuration and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member Check : property:Property * config:IPropertyConfig -> unit public static void Check(this Property property, IPropertyConfig config) Check(Property) Runs the property test and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. F# C# member Check : Property -> unit public static void Check(this Property property) Check(Property, IPropertyConfig) Runs the property test with custom configuration and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member Check : property:Property * config:IPropertyConfig -> unit public static void Check(this Property property, IPropertyConfig config) Check(Property) Runs the property test and throws an exception if it fails. Use this in unit tests to verify that a property holds for randomly generated test cases. Parameters: property: The property to check. F# C# member Check : Property -> unit public static void Check(this Property property) CheckAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member CheckAsync : property:Property * config:IPropertyConfig -> Task public static Task CheckAsync(this Property property, IPropertyConfig config) CheckAsync(Property) Runs the property test asynchronously and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. F# C# member CheckAsync : Property -> Task public static Task CheckAsync(this Property property) CheckAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member CheckAsync : property:Property * config:IPropertyConfig -> Task public static Task CheckAsync(this Property property, IPropertyConfig config) CheckAsync(Property) Runs the property test asynchronously and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. F# C# member CheckAsync : Property -> Task public static Task CheckAsync(this Property property) CheckAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member CheckAsync : property:Property * config:IPropertyConfig -> Task public static Task CheckAsync(this Property property, IPropertyConfig config) CheckAsync(Property) Runs the property test asynchronously and throws an exception if it fails. Use this for non-blocking execution in async contexts. Parameters: property: The property to check. F# C# member CheckAsync : Property -> Task public static Task CheckAsync(this Property property) ForAll(Gen, Func) Creates a property from a generator and applies a function to it, allowing it to be used in LINQ query comprehensions. \"For all\" means the property will be tested for all values of that type generated by the generator. Parameters: gen: The generator to create a property from. bind: The function to apply to each generated value. F# C# member ForAll : gen:Gen<'T> * bind:Func<'T, Property<'TResult>> -> Property<'TResult> public static Property<TResult> ForAll(this Gen<T> gen, Func<T, Property<TResult>> bind) ForAll(Gen) Creates a property from a generator, allowing it to be used in LINQ query comprehensions. \"For all\" means the property will be tested for all values of that type generated by the generator. Parameters: gen: The generator to create a property from. F# C# member ForAll : Gen<'T> -> Property<'T> public static Property<T> ForAll(this Gen<T> gen) IgnoreResult(Property) Discards the result of a property, converting it to Property. This is useful when using assertion libraries that return non-unit types (e.g., fluent assertions). Note: The assertion must throw an exception on failure for the property to fail. Assertions that throw exceptions will still cause the property to fail. Parameters: property: The property whose result should be ignored. Example: var property = from x in Gen.Int32(Range.Linear(0, 100)).ForAll() select x.Should().Be(42); // Returns IAssertion property.IgnoreResult().Check(); // Convert to and run F# C# member IgnoreResult : Property<'T> -> Property public static Property IgnoreResult(this Property<T> property) Recheck(Property, string, IPropertyConfig) Rechecks a previously failed property test using the same random seed and test inputs, with custom configuration. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member Recheck : property:Property * recheckData:string * config:IPropertyConfig -> unit public static void Recheck(this Property property, string recheckData, IPropertyConfig config) Recheck(Property, string) Rechecks a previously failed property test using the same random seed and test inputs. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member Recheck : property:Property * recheckData:string -> unit public static void Recheck(this Property property, string recheckData) Recheck(Property, string, IPropertyConfig) Rechecks a previously failed property test using the same random seed and test inputs, with custom configuration. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member Recheck : property:Property * recheckData:string * config:IPropertyConfig -> unit public static void Recheck(this Property property, string recheckData, IPropertyConfig config) Recheck(Property, string) Rechecks a previously failed property test using the same random seed and test inputs. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member Recheck : property:Property * recheckData:string -> unit public static void Recheck(this Property property, string recheckData) Recheck(Property, string, IPropertyConfig) Rechecks a previously failed property test using the same random seed and test inputs, with custom configuration. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member Recheck : property:Property * recheckData:string * config:IPropertyConfig -> unit public static void Recheck(this Property property, string recheckData, IPropertyConfig config) Recheck(Property, string) Rechecks a previously failed property test using the same random seed and test inputs. Use this to reproduce and debug a specific failure without running all test cases again. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member Recheck : property:Property * recheckData:string -> unit public static void Recheck(this Property property, string recheckData) RecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously using the same random seed and test inputs, with custom configuration. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member RecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task public static Task RecheckAsync(this Property property, string recheckData, IPropertyConfig config) RecheckAsync(Property, string) Rechecks a previously failed property test asynchronously using the same random seed and test inputs. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member RecheckAsync : property:Property * recheckData:string -> Task public static Task RecheckAsync(this Property property, string recheckData) RecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously using the same random seed and test inputs, with custom configuration. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member RecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task public static Task RecheckAsync(this Property property, string recheckData, IPropertyConfig config) RecheckAsync(Property, string) Rechecks a previously failed property test asynchronously using the same random seed and test inputs. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member RecheckAsync : property:Property * recheckData:string -> Task public static Task RecheckAsync(this Property property, string recheckData) RecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously using the same random seed and test inputs, with custom configuration. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member RecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task public static Task RecheckAsync(this Property property, string recheckData, IPropertyConfig config) RecheckAsync(Property, string) Rechecks a previously failed property test asynchronously using the same random seed and test inputs. Returns a task that completes when the recheck is done, throwing an exception if it fails. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member RecheckAsync : property:Property * recheckData:string -> Task public static Task RecheckAsync(this Property property, string recheckData) Render(Property, IPropertyConfig) F# C# member Render : property:Property * config:IPropertyConfig -> string public static string Render(this Property property, IPropertyConfig config) Render(Property) F# C# member Render : Property -> string public static string Render(this Property property) Render(Property, IPropertyConfig) F# C# member Render : property:Property * config:IPropertyConfig -> string public static string Render(this Property property, IPropertyConfig config) Render(Property) F# C# member Render : Property -> string public static string Render(this Property property) Render(Property, IPropertyConfig) F# C# member Render : property:Property * config:IPropertyConfig -> string public static string Render(this Property property, IPropertyConfig config) Render(Property) F# C# member Render : Property -> string public static string Render(this Property property) Report(Property, IPropertyConfig) F# C# member Report : property:Property * config:IPropertyConfig -> Report public static Report Report(this Property property, IPropertyConfig config) Report(Property) F# C# member Report : Property -> Report public static Report Report(this Property property) Report(Property, IPropertyConfig) F# C# member Report : property:Property * config:IPropertyConfig -> Report public static Report Report(this Property property, IPropertyConfig config) Report(Property) F# C# member Report : Property -> Report public static Report Report(this Property property) Report(Property, IPropertyConfig) F# C# member Report : property:Property * config:IPropertyConfig -> Report public static Report Report(this Property property, IPropertyConfig config) Report(Property) F# C# member Report : Property -> Report public static Report Report(this Property property) ReportAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member ReportAsync : property:Property * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportAsync(this Property property, IPropertyConfig config) ReportAsync(Property) Runs the property test asynchronously and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. F# C# member ReportAsync : Property -> Task<Report> public static Task<Report> ReportAsync(this Property property) ReportAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member ReportAsync : property:Property * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportAsync(this Property property, IPropertyConfig config) ReportAsync(Property) Runs the property test asynchronously and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. F# C# member ReportAsync : Property -> Task<Report> public static Task<Report> ReportAsync(this Property property) ReportAsync(Property, IPropertyConfig) Runs the property test asynchronously with custom configuration and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. config: Custom property configuration (e.g., number of test cases). F# C# member ReportAsync : property:Property * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportAsync(this Property property, IPropertyConfig config) ReportAsync(Property) Runs the property test asynchronously and returns a task with the test report. Use this for non-blocking execution of property tests. Parameters: property: The property to check. F# C# member ReportAsync : Property -> Task<Report> public static Task<Report> ReportAsync(this Property property) ReportRecheck(Property, string, IPropertyConfig) F# C# member ReportRecheck : property:Property * recheckData:string * config:IPropertyConfig -> Report public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) ReportRecheck(Property, RecheckData) F# C# member ReportRecheck : property:Property<bool> * recheckData:RecheckData -> Report public static Report ReportRecheck(this Property<bool> property, RecheckData recheckData) ReportRecheck(Property, string) F# C# member ReportRecheck : property:Property * recheckData:string -> Report public static Report ReportRecheck(this Property property, string recheckData) ReportRecheck(Property, string, IPropertyConfig) F# C# member ReportRecheck : property:Property * recheckData:string * config:IPropertyConfig -> Report public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) ReportRecheck(Property, string) F# C# member ReportRecheck : property:Property * recheckData:string -> Report public static Report ReportRecheck(this Property property, string recheckData) ReportRecheck(Property, string, IPropertyConfig) F# C# member ReportRecheck : property:Property * recheckData:string * config:IPropertyConfig -> Report public static Report ReportRecheck(this Property property, string recheckData, IPropertyConfig config) ReportRecheck(Property, string) F# C# member ReportRecheck : property:Property * recheckData:string -> Report public static Report ReportRecheck(this Property property, string recheckData) ReportRecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously with custom configuration and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member ReportRecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData, IPropertyConfig config) ReportRecheckAsync(Property, string) Rechecks a previously failed property test asynchronously and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member ReportRecheckAsync : property:Property * recheckData:string -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData) ReportRecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously with custom configuration and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member ReportRecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData, IPropertyConfig config) ReportRecheckAsync(Property, string) Rechecks a previously failed property test asynchronously and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member ReportRecheckAsync : property:Property * recheckData:string -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData) ReportRecheckAsync(Property, string, IPropertyConfig) Rechecks a previously failed property test asynchronously with custom configuration and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. config: Custom property configuration. F# C# member ReportRecheckAsync : property:Property * recheckData:string * config:IPropertyConfig -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData, IPropertyConfig config) ReportRecheckAsync(Property, string) Rechecks a previously failed property test asynchronously and returns the test report. Parameters: property: The property to recheck. recheckData: The recheck data string from a previous test failure report. F# C# member ReportRecheckAsync : property:Property * recheckData:string -> Task<Report> public static Task<Report> ReportRecheckAsync(this Property property, string recheckData) Select(Property, Action) F# C# member Select : property:Property<'T> * mapper:Action<'T> -> Property public static Property Select(this Property<T> property, Action<T> mapper) Select(Property, Func) F# C# member Select : property:Property<'T> * mapper:Func<'T, 'TResult> -> Property<'TResult> public static Property<TResult> Select(this Property<T> property, Func<T, TResult> mapper) SelectMany(Property, Func) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Task<'TResult>> -> Property<'TResult> public static Property<TResult> SelectMany(this Property<T> property, Func<T, Task<TResult>> binder) SelectMany(Property, Func, Action) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Action<'T, 'TCollection> -> Property public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) SelectMany(Property, Func, Func) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Property<'TResult> public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) SelectMany(Property, Func) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Task<'TResult>> -> Property<'TResult> public static Property<TResult> SelectMany(this Property<T> property, Func<T, Task<TResult>> binder) SelectMany(Property, Func, Action) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Action<'T, 'TCollection> -> Property public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) SelectMany(Property, Func, Func) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Property<'TResult> public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) SelectMany(Property, Func, Action) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Action<'T, 'TCollection> -> Property public static Property SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Action<T, TCollection> projection) SelectMany(Property, Func, Func) F# C# member SelectMany : property:Property<'T> * binder:Func<'T, Property<'TCollection>> * projection:Func<'T, 'TCollection, 'TResult> -> Property<'TResult> public static Property<TResult> SelectMany(this Property<T> property, Func<T, Property<TCollection>> binder, Func<T, TCollection, TResult> projection) ToGen(Property) F# C# member ToGen : Property<'T> -> Gen<Lazy<Journal * Outcome<'T>>> public static Gen<Lazy<(Journal, Outcome)<T>>> ToGen(this Property<T> property) TryFinally(Property, Action) F# C# member TryFinally : property:Property<'T> * onFinally:Action -> Property<'T> public static Property<T> TryFinally(this Property<T> property, Action onFinally) TryWith(Property, Func) F# C# member TryWith : property:Property<'T> * onError:Func<exn, Property<'T>> -> Property<'T> public static Property<T> TryWith(this Property<T> property, Func<exn, Property<T>> onError) Where(Property, Func) F# C# member Where : property:Property<'T> * filter:Func<'T, bool> -> Property<'T> public static Property<T> Where(this Property<T> property, Func<T, bool> filter)"
  },
  "api/Hedgehog.Linq.Range.html": {
    "href": "api/Hedgehog.Linq.Range.html",
    "title": "Class Range | Hedgehog .NET",
    "summary": "Class Range Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type Range = member Constant : x:'T * y:'T -> Range<'T> member Constant : z:'T * x:'T * y:'T -> Range<'T> member ConstantBoundedByte : Range<byte> member ConstantBoundedDecimal : Range<decimal> member ConstantBoundedDouble : Range<double> member ConstantBoundedInt16 : Range<int16> member ConstantBoundedInt32 : Range<int32> member ConstantBoundedInt64 : Range<int64> member ConstantBoundedSByte : Range<sbyte> member ConstantBoundedSingle : Range<single> member ConstantBoundedUInt16 : Range<uint16> member ConstantBoundedUInt32 : Range<uint32> member ConstantBoundedUInt64 : Range<uint64> member ExponentialBoundedByte : Range<byte> member ExponentialBoundedDecimal : Range<decimal> member ExponentialBoundedDouble : Range<double> member ExponentialBoundedInt16 : Range<int16> member ExponentialBoundedInt32 : Range<int32> member ExponentialBoundedInt64 : Range<int64> member ExponentialBoundedSByte : Range<sbyte> member ExponentialBoundedSingle : Range<single> member ExponentialBoundedUInt16 : Range<uint16> member ExponentialBoundedUInt32 : Range<uint32> member ExponentialBoundedUInt64 : Range<uint64> member ExponentialByte : x:byte * y:byte -> Range<byte> member ExponentialDecimal : x:decimal * y:decimal -> Range<decimal> member ExponentialDouble : x:double * y:double -> Range<double> member ExponentialFromByte : z:byte * x:byte * y:byte -> Range<byte> member ExponentialFromDecimal : z:decimal * x:decimal * y:decimal -> Range<decimal> member ExponentialFromDouble : z:double * x:double * y:double -> Range<double> member ExponentialFromInt16 : z:int16 * x:int16 * y:int16 -> Range<int16> member ExponentialFromInt32 : z:int32 * x:int32 * y:int32 -> Range<int32> member ExponentialFromInt64 : z:int64 * x:int64 * y:int64 -> Range<int64> member ExponentialFromSByte : z:sbyte * x:sbyte * y:sbyte -> Range<sbyte> member ExponentialFromSingle : z:single * x:single * y:single -> Range<single> member ExponentialFromUInt16 : z:uint16 * x:uint16 * y:uint16 -> Range<uint16> member ExponentialFromUInt32 : z:uint32 * x:uint32 * y:uint32 -> Range<uint32> member ExponentialFromUInt64 : z:uint64 * x:uint64 * y:uint64 -> Range<uint64> member ExponentialInt16 : x:int16 * y:int16 -> Range<int16> member ExponentialInt32 : x:int32 * y:int32 -> Range<int32> member ExponentialInt64 : x:int64 * y:int64 -> Range<int64> member ExponentialSByte : x:sbyte * y:sbyte -> Range<sbyte> member ExponentialSingle : x:single * y:single -> Range<single> member ExponentialUInt16 : x:uint16 * y:uint16 -> Range<uint16> member ExponentialUInt32 : x:uint32 * y:uint32 -> Range<uint32> member ExponentialUInt64 : x:uint64 * y:uint64 -> Range<uint64> member FromValue : 'T -> Range<'T> member LinearBoundedByte : Range<byte> member LinearBoundedDecimal : Range<decimal> member LinearBoundedDouble : Range<double> member LinearBoundedInt16 : Range<int16> member LinearBoundedInt32 : Range<int32> member LinearBoundedInt64 : Range<int64> member LinearBoundedSByte : Range<sbyte> member LinearBoundedSingle : Range<single> member LinearBoundedUInt16 : Range<uint16> member LinearBoundedUInt32 : Range<uint32> member LinearBoundedUInt64 : Range<uint64> member LinearByte : x:byte * y:byte -> Range<byte> member LinearDecimal : x:decimal * y:decimal -> Range<decimal> member LinearDouble : x:double * y:double -> Range<double> member LinearFromByte : z:byte * x:byte * y:byte -> Range<byte> member LinearFromDecimal : z:decimal * x:decimal * y:decimal -> Range<decimal> member LinearFromDouble : z:double * x:double * y:double -> Range<double> member LinearFromInt16 : z:int16 * x:int16 * y:int16 -> Range<int16> member LinearFromInt32 : z:int32 * x:int32 * y:int32 -> Range<int32> member LinearFromInt64 : z:int64 * x:int64 * y:int64 -> Range<int64> member LinearFromSByte : z:sbyte * x:sbyte * y:sbyte -> Range<sbyte> member LinearFromSingle : z:single * x:single * y:single -> Range<single> member LinearFromUInt16 : z:uint16 * x:uint16 * y:uint16 -> Range<uint16> member LinearFromUInt32 : z:uint32 * x:uint32 * y:uint32 -> Range<uint32> member LinearFromUInt64 : z:uint64 * x:uint64 * y:uint64 -> Range<uint64> member LinearInt16 : x:int16 * y:int16 -> Range<int16> member LinearInt32 : x:int32 * y:int32 -> Range<int32> member LinearInt64 : x:int64 * y:int64 -> Range<int64> member LinearSByte : x:sbyte * y:sbyte -> Range<sbyte> member LinearSingle : x:single * y:single -> Range<single> member LinearUInt16 : x:uint16 * y:uint16 -> Range<uint16> member LinearUInt32 : x:uint32 * y:uint32 -> Range<uint32> member LinearUInt64 : x:uint64 * y:uint64 -> Range<uint64> member Singleton : 'T -> Range<'T> public class Range { public static Range<T> Constant(T x, T y) public static Range<T> Constant(T z, T x, T y) public static Range<byte> ConstantBoundedByte() public static Range<decimal> ConstantBoundedDecimal() public static Range<double> ConstantBoundedDouble() public static Range<int16> ConstantBoundedInt16() public static Range<int32> ConstantBoundedInt32() public static Range<int64> ConstantBoundedInt64() public static Range<sbyte> ConstantBoundedSByte() public static Range<single> ConstantBoundedSingle() public static Range<uint16> ConstantBoundedUInt16() public static Range<uint32> ConstantBoundedUInt32() public static Range<uint64> ConstantBoundedUInt64() public static Range<byte> ExponentialBoundedByte() public static Range<decimal> ExponentialBoundedDecimal() public static Range<double> ExponentialBoundedDouble() public static Range<int16> ExponentialBoundedInt16() public static Range<int32> ExponentialBoundedInt32() public static Range<int64> ExponentialBoundedInt64() public static Range<sbyte> ExponentialBoundedSByte() public static Range<single> ExponentialBoundedSingle() public static Range<uint16> ExponentialBoundedUInt16() public static Range<uint32> ExponentialBoundedUInt32() public static Range<uint64> ExponentialBoundedUInt64() public static Range<byte> ExponentialByte(byte x, byte y) public static Range<decimal> ExponentialDecimal(decimal x, decimal y) public static Range<double> ExponentialDouble(double x, double y) public static Range<byte> ExponentialFromByte(byte z, byte x, byte y) public static Range<decimal> ExponentialFromDecimal(decimal z, decimal x, decimal y) public static Range<double> ExponentialFromDouble(double z, double x, double y) public static Range<int16> ExponentialFromInt16(int16 z, int16 x, int16 y) public static Range<int32> ExponentialFromInt32(int32 z, int32 x, int32 y) public static Range<int64> ExponentialFromInt64(int64 z, int64 x, int64 y) public static Range<sbyte> ExponentialFromSByte(sbyte z, sbyte x, sbyte y) public static Range<single> ExponentialFromSingle(single z, single x, single y) public static Range<uint16> ExponentialFromUInt16(uint16 z, uint16 x, uint16 y) public static Range<uint32> ExponentialFromUInt32(uint32 z, uint32 x, uint32 y) public static Range<uint64> ExponentialFromUInt64(uint64 z, uint64 x, uint64 y) public static Range<int16> ExponentialInt16(int16 x, int16 y) public static Range<int32> ExponentialInt32(int32 x, int32 y) public static Range<int64> ExponentialInt64(int64 x, int64 y) public static Range<sbyte> ExponentialSByte(sbyte x, sbyte y) public static Range<single> ExponentialSingle(single x, single y) public static Range<uint16> ExponentialUInt16(uint16 x, uint16 y) public static Range<uint32> ExponentialUInt32(uint32 x, uint32 y) public static Range<uint64> ExponentialUInt64(uint64 x, uint64 y) public static Range<T> FromValue(T value) public static Range<byte> LinearBoundedByte() public static Range<decimal> LinearBoundedDecimal() public static Range<double> LinearBoundedDouble() public static Range<int16> LinearBoundedInt16() public static Range<int32> LinearBoundedInt32() public static Range<int64> LinearBoundedInt64() public static Range<sbyte> LinearBoundedSByte() public static Range<single> LinearBoundedSingle() public static Range<uint16> LinearBoundedUInt16() public static Range<uint32> LinearBoundedUInt32() public static Range<uint64> LinearBoundedUInt64() public static Range<byte> LinearByte(byte x, byte y) public static Range<decimal> LinearDecimal(decimal x, decimal y) public static Range<double> LinearDouble(double x, double y) public static Range<byte> LinearFromByte(byte z, byte x, byte y) public static Range<decimal> LinearFromDecimal(decimal z, decimal x, decimal y) public static Range<double> LinearFromDouble(double z, double x, double y) public static Range<int16> LinearFromInt16(int16 z, int16 x, int16 y) public static Range<int32> LinearFromInt32(int32 z, int32 x, int32 y) public static Range<int64> LinearFromInt64(int64 z, int64 x, int64 y) public static Range<sbyte> LinearFromSByte(sbyte z, sbyte x, sbyte y) public static Range<single> LinearFromSingle(single z, single x, single y) public static Range<uint16> LinearFromUInt16(uint16 z, uint16 x, uint16 y) public static Range<uint32> LinearFromUInt32(uint32 z, uint32 x, uint32 y) public static Range<uint64> LinearFromUInt64(uint64 z, uint64 x, uint64 y) public static Range<int16> LinearInt16(int16 x, int16 y) public static Range<int32> LinearInt32(int32 x, int32 y) public static Range<int64> LinearInt64(int64 x, int64 y) public static Range<sbyte> LinearSByte(sbyte x, sbyte y) public static Range<single> LinearSingle(single x, single y) public static Range<uint16> LinearUInt16(uint16 x, uint16 y) public static Range<uint32> LinearUInt32(uint32 x, uint32 y) public static Range<uint64> LinearUInt64(uint64 x, uint64 y) public static Range<T> Singleton(T value) } Methods Constant('T, 'T) Construct a range which is unaffected by the size parameter. F# C# member Constant : x:'T * y:'T -> Range<'T> public static Range<T> Constant(T x, T y) Constant('T, 'T, 'T) Construct a range which is unaffected by the size parameter with a origin point which may differ from the bounds. F# C# member Constant : z:'T * x:'T * y:'T -> Range<'T> public static Range<T> Constant(T z, T x, T y) ConstantBoundedByte Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedByte : Range<byte> public static Range<byte> ConstantBoundedByte() ConstantBoundedDecimal Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedDecimal : Range<decimal> public static Range<decimal> ConstantBoundedDecimal() ConstantBoundedDouble Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedDouble : Range<double> public static Range<double> ConstantBoundedDouble() ConstantBoundedInt16 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedInt16 : Range<int16> public static Range<int16> ConstantBoundedInt16() ConstantBoundedInt32 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedInt32 : Range<int32> public static Range<int32> ConstantBoundedInt32() ConstantBoundedInt64 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedInt64 : Range<int64> public static Range<int64> ConstantBoundedInt64() ConstantBoundedSByte Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedSByte : Range<sbyte> public static Range<sbyte> ConstantBoundedSByte() ConstantBoundedSingle Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedSingle : Range<single> public static Range<single> ConstantBoundedSingle() ConstantBoundedUInt16 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedUInt16 : Range<uint16> public static Range<uint16> ConstantBoundedUInt16() ConstantBoundedUInt32 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedUInt32 : Range<uint32> public static Range<uint32> ConstantBoundedUInt32() ConstantBoundedUInt64 Construct a range which is unaffected by the size parameter using the full range of a data type. F# C# member ConstantBoundedUInt64 : Range<uint64> public static Range<uint64> ConstantBoundedUInt64() ExponentialBoundedByte Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedByte : Range<byte> public static Range<byte> ExponentialBoundedByte() ExponentialBoundedDecimal Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedDecimal : Range<decimal> public static Range<decimal> ExponentialBoundedDecimal() ExponentialBoundedDouble Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedDouble : Range<double> public static Range<double> ExponentialBoundedDouble() ExponentialBoundedInt16 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedInt16 : Range<int16> public static Range<int16> ExponentialBoundedInt16() ExponentialBoundedInt32 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedInt32 : Range<int32> public static Range<int32> ExponentialBoundedInt32() ExponentialBoundedInt64 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedInt64 : Range<int64> public static Range<int64> ExponentialBoundedInt64() ExponentialBoundedSByte Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedSByte : Range<sbyte> public static Range<sbyte> ExponentialBoundedSByte() ExponentialBoundedSingle Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedSingle : Range<single> public static Range<single> ExponentialBoundedSingle() ExponentialBoundedUInt16 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedUInt16 : Range<uint16> public static Range<uint16> ExponentialBoundedUInt16() ExponentialBoundedUInt32 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedUInt32 : Range<uint32> public static Range<uint32> ExponentialBoundedUInt32() ExponentialBoundedUInt64 Construct a range which is scaled exponentially relative to the size parameter and uses the full range of a data type. F# C# member ExponentialBoundedUInt64 : Range<uint64> public static Range<uint64> ExponentialBoundedUInt64() ExponentialByte(byte, byte) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialByte : x:byte * y:byte -> Range<byte> public static Range<byte> ExponentialByte(byte x, byte y) ExponentialDecimal(decimal, decimal) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialDecimal : x:decimal * y:decimal -> Range<decimal> public static Range<decimal> ExponentialDecimal(decimal x, decimal y) ExponentialDouble(double, double) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialDouble : x:double * y:double -> Range<double> public static Range<double> ExponentialDouble(double x, double y) ExponentialFromByte(byte, byte, byte) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromByte : z:byte * x:byte * y:byte -> Range<byte> public static Range<byte> ExponentialFromByte(byte z, byte x, byte y) ExponentialFromDecimal(decimal, decimal, decimal) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromDecimal : z:decimal * x:decimal * y:decimal -> Range<decimal> public static Range<decimal> ExponentialFromDecimal(decimal z, decimal x, decimal y) ExponentialFromDouble(double, double, double) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromDouble : z:double * x:double * y:double -> Range<double> public static Range<double> ExponentialFromDouble(double z, double x, double y) ExponentialFromInt16(int16, int16, int16) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromInt16 : z:int16 * x:int16 * y:int16 -> Range<int16> public static Range<int16> ExponentialFromInt16(int16 z, int16 x, int16 y) ExponentialFromInt32(int32, int32, int32) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromInt32 : z:int32 * x:int32 * y:int32 -> Range<int32> public static Range<int32> ExponentialFromInt32(int32 z, int32 x, int32 y) ExponentialFromInt64(int64, int64, int64) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromInt64 : z:int64 * x:int64 * y:int64 -> Range<int64> public static Range<int64> ExponentialFromInt64(int64 z, int64 x, int64 y) ExponentialFromSByte(sbyte, sbyte, sbyte) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromSByte : z:sbyte * x:sbyte * y:sbyte -> Range<sbyte> public static Range<sbyte> ExponentialFromSByte(sbyte z, sbyte x, sbyte y) ExponentialFromSingle(single, single, single) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromSingle : z:single * x:single * y:single -> Range<single> public static Range<single> ExponentialFromSingle(single z, single x, single y) ExponentialFromUInt16(uint16, uint16, uint16) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromUInt16 : z:uint16 * x:uint16 * y:uint16 -> Range<uint16> public static Range<uint16> ExponentialFromUInt16(uint16 z, uint16 x, uint16 y) ExponentialFromUInt32(uint32, uint32, uint32) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromUInt32 : z:uint32 * x:uint32 * y:uint32 -> Range<uint32> public static Range<uint32> ExponentialFromUInt32(uint32 z, uint32 x, uint32 y) ExponentialFromUInt64(uint64, uint64, uint64) Construct a range which scales the bounds exponentially relative to the size parameter. F# C# member ExponentialFromUInt64 : z:uint64 * x:uint64 * y:uint64 -> Range<uint64> public static Range<uint64> ExponentialFromUInt64(uint64 z, uint64 x, uint64 y) ExponentialInt16(int16, int16) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialInt16 : x:int16 * y:int16 -> Range<int16> public static Range<int16> ExponentialInt16(int16 x, int16 y) ExponentialInt32(int32, int32) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialInt32 : x:int32 * y:int32 -> Range<int32> public static Range<int32> ExponentialInt32(int32 x, int32 y) ExponentialInt64(int64, int64) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialInt64 : x:int64 * y:int64 -> Range<int64> public static Range<int64> ExponentialInt64(int64 x, int64 y) ExponentialSByte(sbyte, sbyte) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialSByte : x:sbyte * y:sbyte -> Range<sbyte> public static Range<sbyte> ExponentialSByte(sbyte x, sbyte y) ExponentialSingle(single, single) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialSingle : x:single * y:single -> Range<single> public static Range<single> ExponentialSingle(single x, single y) ExponentialUInt16(uint16, uint16) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialUInt16 : x:uint16 * y:uint16 -> Range<uint16> public static Range<uint16> ExponentialUInt16(uint16 x, uint16 y) ExponentialUInt32(uint32, uint32) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialUInt32 : x:uint32 * y:uint32 -> Range<uint32> public static Range<uint32> ExponentialUInt32(uint32 x, uint32 y) ExponentialUInt64(uint64, uint64) Construct a range which scales the second bound exponentially relative to the size parameter. F# C# member ExponentialUInt64 : x:uint64 * y:uint64 -> Range<uint64> public static Range<uint64> ExponentialUInt64(uint64 x, uint64 y) FromValue('T) Construct a range which represents a constant single value. F# C# member FromValue : 'T -> Range<'T> public static Range<T> FromValue(T value) LinearBoundedByte Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedByte : Range<byte> public static Range<byte> LinearBoundedByte() LinearBoundedDecimal Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedDecimal : Range<decimal> public static Range<decimal> LinearBoundedDecimal() LinearBoundedDouble Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedDouble : Range<double> public static Range<double> LinearBoundedDouble() LinearBoundedInt16 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedInt16 : Range<int16> public static Range<int16> LinearBoundedInt16() LinearBoundedInt32 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedInt32 : Range<int32> public static Range<int32> LinearBoundedInt32() LinearBoundedInt64 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedInt64 : Range<int64> public static Range<int64> LinearBoundedInt64() LinearBoundedSByte Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedSByte : Range<sbyte> public static Range<sbyte> LinearBoundedSByte() LinearBoundedSingle Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedSingle : Range<single> public static Range<single> LinearBoundedSingle() LinearBoundedUInt16 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedUInt16 : Range<uint16> public static Range<uint16> LinearBoundedUInt16() LinearBoundedUInt32 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedUInt32 : Range<uint32> public static Range<uint32> LinearBoundedUInt32() LinearBoundedUInt64 Construct a range which is scaled relative to the size parameter and uses the full range of a data type. F# C# member LinearBoundedUInt64 : Range<uint64> public static Range<uint64> LinearBoundedUInt64() LinearByte(byte, byte) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearByte : x:byte * y:byte -> Range<byte> public static Range<byte> LinearByte(byte x, byte y) LinearDecimal(decimal, decimal) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearDecimal : x:decimal * y:decimal -> Range<decimal> public static Range<decimal> LinearDecimal(decimal x, decimal y) LinearDouble(double, double) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearDouble : x:double * y:double -> Range<double> public static Range<double> LinearDouble(double x, double y) LinearFromByte(byte, byte, byte) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromByte : z:byte * x:byte * y:byte -> Range<byte> public static Range<byte> LinearFromByte(byte z, byte x, byte y) LinearFromDecimal(decimal, decimal, decimal) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromDecimal : z:decimal * x:decimal * y:decimal -> Range<decimal> public static Range<decimal> LinearFromDecimal(decimal z, decimal x, decimal y) LinearFromDouble(double, double, double) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromDouble : z:double * x:double * y:double -> Range<double> public static Range<double> LinearFromDouble(double z, double x, double y) LinearFromInt16(int16, int16, int16) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromInt16 : z:int16 * x:int16 * y:int16 -> Range<int16> public static Range<int16> LinearFromInt16(int16 z, int16 x, int16 y) LinearFromInt32(int32, int32, int32) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromInt32 : z:int32 * x:int32 * y:int32 -> Range<int32> public static Range<int32> LinearFromInt32(int32 z, int32 x, int32 y) LinearFromInt64(int64, int64, int64) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromInt64 : z:int64 * x:int64 * y:int64 -> Range<int64> public static Range<int64> LinearFromInt64(int64 z, int64 x, int64 y) LinearFromSByte(sbyte, sbyte, sbyte) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromSByte : z:sbyte * x:sbyte * y:sbyte -> Range<sbyte> public static Range<sbyte> LinearFromSByte(sbyte z, sbyte x, sbyte y) LinearFromSingle(single, single, single) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromSingle : z:single * x:single * y:single -> Range<single> public static Range<single> LinearFromSingle(single z, single x, single y) LinearFromUInt16(uint16, uint16, uint16) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromUInt16 : z:uint16 * x:uint16 * y:uint16 -> Range<uint16> public static Range<uint16> LinearFromUInt16(uint16 z, uint16 x, uint16 y) LinearFromUInt32(uint32, uint32, uint32) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromUInt32 : z:uint32 * x:uint32 * y:uint32 -> Range<uint32> public static Range<uint32> LinearFromUInt32(uint32 z, uint32 x, uint32 y) LinearFromUInt64(uint64, uint64, uint64) Construct a range which scales the bounds relative to the size parameter. F# C# member LinearFromUInt64 : z:uint64 * x:uint64 * y:uint64 -> Range<uint64> public static Range<uint64> LinearFromUInt64(uint64 z, uint64 x, uint64 y) LinearInt16(int16, int16) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearInt16 : x:int16 * y:int16 -> Range<int16> public static Range<int16> LinearInt16(int16 x, int16 y) LinearInt32(int32, int32) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearInt32 : x:int32 * y:int32 -> Range<int32> public static Range<int32> LinearInt32(int32 x, int32 y) LinearInt64(int64, int64) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearInt64 : x:int64 * y:int64 -> Range<int64> public static Range<int64> LinearInt64(int64 x, int64 y) LinearSByte(sbyte, sbyte) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearSByte : x:sbyte * y:sbyte -> Range<sbyte> public static Range<sbyte> LinearSByte(sbyte x, sbyte y) LinearSingle(single, single) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearSingle : x:single * y:single -> Range<single> public static Range<single> LinearSingle(single x, single y) LinearUInt16(uint16, uint16) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearUInt16 : x:uint16 * y:uint16 -> Range<uint16> public static Range<uint16> LinearUInt16(uint16 x, uint16 y) LinearUInt32(uint32, uint32) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearUInt32 : x:uint32 * y:uint32 -> Range<uint32> public static Range<uint32> LinearUInt32(uint32 x, uint32 y) LinearUInt64(uint64, uint64) Construct a range which scales the second bound relative to the size parameter. F# C# member LinearUInt64 : x:uint64 * y:uint64 -> Range<uint64> public static Range<uint64> LinearUInt64(uint64 x, uint64 y) Singleton('T) Construct a range which represents a constant single value. F# C# member Singleton : 'T -> Range<'T> public static Range<T> Singleton(T value)"
  },
  "api/Hedgehog.Linq.RangeExtensions.html": {
    "href": "api/Hedgehog.Linq.RangeExtensions.html",
    "title": "Class RangeExtensions | Hedgehog .NET",
    "summary": "Class RangeExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type RangeExtensions = member Bounds : range:Range<'T> * sz:Size -> 'T * 'T member LowerBound : range:Range<'T> * sz:Size -> 'T member Origin : Range<'T> -> 'T member Select : range:Range<'T> * mapper:Func<'T, 'TResult> -> Range<'TResult> member UpperBound : range:Range<'T> * sz:Size -> 'T public class RangeExtensions { public static (T, T) Bounds(this Range<T> range, Size sz) public static T LowerBound(this Range<T> range, Size sz) public static T Origin(this Range<T> range) public static Range<TResult> Select(this Range<T> range, Func<T, TResult> mapper) public static T UpperBound(this Range<T> range, Size sz) } Methods Bounds(Range, Size) Get the extents of a range, for a given size. F# C# member Bounds : range:Range<'T> * sz:Size -> 'T * 'T public static (T, T) Bounds(this Range<T> range, Size sz) LowerBound(Range, Size) Get the lower bound of a range for the given size. F# C# member LowerBound : range:Range<'T> * sz:Size -> 'T public static T LowerBound(this Range<T> range, Size sz) Origin(Range) Get the origin of a range. This might be the mid-point or the lower bound, depending on what the range represents. The 'bounds' of a range are scaled around this value when using the 'linear' family of combinators. When using a 'Range' to generate numbers, the shrinking function will shrink towards the origin. F# C# member Origin : Range<'T> -> 'T public static T Origin(this Range<T> range) Select(Range, Func) F# C# member Select : range:Range<'T> * mapper:Func<'T, 'TResult> -> Range<'TResult> public static Range<TResult> Select(this Range<T> range, Func<T, TResult> mapper) UpperBound(Range, Size) Get the upper bound of a range for the given size. F# C# member UpperBound : range:Range<'T> * sz:Size -> 'T public static T UpperBound(this Range<T> range, Size sz)"
  },
  "api/Hedgehog.Linq.ReportExtensions.html": {
    "href": "api/Hedgehog.Linq.ReportExtensions.html",
    "title": "Class ReportExtensions | Hedgehog .NET",
    "summary": "Class ReportExtensions Namespace Hedgehog.Linq Assembly Hedgehog.dll F# C# type ReportExtensions = member Render : Report -> string public class ReportExtensions { public static string Render(this Report report) } Methods Render(Report) F# C# member Render : Report -> string public static string Render(this Report report)"
  },
  "api/Hedgehog.MaxValue.html": {
    "href": "api/Hedgehog.MaxValue.html",
    "title": "Class MaxValue | Hedgehog .NET",
    "summary": "Class MaxValue Namespace Hedgehog Assembly Hedgehog.dll F# C# type MaxValue = member Invoke : ^a member MaxValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * arg1:MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 member MaxValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * 'g * arg1:MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 member MaxValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * arg1:MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 member MaxValue : arg0:'a * 'b * 'c * 'd * 'e * arg1:MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 member MaxValue : arg0:'a * 'b * 'c * 'd * arg1:MaxValue -> ^a0 * ^b1 * ^c2 * ^d3 member MaxValue : arg0:'a * 'b * 'c * arg1:MaxValue -> ^a0 * ^b1 * ^c2 member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 member MaxValue : arg0:TimeSpan * arg1:MaxValue -> TimeSpan member MaxValue : arg0:DateTimeOffset * arg1:MaxValue -> DateTimeOffset member MaxValue : arg0:DateTime * arg1:MaxValue -> DateTime member MaxValue : arg0:decimal * arg1:MaxValue -> decimal member MaxValue : arg0:double * arg1:MaxValue -> double member MaxValue : arg0:single * arg1:MaxValue -> single member MaxValue : arg0:int64 * arg1:MaxValue -> int64 member MaxValue : arg0:int32 * arg1:MaxValue -> int32 member MaxValue : arg0:int16 * arg1:MaxValue -> int16 member MaxValue : arg0:int8 * arg1:MaxValue -> int8 member MaxValue : arg0:uint64 * arg1:MaxValue -> uint64 member MaxValue : arg0:uint32 * arg1:MaxValue -> uint32 member MaxValue : arg0:uint16 * arg1:MaxValue -> uint16 member MaxValue : arg0:uint8 * arg1:MaxValue -> uint8 member MaxValue : arg0:char * arg1:MaxValue -> char member MaxValue : arg0:bool * arg1:MaxValue -> bool member MaxValue : ():unit * arg1:MaxValue -> unit public class MaxValue { public static ^a Invoke() public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 MaxValue((a, b, c, d, e, f, g, h) arg0, MaxValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 MaxValue((a, b, c, d, e, f, g) arg0, MaxValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 MaxValue((a, b, c, d, e, f) arg0, MaxValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 MaxValue((a, b, c, d, e) arg0, MaxValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 MaxValue((a, b, c, d) arg0, MaxValue arg1) public static ^a0 * ^b1 * ^c2 MaxValue((a, b, c) arg0, MaxValue arg1) public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) public static TimeSpan MaxValue(TimeSpan arg0, MaxValue arg1) public static DateTimeOffset MaxValue(DateTimeOffset arg0, MaxValue arg1) public static DateTime MaxValue(DateTime arg0, MaxValue arg1) public static decimal MaxValue(decimal arg0, MaxValue arg1) public static double MaxValue(double arg0, MaxValue arg1) public static single MaxValue(single arg0, MaxValue arg1) public static int64 MaxValue(int64 arg0, MaxValue arg1) public static int32 MaxValue(int32 arg0, MaxValue arg1) public static int16 MaxValue(int16 arg0, MaxValue arg1) public static int8 MaxValue(int8 arg0, MaxValue arg1) public static uint64 MaxValue(uint64 arg0, MaxValue arg1) public static uint32 MaxValue(uint32 arg0, MaxValue arg1) public static uint16 MaxValue(uint16 arg0, MaxValue arg1) public static uint8 MaxValue(uint8 arg0, MaxValue arg1) public static char MaxValue(char arg0, MaxValue arg1) public static bool MaxValue(bool arg0, MaxValue arg1) public static void MaxValue(void (), MaxValue arg1) } Methods Invoke F# C# member Invoke : ^a public static ^a Invoke() MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:'a * 'b * arg1:MaxValue -> ^a0 * ^b1 public static ^a0 * ^b1 MaxValue((a, b) arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:TimeSpan * arg1:MaxValue -> TimeSpan public static TimeSpan MaxValue(TimeSpan arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:DateTimeOffset * arg1:MaxValue -> DateTimeOffset public static DateTimeOffset MaxValue(DateTimeOffset arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:DateTime * arg1:MaxValue -> DateTime public static DateTime MaxValue(DateTime arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:decimal * arg1:MaxValue -> decimal public static decimal MaxValue(decimal arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:double * arg1:MaxValue -> double public static double MaxValue(double arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:single * arg1:MaxValue -> single public static single MaxValue(single arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:int64 * arg1:MaxValue -> int64 public static int64 MaxValue(int64 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:int32 * arg1:MaxValue -> int32 public static int32 MaxValue(int32 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:int16 * arg1:MaxValue -> int16 public static int16 MaxValue(int16 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:int8 * arg1:MaxValue -> int8 public static int8 MaxValue(int8 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:uint64 * arg1:MaxValue -> uint64 public static uint64 MaxValue(uint64 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:uint32 * arg1:MaxValue -> uint32 public static uint32 MaxValue(uint32 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:uint16 * arg1:MaxValue -> uint16 public static uint16 MaxValue(uint16 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:uint8 * arg1:MaxValue -> uint8 public static uint8 MaxValue(uint8 arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:char * arg1:MaxValue -> char public static char MaxValue(char arg0, MaxValue arg1) MaxValue F# C# member MaxValue : arg0:bool * arg1:MaxValue -> bool public static bool MaxValue(bool arg0, MaxValue arg1) MaxValue F# C# member MaxValue : ():unit * arg1:MaxValue -> unit public static void MaxValue(void (), MaxValue arg1)"
  },
  "api/Hedgehog.MinValue.html": {
    "href": "api/Hedgehog.MinValue.html",
    "title": "Class MinValue | Hedgehog .NET",
    "summary": "Class MinValue Namespace Hedgehog Assembly Hedgehog.dll F# C# type MinValue = member Invoke : ^a member MinValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * arg1:MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 member MinValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * 'g * arg1:MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 member MinValue : arg0:'a * 'b * 'c * 'd * 'e * 'f * arg1:MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 member MinValue : arg0:'a * 'b * 'c * 'd * 'e * arg1:MinValue -> ^a0 * ^b1 * ^c2 * ^d3 * ^e4 member MinValue : arg0:'a * 'b * 'c * 'd * arg1:MinValue -> ^a0 * ^b1 * ^c2 * ^d3 member MinValue : arg0:'a * 'b * 'c * arg1:MinValue -> ^a0 * ^b1 * ^c2 member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 member MinValue : arg0:TimeSpan * arg1:MinValue -> TimeSpan member MinValue : arg0:DateTimeOffset * arg1:MinValue -> DateTimeOffset member MinValue : arg0:DateTime * arg1:MinValue -> DateTime member MinValue : arg0:decimal * arg1:MinValue -> decimal member MinValue : arg0:double * arg1:MinValue -> double member MinValue : arg0:single * arg1:MinValue -> single member MinValue : arg0:int64 * arg1:MinValue -> int64 member MinValue : arg0:int32 * arg1:MinValue -> int32 member MinValue : arg0:int16 * arg1:MinValue -> int16 member MinValue : arg0:int8 * arg1:MinValue -> int8 member MinValue : arg0:uint64 * arg1:MinValue -> uint64 member MinValue : arg0:uint32 * arg1:MinValue -> uint32 member MinValue : arg0:uint16 * arg1:MinValue -> uint16 member MinValue : arg0:uint8 * arg1:MinValue -> uint8 member MinValue : arg0:char * arg1:MinValue -> char member MinValue : arg0:bool * arg1:MinValue -> bool member MinValue : ():unit * arg1:MinValue -> unit public class MinValue { public static ^a Invoke() public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 * ^h7 MinValue((a, b, c, d, e, f, g, h) arg0, MinValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 * ^g6 MinValue((a, b, c, d, e, f, g) arg0, MinValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 * ^f5 MinValue((a, b, c, d, e, f) arg0, MinValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 * ^e4 MinValue((a, b, c, d, e) arg0, MinValue arg1) public static ^a0 * ^b1 * ^c2 * ^d3 MinValue((a, b, c, d) arg0, MinValue arg1) public static ^a0 * ^b1 * ^c2 MinValue((a, b, c) arg0, MinValue arg1) public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) public static TimeSpan MinValue(TimeSpan arg0, MinValue arg1) public static DateTimeOffset MinValue(DateTimeOffset arg0, MinValue arg1) public static DateTime MinValue(DateTime arg0, MinValue arg1) public static decimal MinValue(decimal arg0, MinValue arg1) public static double MinValue(double arg0, MinValue arg1) public static single MinValue(single arg0, MinValue arg1) public static int64 MinValue(int64 arg0, MinValue arg1) public static int32 MinValue(int32 arg0, MinValue arg1) public static int16 MinValue(int16 arg0, MinValue arg1) public static int8 MinValue(int8 arg0, MinValue arg1) public static uint64 MinValue(uint64 arg0, MinValue arg1) public static uint32 MinValue(uint32 arg0, MinValue arg1) public static uint16 MinValue(uint16 arg0, MinValue arg1) public static uint8 MinValue(uint8 arg0, MinValue arg1) public static char MinValue(char arg0, MinValue arg1) public static bool MinValue(bool arg0, MinValue arg1) public static void MinValue(void (), MinValue arg1) } Methods Invoke F# C# member Invoke : ^a public static ^a Invoke() MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:'a * 'b * arg1:MinValue -> ^a0 * ^b1 public static ^a0 * ^b1 MinValue((a, b) arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:TimeSpan * arg1:MinValue -> TimeSpan public static TimeSpan MinValue(TimeSpan arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:DateTimeOffset * arg1:MinValue -> DateTimeOffset public static DateTimeOffset MinValue(DateTimeOffset arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:DateTime * arg1:MinValue -> DateTime public static DateTime MinValue(DateTime arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:decimal * arg1:MinValue -> decimal public static decimal MinValue(decimal arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:double * arg1:MinValue -> double public static double MinValue(double arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:single * arg1:MinValue -> single public static single MinValue(single arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:int64 * arg1:MinValue -> int64 public static int64 MinValue(int64 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:int32 * arg1:MinValue -> int32 public static int32 MinValue(int32 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:int16 * arg1:MinValue -> int16 public static int16 MinValue(int16 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:int8 * arg1:MinValue -> int8 public static int8 MinValue(int8 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:uint64 * arg1:MinValue -> uint64 public static uint64 MinValue(uint64 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:uint32 * arg1:MinValue -> uint32 public static uint32 MinValue(uint32 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:uint16 * arg1:MinValue -> uint16 public static uint16 MinValue(uint16 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:uint8 * arg1:MinValue -> uint8 public static uint8 MinValue(uint8 arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:char * arg1:MinValue -> char public static char MinValue(char arg0, MinValue arg1) MinValue F# C# member MinValue : arg0:bool * arg1:MinValue -> bool public static bool MinValue(bool arg0, MinValue arg1) MinValue F# C# member MinValue : ():unit * arg1:MinValue -> unit public static void MinValue(void (), MinValue arg1)"
  },
  "api/Hedgehog.Numeric.html": {
    "href": "api/Hedgehog.Numeric.html",
    "title": "Class Numeric | Hedgehog .NET",
    "summary": "Class Numeric Namespace Hedgehog Assembly Hedgehog.dll F# C# type Numeric = member fromBigInt : bigint -> ^a member maxValue : unit -> ^a member minValue : unit -> ^a member toBigInt : ^a -> bigint public class Numeric { public static ^a fromBigInt(bigint x) public static ^a maxValue(void ()) public static ^a minValue(void ()) public static bigint toBigInt(^a x) } Methods minValue Returns the smallest possible value. F# C# member minValue : unit -> ^a public static ^a minValue(void ()) maxValue Returns the largest possible value. F# C# member maxValue : unit -> ^a public static ^a maxValue(void ()) fromBigInt Converts from a BigInt to the inferred destination type. F# C# member fromBigInt : bigint -> ^a public static ^a fromBigInt(bigint x) toBigInt Converts to a BigInt. F# C# member toBigInt : ^a -> bigint public static bigint toBigInt(^a x)"
  },
  "api/Hedgehog.Outcome.html": {
    "href": "api/Hedgehog.Outcome.html",
    "title": "Class Outcome | Hedgehog .NET",
    "summary": "Class Outcome Namespace Hedgehog Assembly Hedgehog.dll F# C# type Outcome = member filter : 'a -> bool -> Outcome<'a> -> Outcome<'a> member isFailure : Outcome<'a> -> bool member map : 'a -> 'b -> Outcome<'a> -> Outcome<'b> public class Outcome { public static Outcome<a> filter(a -> bool f, Outcome<a> result) public static bool isFailure(Outcome<a> result) public static Outcome<b> map(a -> b f, Outcome<a> result) } Methods map F# C# member map : 'a -> 'b -> Outcome<'a> -> Outcome<'b> public static Outcome<b> map(a -> b f, Outcome<a> result) filter F# C# member filter : 'a -> bool -> Outcome<'a> -> Outcome<'a> public static Outcome<a> filter(a -> bool f, Outcome<a> result) isFailure F# C# member isFailure : Outcome<'a> -> bool public static bool isFailure(Outcome<a> result)"
  },
  "api/Hedgehog.Outcome_a_.html": {
    "href": "api/Hedgehog.Outcome_a_.html",
    "title": "Class Outcome<'a> | Hedgehog .NET",
    "summary": "Class Outcome<'a> Namespace Hedgehog Assembly Hedgehog.dll F# C# type Outcome<'a> public class Outcome<a>"
  },
  "api/Hedgehog.PropertyArgs.html": {
    "href": "api/Hedgehog.PropertyArgs.html",
    "title": "Class PropertyArgs | Hedgehog .NET",
    "summary": "Class PropertyArgs Namespace Hedgehog Assembly Hedgehog.dll F# C# type PropertyArgs = member init : unit -> PropertyArgs public class PropertyArgs { public static PropertyArgs init(void ()) } Methods init F# C# member init : unit -> PropertyArgs public static PropertyArgs init(void ())"
  },
  "api/Hedgehog.PropertyConfig.html": {
    "href": "api/Hedgehog.PropertyConfig.html",
    "title": "Class PropertyConfig | Hedgehog .NET",
    "summary": "Class PropertyConfig Namespace Hedgehog Assembly Hedgehog.dll F# C# type PropertyConfig = member defaults : IPropertyConfig member withShrinks : int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig -> IPropertyConfig member withTests : int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig -> IPropertyConfig member withoutShrinks : IPropertyConfig -> IPropertyConfig public class PropertyConfig { public static IPropertyConfig defaults() public static IPropertyConfig withShrinks(int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit, IPropertyConfig config) public static IPropertyConfig withTests(int<MeasureProduct<tests, MeasureOne>> testLimit, IPropertyConfig config) public static IPropertyConfig withoutShrinks(IPropertyConfig config) } Methods defaults The default configuration for a property test. F# C# member defaults : IPropertyConfig public static IPropertyConfig defaults() withShrinks Set the number of times a property is allowed to shrink before the test runner gives up and displays the counterexample. F# C# member withShrinks : int<MeasureProduct<shrinks, MeasureOne>> -> IPropertyConfig -> IPropertyConfig public static IPropertyConfig withShrinks(int<MeasureProduct<shrinks, MeasureOne>> shrinkLimit, IPropertyConfig config) withoutShrinks Restores the default shrinking behavior. F# C# member withoutShrinks : IPropertyConfig -> IPropertyConfig public static IPropertyConfig withoutShrinks(IPropertyConfig config) withTests Set the number of times a property should be executed before it is considered successful. F# C# member withTests : int<MeasureProduct<tests, MeasureOne>> -> IPropertyConfig -> IPropertyConfig public static IPropertyConfig withTests(int<MeasureProduct<tests, MeasureOne>> testLimit, IPropertyConfig config)"
  },
  "api/Hedgehog.Property_a_.html": {
    "href": "api/Hedgehog.Property_a_.html",
    "title": "Class Property<'a> | Hedgehog .NET",
    "summary": "Class Property<'a> Namespace Hedgehog Assembly Hedgehog.dll F# C# type Property<'a> public class Property<a>"
  },
  "api/Hedgehog.Random_a_.html": {
    "href": "api/Hedgehog.Random_a_.html",
    "title": "Class Random<'a> | Hedgehog .NET",
    "summary": "Class Random<'a> Namespace Hedgehog Assembly Hedgehog.dll A generator for random values of type 'a F# C# type Random<'a> public class Random<a>"
  },
  "api/Hedgehog.Range_a_.html": {
    "href": "api/Hedgehog.Range_a_.html",
    "title": "Class Range<'a> | Hedgehog .NET",
    "summary": "Class Range<'a> Namespace Hedgehog Assembly Hedgehog.dll A range describes the bounds of a number to generate, which may or may not be dependent on a 'Size'. The constructor takes an origin between the lower and upper bound, and a function from 'Size' to bounds. As the size goes towards 0, the values go towards the origin. F# C# type Range<'a> public class Range<a>"
  },
  "api/Hedgehog.RecheckData.html": {
    "href": "api/Hedgehog.RecheckData.html",
    "title": "Class RecheckData | Hedgehog .NET",
    "summary": "Class RecheckData Namespace Hedgehog Assembly Hedgehog.dll F# C# type RecheckData = member deserialize : string -> RecheckData member serialize : RecheckData -> string public class RecheckData { public static RecheckData deserialize(string s) public static string serialize(RecheckData data) } Methods serialize F# C# member serialize : RecheckData -> string public static string serialize(RecheckData data) deserialize F# C# member deserialize : string -> RecheckData public static RecheckData deserialize(string s)"
  },
  "api/Hedgehog.RecheckInfo.html": {
    "href": "api/Hedgehog.RecheckInfo.html",
    "title": "Class RecheckInfo | Hedgehog .NET",
    "summary": "Class RecheckInfo Namespace Hedgehog Assembly Hedgehog.dll F# C# type RecheckInfo public class RecheckInfo"
  },
  "api/Hedgehog.Report.html": {
    "href": "api/Hedgehog.Report.html",
    "title": "Class Report | Hedgehog .NET",
    "summary": "Class Report Namespace Hedgehog Assembly Hedgehog.dll F# C# type Report = member render : Report -> string member tryRaise : Report -> unit public class Report { public static string render(Report report) public static void tryRaise(Report report) } Methods render F# C# member render : Report -> string public static string render(Report report) tryRaise F# C# member tryRaise : Report -> unit public static void tryRaise(Report report)"
  },
  "api/Hedgehog.Seed.html": {
    "href": "api/Hedgehog.Seed.html",
    "title": "Class Seed | Hedgehog .NET",
    "summary": "Class Seed Namespace Hedgehog Assembly Hedgehog.dll Splittable random number generator. F# C# type Seed = member from : uint64 -> Seed member nextBigInt : bigint -> bigint -> Seed -> bigint * Seed member nextDouble : double -> double -> Seed -> double * Seed member nextInt32 : int32 -> int32 -> Seed -> int32 * Seed member nextInt64 : int64 -> int64 -> Seed -> int64 * Seed member nextUInt64 : Seed -> uint64 * Seed member random : unit -> Seed member range : int64 * int64 member split : Seed -> Seed * Seed public class Seed { public static Seed from(uint64 x) public static (bigint, Seed) nextBigInt(bigint lo, bigint hi, Seed seed) public static (double, Seed) nextDouble(double lo, double hi, Seed seed) public static (int32, Seed) nextInt32(int32 lo, int32 hi, Seed seed) public static (int64, Seed) nextInt64(int64 lo, int64 hi, Seed seed) public static (uint64, Seed) nextUInt64(Seed seed) public static Seed random(void ()) public static (int64, int64) range() public static (Seed, Seed) split(Seed seed) } Methods from Create a new 'Seed'. F# C# member from : uint64 -> Seed public static Seed from(uint64 x) random Create a new random 'Seed'. F# C# member random : unit -> Seed public static Seed random(void ()) range The possible range of values returned from 'next'. F# C# member range : int64 * int64 public static (int64, int64) range() nextUInt64 Generates a random 'System.UInt64'. F# C# member nextUInt64 : Seed -> uint64 * Seed public static (uint64, Seed) nextUInt64(Seed seed) nextBigInt Generates a random bigint in the specified range. F# C# member nextBigInt : bigint -> bigint -> Seed -> bigint * Seed public static (bigint, Seed) nextBigInt(bigint lo, bigint hi, Seed seed) nextInt32 Generates a random int32 in the specified range. F# C# member nextInt32 : int32 -> int32 -> Seed -> int32 * Seed public static (int32, Seed) nextInt32(int32 lo, int32 hi, Seed seed) nextInt64 Generates a random int64 in the specified range. F# C# member nextInt64 : int64 -> int64 -> Seed -> int64 * Seed public static (int64, Seed) nextInt64(int64 lo, int64 hi, Seed seed) nextDouble Generates a random double in the specified range. F# C# member nextDouble : double -> double -> Seed -> double * Seed public static (double, Seed) nextDouble(double lo, double hi, Seed seed) split Splits a 'Seed' in to two. F# C# member split : Seed -> Seed * Seed public static (Seed, Seed) split(Seed seed)"
  },
  "api/Hedgehog.Shrink.html": {
    "href": "api/Hedgehog.Shrink.html",
    "title": "Class Shrink | Hedgehog .NET",
    "summary": "Class Shrink Namespace Hedgehog Assembly Hedgehog.dll F# C# type Shrink = member createTree : ^a -> ^a -> Tree<^a> member elems : 'a -> 'a seq -> List<'a> -> List<'a> seq member halves : ^a -> ^a seq member list : List<'a> -> List<'a> seq member removes : int -> List<'a> -> List<'a> seq member sequence : List<Tree<'a>> -> List<Tree<'a>> seq -> List<Tree<'a>> -> Tree<List<'a>> member sequenceElems : List<Tree<'a>> -> Tree<List<'a>> member sequenceList : List<Tree<'a>> -> Tree<List<'a>> member towards : ^a -> ^a -> ^a seq member towardsDouble : double -> double -> double seq public class Shrink { public static Tree<^a> createTree(^a destination, ^a x) public static List<a>IEnumerable elems(a -> aIEnumerable shrink, List<a> xs) public static ^aIEnumerable halves(^a n) public static List<a>IEnumerable list(List<a> xs) public static List<a>IEnumerable removes(int k0, List<a> xs0) public static Tree<List<a>> sequence(List<Tree<a>> -> List<Tree<a>>IEnumerable merge, List<Tree<a>> xs) public static Tree<List<a>> sequenceElems(List<Tree<a>> xs0) public static Tree<List<a>> sequenceList(List<Tree<a>> xs0) public static ^aIEnumerable towards(^a destination, ^a x) public static doubleIEnumerable towardsDouble(double destination, double x) } Methods removes Produce all permutations of removing 'k' elements from a list. F# C# member removes : int -> List<'a> -> List<'a> seq public static List<a>IEnumerable removes(int k0, List<a> xs0) halves Produce a list containing the progressive halving of an integral. F# C# member halves : ^a -> ^a seq public static ^aIEnumerable halves(^a n) list Shrink a list by edging towards the empty list. Note we always try the empty list first, as that is the optimal shrink. F# C# member list : List<'a> -> List<'a> seq public static List<a>IEnumerable list(List<a> xs) elems Shrink each of the elements in input list using the supplied shrinking function. Iterative implementation to avoid stack overflow on large lists. F# C# member elems : 'a -> 'a seq -> List<'a> -> List<'a> seq public static List<a>IEnumerable elems(a -> aIEnumerable shrink, List<a> xs) sequence Turn a list of trees in to a tree of lists, using the supplied function to merge shrinking options. F# C# member sequence : List<Tree<'a>> -> List<Tree<'a>> seq -> List<Tree<'a>> -> Tree<List<'a>> public static Tree<List<a>> sequence(List<Tree<a>> -> List<Tree<a>>IEnumerable merge, List<Tree<a>> xs) sequenceList Turn a list of trees in to a tree of lists, opting to shrink both the list itself and the elements in the list during traversal. F# C# member sequenceList : List<Tree<'a>> -> Tree<List<'a>> public static Tree<List<a>> sequenceList(List<Tree<a>> xs0) sequenceElems Turn a list of trees in to a tree of lists, opting to shrink only the elements of the list (i.e. the size of the list will always be the same). F# C# member sequenceElems : List<Tree<'a>> -> Tree<List<'a>> public static Tree<List<a>> sequenceElems(List<Tree<a>> xs0) towards Shrink an integral number by edging towards a destination. F# C# member towards : ^a -> ^a -> ^a seq public static ^aIEnumerable towards(^a destination, ^a x) towardsDouble Shrink a floating-point number by edging towards a destination. Note we always try the destination first, as that is the optimal shrink. F# C# member towardsDouble : double -> double -> double seq public static doubleIEnumerable towardsDouble(double destination, double x) createTree F# C# member createTree : ^a -> ^a -> Tree<^a> public static Tree<^a> createTree(^a destination, ^a x)"
  },
  "api/Hedgehog.ShrinkOutcome.html": {
    "href": "api/Hedgehog.ShrinkOutcome.html",
    "title": "Class ShrinkOutcome | Hedgehog .NET",
    "summary": "Class ShrinkOutcome Namespace Hedgehog Assembly Hedgehog.dll F# C# type ShrinkOutcome public class ShrinkOutcome"
  },
  "api/Hedgehog.Size.html": {
    "href": "api/Hedgehog.Size.html",
    "title": "Class Size | Hedgehog .NET",
    "summary": "Class Size Namespace Hedgehog Assembly Hedgehog.dll Tests are parameterized by the Size of the randomly-generated data, the meaning of which depends on the particular generator used. F# C# type Size public class Size"
  },
  "api/Hedgehog.Stateful.ActionCommand_TSystem, TState, TInput_.html": {
    "href": "api/Hedgehog.Stateful.ActionCommand_TSystem, TState, TInput_.html",
    "title": "Class ActionCommand<'TSystem, 'TState, 'TInput> | Hedgehog .NET",
    "summary": "Class ActionCommand<'TSystem, 'TState, 'TInput> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Base class for commands that perform side-effects without returning meaningful values. Examples: closing a connection, clearing a cache, deleting a file. Simpler than Command because no output variable is needed. Execute returns a Task to support both synchronous and asynchronous operations. The SUT is passed as a typed parameter to Execute and Ensure. F# C# type ActionCommand<'TSystem, 'TState, 'TInput> = abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput -> bool abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task abstract member Generate : 'TState -> Gen<'TInput> abstract member Name : string abstract member Precondition : 'TState -> bool abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract member Update : state:'TState * input:'TInput -> 'TState public class ActionCommand<TSystem, TState, TInput> { abstract bool Ensure(Env env, TState oldState, TState newState, TInput input) abstract Task Execute(TSystem sut, Env env, TState state, TInput input) abstract Gen<TInput> Generate(TState state) abstract string Name() abstract bool Precondition(TState state) abstract bool Require(Env env, TState state, TInput input) abstract TState Update(TState state, TInput input) } Methods Ensure Verify the action's postcondition after execution. Compare the model state transitions (s0 -> s1) with the input. Should only verify based on states and input - not inspect the SUT directly. No output parameter since actions don't produce values. Returns true if postcondition is satisfied, false otherwise. May throw exceptions which will be caught and treated as failures. Parameters: env: The environment containing resolved values from previous commands. oldState: The model state before the action executed. newState: The model state after the action executed. input: The input value for this action. F# C# abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput -> bool abstract bool Ensure(Env env, TState oldState, TState newState, TInput input) Execute Execute the action against the real system without returning a value. For synchronous operations, use Task.CompletedTask. The sut parameter is the typed System Under Test. The state parameter is the current model state. The env contains resolved values from previous commands. Parameters: sut: The system under test. env: The environment containing resolved values from previous commands. state: The current model state. input: The input value for this action. F# C# abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task abstract Task Execute(TSystem sut, Env env, TState state, TInput input) Generate Generate random input for this action given the current model state. This is only called when Precondition returns true. Parameters: state: The current model state. F# C# abstract member Generate : 'TState -> Gen<'TInput> abstract Gen<TInput> Generate(TState state) Precondition Structural precondition that determines if this action can be generated/executed in the given state. Return true if the action can run, false to skip generation. This is automatically used by both generation and Require (unless Require is overridden). Parameters: state: The current model state. F# C# abstract member Precondition : 'TState -> bool abstract bool Precondition(TState state) Require Check if the action can be executed in the given state with concrete values. Return false if the action should not be executed in this state. The env parameter allows resolving symbolic variables from the state. By default, returns true. Override only when you need to check concrete values with env. Note: Precondition is always checked separately, so you don't need to duplicate those checks here. Parameters: env: The environment containing resolved values from previous commands. state: The current model state. input: The concrete input value for this action. F# C# abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract bool Require(Env env, TState state, TInput input) Update Update the model state after the action executes. No output variable since actions don't produce values to reference later. Parameters: state: The current model state. input: The input value for this action. F# C# abstract member Update : state:'TState * input:'TInput -> 'TState abstract TState Update(TState state, TInput input) Name Human-readable name of the action (e.g., \"Close\", \"Clear\", \"Delete\") F# C# abstract member Name : string abstract string Name()"
  },
  "api/Hedgehog.Stateful.ActionGen_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ActionGen_TSystem, TState_.html",
    "title": "Class ActionGen<'TSystem, 'TState> | Hedgehog .NET",
    "summary": "Class ActionGen<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Existential wrapper to allow heterogeneous command lists. This erases the input/output types so different commands can be in the same list. F# C# type ActionGen<'TSystem, 'TState> public class ActionGen<TSystem, TState>"
  },
  "api/Hedgehog.Stateful.Command_TSystem, TState, TInput, TOutput_.html": {
    "href": "api/Hedgehog.Stateful.Command_TSystem, TState, TInput, TOutput_.html",
    "title": "Class Command<'TSystem, 'TState, 'TInput, 'TOutput> | Hedgehog .NET",
    "summary": "Class Command<'TSystem, 'TState, 'TInput, 'TOutput> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Base class for commands that perform stateful operations and return values. Commands are the building blocks of state machine tests - they represent operations on a system under test (SUT) that can be generated, executed, and verified. The SUT is passed as a typed parameter to Execute and Ensure. Execute returns a Task to support both synchronous and asynchronous operations. F# C# type Command<'TSystem, 'TState, 'TInput, 'TOutput> = abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput * output:'TOutput -> bool abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task<'TOutput> abstract member Generate : 'TState -> Gen<'TInput> abstract member Name : string abstract member Precondition : 'TState -> bool abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract member Update : state:'TState * input:'TInput * output:Var<'TOutput> -> 'TState public class Command<TSystem, TState, TInput, TOutput> { abstract bool Ensure(Env env, TState oldState, TState newState, TInput input, TOutput output) abstract Task<TOutput> Execute(TSystem sut, Env env, TState state, TInput input) abstract Gen<TInput> Generate(TState state) abstract string Name() abstract bool Precondition(TState state) abstract bool Require(Env env, TState state, TInput input) abstract TState Update(TState state, TInput input, Var<TOutput> output) } Methods Ensure Verify the command's postcondition after execution. Compare the model state transitions (s0 -> s1) with the actual output. Should only verify based on states, input, and output - not inspect the SUT directly. Returns true if postcondition is satisfied, false otherwise. May throw exceptions which will be caught and treated as failures. Parameters: env: The environment containing resolved values from previous commands. oldState: The model state before the command executed. newState: The model state after the command executed. input: The input value for this command. output: The actual output value produced by the command. F# C# abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput * output:'TOutput -> bool abstract bool Ensure(Env env, TState oldState, TState newState, TInput input, TOutput output) Execute Execute the command against the real system, returning a Task. For synchronous operations, use Task.FromResult(value). The sut parameter is the typed System Under Test. The state parameter is the current model state. The env contains resolved values from previous commands. Parameters: sut: The system under test. env: The environment containing resolved values from previous commands. state: The current model state. input: The input value for this command. F# C# abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task<'TOutput> abstract Task<TOutput> Execute(TSystem sut, Env env, TState state, TInput input) Generate Generate random input for this command given the current model state. This is only called when Precondition returns true. Parameters: state: The current model state. F# C# abstract member Generate : 'TState -> Gen<'TInput> abstract Gen<TInput> Generate(TState state) Precondition Structural precondition that determines if this command can be generated/executed in the given state. Return true if the command can run, false to skip generation. This is automatically used by both generation and Require (unless Require is overridden). Parameters: state: The current model state. F# C# abstract member Precondition : 'TState -> bool abstract bool Precondition(TState state) Require Check if the command can be executed in the given state with concrete values. Return false if the command should not be executed in this state. The env parameter allows resolving symbolic variables from the state. By default, returns true. Override only when you need to check concrete values with env. Note: Precondition is always checked separately, so you don't need to duplicate those checks here. Parameters: env: The environment containing resolved values from previous commands. state: The current model state. input: The concrete input value for this command. F# C# abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract bool Require(Env env, TState state, TInput input) Update Update the model state after the command executes. The Var represents the symbolic output that can be referenced by future commands. Parameters: state: The current model state. input: The input value for this command. output: The symbolic output variable that can be referenced by future commands. F# C# abstract member Update : state:'TState * input:'TInput * output:Var<'TOutput> -> 'TState abstract TState Update(TState state, TInput input, Var<TOutput> output) Name Human-readable name of the command (e.g., \"Push\", \"Pop\") F# C# abstract member Name : string abstract string Name()"
  },
  "api/Hedgehog.Stateful.Env.html": {
    "href": "api/Hedgehog.Stateful.Env.html",
    "title": "Class Env | Hedgehog .NET",
    "summary": "Class Env Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Environment mapping symbolic variable names to concrete values. The SUT is passed separately to Execute, not stored in Env. F# C# type Env public class Env"
  },
  "api/Hedgehog.Stateful.FSharp.Var.html": {
    "href": "api/Hedgehog.Stateful.FSharp.Var.html",
    "title": "Class Var | Hedgehog .NET",
    "summary": "Class Var Namespace Hedgehog.Stateful.FSharp Assembly Hedgehog.Stateful.dll F# C# type Var = member map : 'T -> 'U -> Var<'T> -> Var<'U> member resolve : Env -> Var<'T> -> 'T member resolveOr : 'T -> Env -> Var<'T> -> 'T member tryResolve : Var<'T> -> Env -> Result<'T, string> public class Var { public static Var<U> map(T -> U f, Var<T> v) public static T resolve(Env env, Var<T> v) public static T resolveOr(T fallback, Env env, Var<T> v) public static Result<T, string> tryResolve(Var<T> v, Env env) } Methods resolve Resolve a variable using its default value if not found in the environment. Parameters: env: The environment to resolve the variable from. v: The variable to resolve. F# C# member resolve : Env -> Var<'T> -> 'T public static T resolve(Env env, Var<T> v) resolveOr Resolve a variable with an explicit fallback value, overriding the variable's default. Parameters: fallback: The fallback value to use if the variable is not found. env: The environment to resolve the variable from. v: The variable to resolve. F# C# member resolveOr : 'T -> Env -> Var<'T> -> 'T public static T resolveOr(T fallback, Env env, Var<T> v) tryResolve Resolve a variable, returning Error if not found in the environment or if resolution fails. Parameters: v: The variable to resolve. env: The environment to resolve the variable from. F# C# member tryResolve : Var<'T> -> Env -> Result<'T, string> public static Result<T, string> tryResolve(Var<T> v, Env env) map Map a function over a variable, creating a new variable that projects a value from the original variable's output. This allows extracting fields from structured command outputs. Parameters: f: The projection function to apply. v: The variable to map over. F# C# member map : 'T -> 'U -> Var<'T> -> Var<'U> public static Var<U> map(T -> U f, Var<T> v)"
  },
  "api/Hedgehog.Stateful.ICommand_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ICommand_TSystem, TState_.html",
    "title": "Class ICommand<'TSystem, 'TState> | Hedgehog .NET",
    "summary": "Class ICommand<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Interface for types that helps with converting commands to executable actions. This allows seamless mixing of different commands and action commands. F# C# type ICommand<'TSystem, 'TState> = abstract member ToActionGen : ActionGen<'TSystem, 'TState> public class ICommand<TSystem, TState> { abstract ActionGen<TSystem, TState> ToActionGen() } Methods ToActionGen F# C# abstract member ToActionGen : ActionGen<'TSystem, 'TState> abstract ActionGen<TSystem, TState> ToActionGen()"
  },
  "api/Hedgehog.Stateful.Linq.NoValue.html": {
    "href": "api/Hedgehog.Stateful.Linq.NoValue.html",
    "title": "Class NoValue | Hedgehog .NET",
    "summary": "Class NoValue Namespace Hedgehog.Stateful.Linq Assembly Hedgehog.Stateful.dll Represents the absence of value, that can be used for commands that don't require input parameters. Similar to F#'s unit type, this is a zero-sized struct with a single instance. F# C# type NoValue = member Value : NoValue public class NoValue { public static NoValue Value() } Methods Value F# C# member Value : NoValue public static NoValue Value()"
  },
  "api/Hedgehog.Stateful.Linq.VarExtensions.html": {
    "href": "api/Hedgehog.Stateful.Linq.VarExtensions.html",
    "title": "Class VarExtensions | Hedgehog .NET",
    "summary": "Class VarExtensions Namespace Hedgehog.Stateful.Linq Assembly Hedgehog.Stateful.dll Extension methods for working with Var<T> in C#. F# C# type VarExtensions = member Select : var:Var<'T> * selector:Func<'T, 'U> -> Var<'U> public class VarExtensions { public static Var<U> Select(this Var<T> var, Func<T, U> selector) } Methods Select(Var, Func) Projects the value of a variable using a selector function. This allows extracting fields from structured command outputs. Parameters: var: The variable to project from. selector: A function to apply to the variable's value. F# C# member Select : var:Var<'T> * selector:Func<'T, 'U> -> Var<'U> public static Var<U> Select(this Var<T> var, Func<T, U> selector)"
  },
  "api/Hedgehog.Stateful.Name.html": {
    "href": "api/Hedgehog.Stateful.Name.html",
    "title": "Class Name | Hedgehog .NET",
    "summary": "Class Name Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Unique identifier for a symbolic variable. F# C# type Name public class Name"
  },
  "api/Hedgehog.Stateful.Parallel.html": {
    "href": "api/Hedgehog.Stateful.Parallel.html",
    "title": "Class Parallel | Hedgehog .NET",
    "summary": "Class Parallel Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Parallel public class Parallel"
  },
  "api/Hedgehog.Stateful.ParallelSpecification_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ParallelSpecification_TSystem, TState_.html",
    "title": "Class ParallelSpecification<'TSystem, 'TState> | Hedgehog .NET",
    "summary": "Class ParallelSpecification<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Abstract base class for parallel state machine tests. Tests concurrent execution by running two branches in parallel after a sequential prefix. The SUT (System Under Test) is created externally and passed to Check/ToProperty methods. F# C# type ParallelSpecification<'TSystem, 'TState> = abstract member BranchRange : Range<int> abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract member Commands : ICommand<'TSystem, 'TState> array abstract member InitialState : 'TState abstract member PrefixRange : Range<int> abstract member SetupCommands : ICommand<'TSystem, 'TState> array member ToProperty : 'TSystem -> Property<unit> member ToPropertyWith : unit -> 'TSystem -> Property<unit> public class ParallelSpecification<TSystem, TState> { abstract Range<int> BranchRange() abstract ICommand<TSystem, TState> array CleanupCommands() abstract ICommand<TSystem, TState> array Commands() abstract TState InitialState() abstract Range<int> PrefixRange() abstract ICommand<TSystem, TState> array SetupCommands() public static Property<void> ToProperty(TSystem sut) public static Property<void> ToPropertyWith(void -> TSystem createSut) } Methods ToProperty Convert this specification to a property that can be checked. Parameters: sut: The system under test (SUT) instance to use for the test run. F# C# member ToProperty : 'TSystem -> Property<unit> public static Property<void> ToProperty(TSystem sut) ToPropertyWith Convert this specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. This is the recommended approach to ensure test isolation. Parameters: createSut: A function that creates a new SUT instance for each test run. F# C# member ToPropertyWith : unit -> 'TSystem -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut) InitialState The initial model state. F# C# abstract member InitialState : 'TState abstract TState InitialState() PrefixRange Range of prefix sequence lengths to generate (sequential actions before parallel execution). F# C# abstract member PrefixRange : Range<int> abstract Range<int> PrefixRange() BranchRange Range of branch sequence lengths to generate (parallel actions in each branch). F# C# abstract member BranchRange : Range<int> abstract Range<int> BranchRange() SetupCommands Setup commands that execute before the prefix and parallel branches. These commands are generated (parameters can shrink) but always execute in the order specified. Setup commands cannot be shrunk away from the action sequence. Default is an empty list (no setup). F# C# abstract member SetupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array SetupCommands() CleanupCommands Cleanup commands that execute after the parallel branches complete. These commands are generated (parameters can shrink) but always execute in the order specified. Cleanup commands cannot be shrunk away and are guaranteed to run even if tests fail. Cleanup is generated using the state after prefix (before parallel execution). Default is an empty list (no cleanup). F# C# abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array CleanupCommands() Commands Commands that operate on the SUT during the test sequence. The SUT is passed as a typed parameter to Execute methods. F# C# abstract member Commands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array Commands()"
  },
  "api/Hedgehog.Stateful.Sequential.html": {
    "href": "api/Hedgehog.Stateful.Sequential.html",
    "title": "Class Sequential | Hedgehog .NET",
    "summary": "Class Sequential Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Sequential public class Sequential"
  },
  "api/Hedgehog.Stateful.SequentialSpecification_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.SequentialSpecification_TSystem, TState_.html",
    "title": "Class SequentialSpecification<'TSystem, 'TState> | Hedgehog .NET",
    "summary": "Class SequentialSpecification<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Abstract base class for sequential state machine tests. The SUT (System Under Test) is created externally and passed to Check/ToProperty methods. Setup and cleanup are modeled as command lists that execute before/after test actions. F# C# type SequentialSpecification<'TSystem, 'TState> = abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract member Commands : ICommand<'TSystem, 'TState> array abstract member InitialState : 'TState abstract member Range : Range<int> abstract member SetupCommands : ICommand<'TSystem, 'TState> array member ToProperty : 'TSystem -> Property<unit> member ToPropertyWith : unit -> 'TSystem -> Property<unit> public class SequentialSpecification<TSystem, TState> { abstract ICommand<TSystem, TState> array CleanupCommands() abstract ICommand<TSystem, TState> array Commands() abstract TState InitialState() abstract Range<int> Range() abstract ICommand<TSystem, TState> array SetupCommands() public static Property<void> ToProperty(TSystem sut) public static Property<void> ToPropertyWith(void -> TSystem createSut) } Methods ToProperty Convert this specification to a property that can be checked. Parameters: sut: The system under test (SUT) instance to use for the test run. F# C# member ToProperty : 'TSystem -> Property<unit> public static Property<void> ToProperty(TSystem sut) ToPropertyWith Convert this specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. This is the recommended approach to ensure test isolation. Parameters: createSut: A function that creates a new SUT instance for each test run. F# C# member ToPropertyWith : unit -> 'TSystem -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut) Range Range of action sequence lengths to generate. F# C# abstract member Range : Range<int> abstract Range<int> Range() InitialState The initial model state. F# C# abstract member InitialState : 'TState abstract TState InitialState() SetupCommands Setup commands that execute before the test sequence. These commands are generated (parameters can shrink) but always execute in the order specified. Setup commands cannot be shrunk away from the action sequence. Default is an empty list (no setup). F# C# abstract member SetupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array SetupCommands() CleanupCommands Cleanup commands that execute after the test sequence. These commands are generated (parameters can shrink) but always execute in the order specified. Cleanup commands cannot be shrunk away and are guaranteed to run even if tests fail. Cleanup is generated using the final state after setup and test actions complete. Default is an empty list (no cleanup). F# C# abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array CleanupCommands() Commands Commands that operate on the SUT during the test sequence. The SUT is passed as a typed parameter to Execute methods. F# C# abstract member Commands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array Commands()"
  },
  "api/Hedgehog.Stateful.Var.html": {
    "href": "api/Hedgehog.Stateful.Var.html",
    "title": "Class Var | Hedgehog .NET",
    "summary": "Class Var Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Var = member symbolic : 'T -> Var<'T> public class Var { public static Var<T> symbolic(T defaultValue) } Methods symbolic Initialise a symbolic (unbound) variable with a default value for the initial state. A symbolic variable is not yet bound to a generated value and is used to represent a placeholder in the model before generation or binding occurs. Parameters: defaultValue: The default value to assign to the variable. F# C# member symbolic : 'T -> Var<'T> public static Var<T> symbolic(T defaultValue)"
  },
  "api/Hedgehog.Stateful.Var_T_.html": {
    "href": "api/Hedgehog.Stateful.Var_T_.html",
    "title": "Class Var<'T> | Hedgehog .NET",
    "summary": "Class Var<'T> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Symbolic variable referencing a command's output. Symbolic variables are placeholders that let us chain commands by using one command's result as input to another, even before execution. A symbolic variable is not yet bound to a generated value and is used to represent a value in the model before binding occurs. F# C# type Var<'T> = member Resolve : Env -> 'T member ResolveOr : env:Env * fallback:'T -> 'T member TryResolve : env:Env * value:byref<'T> -> bool public class Var<T> { public static T Resolve(Env env) public static T ResolveOr(Env env, T fallback) public static bool TryResolve(Env env, byref<T> value) } Methods Resolve Resolve the variable using its default if not found in the environment. Parameters: env: The environment to resolve the variable from. F# C# member Resolve : Env -> 'T public static T Resolve(Env env) ResolveOr Resolve the variable with an explicit fallback value, overriding the variable's default. Parameters: env: The environment to resolve the variable from. fallback: The fallback value to use if the variable is not found. F# C# member ResolveOr : env:Env * fallback:'T -> 'T public static T ResolveOr(Env env, T fallback) TryResolve Attempts to resolve a variable from the environment. Parameters: env: The environment to resolve the variable from. value: When this method returns, contains the resolved value if successful; otherwise, the default value for the type. F# C# member TryResolve : env:Env * value:byref<'T> -> bool public static bool TryResolve(Env env, byref<T> value)"
  },
  "api/Hedgehog.Status.html": {
    "href": "api/Hedgehog.Status.html",
    "title": "Class Status | Hedgehog .NET",
    "summary": "Class Status Namespace Hedgehog Assembly Hedgehog.dll F# C# type Status public class Status"
  },
  "api/Hedgehog.ToBigInt.html": {
    "href": "api/Hedgehog.ToBigInt.html",
    "title": "Class ToBigInt | Hedgehog .NET",
    "summary": "Class ToBigInt Namespace Hedgehog Assembly Hedgehog.dll F# C# type ToBigInt = member Invoke : ^Integral -> bigint member ToBigInt : unativeint -> bigint member ToBigInt : nativeint -> bigint member ToBigInt : decimal -> bigint member ToBigInt : double -> bigint member ToBigInt : single -> bigint member ToBigInt : int64 -> bigint member ToBigInt : int32 -> bigint member ToBigInt : int16 -> bigint member ToBigInt : int8 -> bigint member ToBigInt : uint64 -> bigint member ToBigInt : uint32 -> bigint member ToBigInt : uint16 -> bigint member ToBigInt : uint8 -> bigint member ToBigInt : bigint -> bigint public class ToBigInt { public static bigint Invoke(^Integral x) public static bigint ToBigInt(unativeint x) public static bigint ToBigInt(nativeint x) public static bigint ToBigInt(decimal x) public static bigint ToBigInt(double x) public static bigint ToBigInt(single x) public static bigint ToBigInt(int64 x) public static bigint ToBigInt(int32 x) public static bigint ToBigInt(int16 x) public static bigint ToBigInt(int8 x) public static bigint ToBigInt(uint64 x) public static bigint ToBigInt(uint32 x) public static bigint ToBigInt(uint16 x) public static bigint ToBigInt(uint8 x) public static bigint ToBigInt(bigint x) } Methods Invoke F# C# member Invoke : ^Integral -> bigint public static bigint Invoke(^Integral x) ToBigInt F# C# member ToBigInt : unativeint -> bigint public static bigint ToBigInt(unativeint x) ToBigInt F# C# member ToBigInt : nativeint -> bigint public static bigint ToBigInt(nativeint x) ToBigInt F# C# member ToBigInt : decimal -> bigint public static bigint ToBigInt(decimal x) ToBigInt F# C# member ToBigInt : double -> bigint public static bigint ToBigInt(double x) ToBigInt F# C# member ToBigInt : single -> bigint public static bigint ToBigInt(single x) ToBigInt F# C# member ToBigInt : int64 -> bigint public static bigint ToBigInt(int64 x) ToBigInt F# C# member ToBigInt : int32 -> bigint public static bigint ToBigInt(int32 x) ToBigInt F# C# member ToBigInt : int16 -> bigint public static bigint ToBigInt(int16 x) ToBigInt F# C# member ToBigInt : int8 -> bigint public static bigint ToBigInt(int8 x) ToBigInt F# C# member ToBigInt : uint64 -> bigint public static bigint ToBigInt(uint64 x) ToBigInt F# C# member ToBigInt : uint32 -> bigint public static bigint ToBigInt(uint32 x) ToBigInt F# C# member ToBigInt : uint16 -> bigint public static bigint ToBigInt(uint16 x) ToBigInt F# C# member ToBigInt : uint8 -> bigint public static bigint ToBigInt(uint8 x) ToBigInt F# C# member ToBigInt : bigint -> bigint public static bigint ToBigInt(bigint x)"
  },
  "api/Hedgehog.Tree.html": {
    "href": "api/Hedgehog.Tree.html",
    "title": "Class Tree | Hedgehog .NET",
    "summary": "Class Tree Namespace Hedgehog Assembly Hedgehog.dll F# C# type Tree = member addChild : Tree<'a> -> Tree<'a> -> Tree<'a> member addChildValue : 'a -> Tree<'a> -> Tree<'a> member apply : Tree<'a> -> Tree<('a -> 'b)> -> Tree<'b> member bind : 'a -> Tree<'b> -> Tree<'a> -> Tree<'b> member cata : 'a -> 'b seq -> 'b -> Tree<'a> -> 'b member create : 'a -> Tree<'a> seq -> Tree<'a> member depth : Tree<'a> -> int member duplicate : Tree<'a> -> Tree<Tree<'a>> member expand : 'a -> 'a seq -> Tree<'a> -> Tree<'a> member filter : 'a -> bool -> Tree<'a> -> Tree<'a> member filterForest : 'a -> bool -> Tree<'a> seq -> Tree<'a> seq member fold : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> -> 'b member foldForest : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> seq -> 'x member join : Tree<Tree<'a>> -> Tree<'a> member map : 'a -> 'b -> Tree<'a> -> Tree<'b> member mapWithSubtrees : 'a -> Tree<'b> seq -> 'b -> Tree<'a> -> Tree<'b> member outcome : Tree<'a> -> 'a member render : Tree<string> -> string member renderList : Tree<string> -> List<string> member shrinks : Tree<'a> -> Tree<'a> seq member singleton : 'a -> Tree<'a> member toSeq : Tree<'a> -> 'a seq member unfold : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> member unfoldForest : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> seq public class Tree { public static Tree<a> addChild(Tree<a> child, Tree<a> parent) public static Tree<a> addChildValue(a a, Tree<a> tree) public static Tree<b> apply(Tree<a> ta, Tree<(a -> b)> tf) public static Tree<b> bind(a -> Tree<b> f, Tree<a> tree) public static b cata(a -> bIEnumerable -> b f, Tree<a> arg1) public static Tree<a> create(a a, Tree<a>IEnumerable children) public static int depth(Tree<a> tree) public static Tree<Tree<a>> duplicate(Tree<a> x) public static Tree<a> expand(a -> aIEnumerable f, Tree<a> arg1) public static Tree<a> filter(a -> bool f, Tree<a> arg1) public static Tree<a>IEnumerable filterForest(a -> bool f, Tree<a>IEnumerable xs) public static b fold(a -> x -> b f, bIEnumerable -> x g, Tree<a> arg2) public static x foldForest(a -> x -> b f, bIEnumerable -> x g, Tree<a>IEnumerable xs) public static Tree<a> join(Tree<Tree<a>> xss) public static Tree<b> map(a -> b f, Tree<a> tree) public static Tree<b> mapWithSubtrees(a -> Tree<b>IEnumerable -> b f, Tree<a> tree) public static a outcome(Tree<a> arg0) public static string render(Tree<string> t) public static List<string> renderList(Tree<string> arg0) public static Tree<a>IEnumerable shrinks(Tree<a> arg0) public static Tree<a> singleton(a x) public static aIEnumerable toSeq(Tree<a> tree) public static Tree<a> unfold(b -> a f, b -> bIEnumerable g, b x) public static Tree<a>IEnumerable unfoldForest(b -> a f, b -> bIEnumerable g, b x) } Methods outcome The generated outcome. F# C# member outcome : Tree<'a> -> 'a public static a outcome(Tree<a> arg0) shrinks All the possible shrinks of this outcome. This should be ordered smallest to largest as if property still fails with the first shrink in the list then we will commit to that path and none of the others will be tried (i.e. there is no backtracking). F# C# member shrinks : Tree<'a> -> Tree<'a> seq public static Tree<a>IEnumerable shrinks(Tree<a> arg0) create F# C# member create : 'a -> Tree<'a> seq -> Tree<'a> public static Tree<a> create(a a, Tree<a>IEnumerable children) singleton Create a tree with a single outcome and no shrinks. F# C# member singleton : 'a -> Tree<'a> public static Tree<a> singleton(a x) addChild F# C# member addChild : Tree<'a> -> Tree<'a> -> Tree<'a> public static Tree<a> addChild(Tree<a> child, Tree<a> parent) addChildValue F# C# member addChildValue : 'a -> Tree<'a> -> Tree<'a> public static Tree<a> addChildValue(a a, Tree<a> tree) cata F# C# member cata : 'a -> 'b seq -> 'b -> Tree<'a> -> 'b public static b cata(a -> bIEnumerable -> b f, Tree<a> arg1) depth F# C# member depth : Tree<'a> -> int public static int depth(Tree<a> tree) toSeq F# C# member toSeq : Tree<'a> -> 'a seq public static aIEnumerable toSeq(Tree<a> tree) map Map over a tree. F# C# member map : 'a -> 'b -> Tree<'a> -> Tree<'b> public static Tree<b> map(a -> b f, Tree<a> tree) mapWithSubtrees F# C# member mapWithSubtrees : 'a -> Tree<'b> seq -> 'b -> Tree<'a> -> Tree<'b> public static Tree<b> mapWithSubtrees(a -> Tree<b>IEnumerable -> b f, Tree<a> tree) apply F# C# member apply : Tree<'a> -> Tree<('a -> 'b)> -> Tree<'b> public static Tree<b> apply(Tree<a> ta, Tree<(a -> b)> tf) bind F# C# member bind : 'a -> Tree<'b> -> Tree<'a> -> Tree<'b> public static Tree<b> bind(a -> Tree<b> f, Tree<a> tree) join F# C# member join : Tree<Tree<'a>> -> Tree<'a> public static Tree<a> join(Tree<Tree<a>> xss) duplicate Turns a tree, in to a tree of trees. Useful for testing Hedgehog itself as it allows you to observe the shrinks for a value inside a property, while still allowing the property to shrink to a minimal counterexample. F# C# member duplicate : Tree<'a> -> Tree<Tree<'a>> public static Tree<Tree<a>> duplicate(Tree<a> x) fold Fold over a tree. F# C# member fold : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> -> 'b public static b fold(a -> x -> b f, bIEnumerable -> x g, Tree<a> arg2) foldForest Fold over a list of trees. F# C# member foldForest : 'a -> 'x -> 'b -> 'b seq -> 'x -> Tree<'a> seq -> 'x public static x foldForest(a -> x -> b f, bIEnumerable -> x g, Tree<a>IEnumerable xs) unfold Build a tree from an unfolding function and a seed value. F# C# member unfold : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> public static Tree<a> unfold(b -> a f, b -> bIEnumerable g, b x) unfoldForest Build a list of trees from an unfolding function and a seed value. F# C# member unfoldForest : 'b -> 'a -> 'b -> 'b seq -> 'b -> Tree<'a> seq public static Tree<a>IEnumerable unfoldForest(b -> a f, b -> bIEnumerable g, b x) expand Apply an additional unfolding function to an existing tree. The root outcome remains intact, only the shrinks are affected, this applies recursively, so shrinks can only ever be added using this function. If you want to replace the shrinks altogether, try: Tree.unfold f (outcome oldTree) F# C# member expand : 'a -> 'a seq -> Tree<'a> -> Tree<'a> public static Tree<a> expand(a -> aIEnumerable f, Tree<a> arg1) filter Recursively discard any shrinks whose outcome does not pass the predicate. Note that the root outcome can never be discarded. F# C# member filter : 'a -> bool -> Tree<'a> -> Tree<'a> public static Tree<a> filter(a -> bool f, Tree<a> arg1) filterForest Recursively discard any trees whose outcome does not pass the predicate. F# C# member filterForest : 'a -> bool -> Tree<'a> seq -> Tree<'a> seq public static Tree<a>IEnumerable filterForest(a -> bool f, Tree<a>IEnumerable xs) renderList F# C# member renderList : Tree<string> -> List<string> public static List<string> renderList(Tree<string> arg0) render F# C# member render : Tree<string> -> string public static string render(Tree<string> t)"
  },
  "api/Hedgehog.Tree_a_.html": {
    "href": "api/Hedgehog.Tree_a_.html",
    "title": "Class Tree<'a> | Hedgehog .NET",
    "summary": "Class Tree<'a> Namespace Hedgehog Assembly Hedgehog.dll A rose tree which represents a random generated outcome, and all the ways in which it can be made smaller. F# C# type Tree<'a> public class Tree<a>"
  },
  "api/Hedgehog.Xunit.AlphaNumStringAttribute.html": {
    "href": "api/Hedgehog.Xunit.AlphaNumStringAttribute.html",
    "title": "Class AlphaNumStringAttribute | Hedgehog .NET",
    "summary": "Class AlphaNumStringAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string containing alphanumeric characters. F# C# type AlphaNumStringAttribute public class AlphaNumStringAttribute"
  },
  "api/Hedgehog.Xunit.DateTimeAttribute.html": {
    "href": "api/Hedgehog.Xunit.DateTimeAttribute.html",
    "title": "Class DateTimeAttribute | Hedgehog .NET",
    "summary": "Class DateTimeAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a DateTime value. F# C# type DateTimeAttribute public class DateTimeAttribute"
  },
  "api/Hedgehog.Xunit.DateTimeOffsetAttribute.html": {
    "href": "api/Hedgehog.Xunit.DateTimeOffsetAttribute.html",
    "title": "Class DateTimeOffsetAttribute | Hedgehog .NET",
    "summary": "Class DateTimeOffsetAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a DateTimeOffset value. F# C# type DateTimeOffsetAttribute public class DateTimeOffsetAttribute"
  },
  "api/Hedgehog.Xunit.DomainNameAttribute.html": {
    "href": "api/Hedgehog.Xunit.DomainNameAttribute.html",
    "title": "Class DomainNameAttribute | Hedgehog .NET",
    "summary": "Class DomainNameAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a valid domain name. F# C# type DomainNameAttribute public class DomainNameAttribute"
  },
  "api/Hedgehog.Xunit.EmailAttribute.html": {
    "href": "api/Hedgehog.Xunit.EmailAttribute.html",
    "title": "Class EmailAttribute | Hedgehog .NET",
    "summary": "Class EmailAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a valid email address. F# C# type EmailAttribute public class EmailAttribute"
  },
  "api/Hedgehog.Xunit.EvenAttribute.html": {
    "href": "api/Hedgehog.Xunit.EvenAttribute.html",
    "title": "Class EvenAttribute | Hedgehog .NET",
    "summary": "Class EvenAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an even integer. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type EvenAttribute public class EvenAttribute"
  },
  "api/Hedgehog.Xunit.GenAttribute_a_.html": {
    "href": "api/Hedgehog.Xunit.GenAttribute_a_.html",
    "title": "Class GenAttribute<'a> | Hedgehog .NET",
    "summary": "Class GenAttribute<'a> Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Set a Generator for a parameter of a test annotated with `Property` Example usage: type ConstantInt(i: int) = inherit ParameterGeneraterBaseType() override _.Generator = Gen.constant i [] let is always 2 ([] i) = Assert.StrictEqual(2, i) F# C# type GenAttribute<'a> = member Box : Gen<obj> abstract member Generator : Gen<'a> public class GenAttribute<a> { public static Gen<obj> Box() abstract Gen<a> Generator() } Methods Box F# C# member Box : Gen<obj> public static Gen<obj> Box() Generator F# C# abstract member Generator : Gen<'a> abstract Gen<a> Generator()"
  },
  "api/Hedgehog.Xunit.IdentifierAttribute.html": {
    "href": "api/Hedgehog.Xunit.IdentifierAttribute.html",
    "title": "Class IdentifierAttribute | Hedgehog .NET",
    "summary": "Class IdentifierAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string that is a valid identifier. F# C# type IdentifierAttribute public class IdentifierAttribute"
  },
  "api/Hedgehog.Xunit.IntAttribute.html": {
    "href": "api/Hedgehog.Xunit.IntAttribute.html",
    "title": "Class IntAttribute | Hedgehog .NET",
    "summary": "Class IntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an integer within a specified range. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type IntAttribute public class IntAttribute"
  },
  "api/Hedgehog.Xunit.Ipv4AddressAttribute.html": {
    "href": "api/Hedgehog.Xunit.Ipv4AddressAttribute.html",
    "title": "Class Ipv4AddressAttribute | Hedgehog .NET",
    "summary": "Class Ipv4AddressAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an IP address (IPv4). F# C# type Ipv4AddressAttribute public class Ipv4AddressAttribute"
  },
  "api/Hedgehog.Xunit.Ipv6AddressAttribute.html": {
    "href": "api/Hedgehog.Xunit.Ipv6AddressAttribute.html",
    "title": "Class Ipv6AddressAttribute | Hedgehog .NET",
    "summary": "Class Ipv6AddressAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an IPv6 address. F# C# type Ipv6AddressAttribute public class Ipv6AddressAttribute"
  },
  "api/Hedgehog.Xunit.KebabCaseAttribute.html": {
    "href": "api/Hedgehog.Xunit.KebabCaseAttribute.html",
    "title": "Class KebabCaseAttribute | Hedgehog .NET",
    "summary": "Class KebabCaseAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string in kebab-case. F# C# type KebabCaseAttribute public class KebabCaseAttribute"
  },
  "api/Hedgehog.Xunit.LatinNameAttribute.html": {
    "href": "api/Hedgehog.Xunit.LatinNameAttribute.html",
    "title": "Class LatinNameAttribute | Hedgehog .NET",
    "summary": "Class LatinNameAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string representing a Latin name. F# C# type LatinNameAttribute public class LatinNameAttribute"
  },
  "api/Hedgehog.Xunit.NonNegativeIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.NonNegativeIntAttribute.html",
    "title": "Class NonNegativeIntAttribute | Hedgehog .NET",
    "summary": "Class NonNegativeIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a non-negative integer. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type NonNegativeIntAttribute public class NonNegativeIntAttribute"
  },
  "api/Hedgehog.Xunit.NonZeroIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.NonZeroIntAttribute.html",
    "title": "Class NonZeroIntAttribute | Hedgehog .NET",
    "summary": "Class NonZeroIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a non-zero integer. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type NonZeroIntAttribute public class NonZeroIntAttribute"
  },
  "api/Hedgehog.Xunit.OddAttribute.html": {
    "href": "api/Hedgehog.Xunit.OddAttribute.html",
    "title": "Class OddAttribute | Hedgehog .NET",
    "summary": "Class OddAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates an odd integer. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type OddAttribute public class OddAttribute"
  },
  "api/Hedgehog.Xunit.PositiveIntAttribute.html": {
    "href": "api/Hedgehog.Xunit.PositiveIntAttribute.html",
    "title": "Class PositiveIntAttribute | Hedgehog .NET",
    "summary": "Class PositiveIntAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a positive integer. Range strategy: exponential (>1000), linear (>100), or constant (100). F# C# type PositiveIntAttribute public class PositiveIntAttribute"
  },
  "api/Hedgehog.Xunit.PropertiesAttribute.html": {
    "href": "api/Hedgehog.Xunit.PropertiesAttribute.html",
    "title": "Class PropertiesAttribute | Hedgehog .NET",
    "summary": "Class PropertiesAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Set a default AutoGenConfig or for all [ ] attributed methods in this class/module F# C# type PropertiesAttribute = member AutoGenConfig : unit member AutoGenConfigArgs : unit member Shrinks : unit member Size : unit member Tests : unit public class PropertiesAttribute { public static void AutoGenConfig() public static void AutoGenConfigArgs() public static void Shrinks() public static void Size() public static void Tests() } Methods Shrinks F# C# member Shrinks : unit public static void Shrinks() AutoGenConfigArgs F# C# member AutoGenConfigArgs : unit public static void AutoGenConfigArgs() Tests F# C# member Tests : unit public static void Tests() Size F# C# member Size : unit public static void Size() AutoGenConfig F# C# member AutoGenConfig : unit public static void AutoGenConfig()"
  },
  "api/Hedgehog.Xunit.PropertyAttribute.html": {
    "href": "api/Hedgehog.Xunit.PropertyAttribute.html",
    "title": "Class PropertyAttribute | Hedgehog .NET",
    "summary": "Class PropertyAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates arguments using GenX.auto (or autoWith if you provide an AutoGenConfig), then runs Property.check F# C# type PropertyAttribute = member AutoGenConfig : unit member AutoGenConfigArgs : unit member Shrinks : unit member Size : unit member Tests : unit public class PropertyAttribute { public static void AutoGenConfig() public static void AutoGenConfigArgs() public static void Shrinks() public static void Size() public static void Tests() } Methods Shrinks F# C# member Shrinks : unit public static void Shrinks() AutoGenConfigArgs F# C# member AutoGenConfigArgs : unit public static void AutoGenConfigArgs() Tests F# C# member Tests : unit public static void Tests() Size F# C# member Size : unit public static void Size() AutoGenConfig F# C# member AutoGenConfig : unit public static void AutoGenConfig()"
  },
  "api/Hedgehog.Xunit.PropertyFailedException.html": {
    "href": "api/Hedgehog.Xunit.PropertyFailedException.html",
    "title": "Class PropertyFailedException | Hedgehog .NET",
    "summary": "Class PropertyFailedException Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Exception for property test failures that produces clean output F# C# type PropertyFailedException public class PropertyFailedException"
  },
  "api/Hedgehog.Xunit.RecheckAttribute.html": {
    "href": "api/Hedgehog.Xunit.RecheckAttribute.html",
    "title": "Class RecheckAttribute | Hedgehog .NET",
    "summary": "Class RecheckAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Runs Property.reportRecheck F# C# type RecheckAttribute public class RecheckAttribute"
  },
  "api/Hedgehog.Xunit.SnakeCaseAttribute.html": {
    "href": "api/Hedgehog.Xunit.SnakeCaseAttribute.html",
    "title": "Class SnakeCaseAttribute | Hedgehog .NET",
    "summary": "Class SnakeCaseAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string in snake_case. F# C# type SnakeCaseAttribute public class SnakeCaseAttribute"
  },
  "api/Hedgehog.Xunit.UnicodeStringAttribute.html": {
    "href": "api/Hedgehog.Xunit.UnicodeStringAttribute.html",
    "title": "Class UnicodeStringAttribute | Hedgehog .NET",
    "summary": "Class UnicodeStringAttribute Namespace Hedgehog.Xunit Assembly Hedgehog.Xunit.dll Generates a string containing unicode characters. F# C# type UnicodeStringAttribute public class UnicodeStringAttribute"
  },
  "api/Hedgehog.discards.html": {
    "href": "api/Hedgehog.discards.html",
    "title": "Class discards | Hedgehog .NET",
    "summary": "Class discards Namespace Hedgehog Assembly Hedgehog.dll F# C# type discards public class discards"
  },
  "api/Hedgehog.shrinks.html": {
    "href": "api/Hedgehog.shrinks.html",
    "title": "Class shrinks | Hedgehog .NET",
    "summary": "Class shrinks Namespace Hedgehog Assembly Hedgehog.dll F# C# type shrinks public class shrinks"
  },
  "api/Hedgehog.tests.html": {
    "href": "api/Hedgehog.tests.html",
    "title": "Class tests | Hedgehog .NET",
    "summary": "Class tests Namespace Hedgehog Assembly Hedgehog.dll F# C# type tests public class tests"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Hedgehog .NET",
    "summary": "API Documentation For F# Users To use Hedgehog in F#, import the following namespaces: open Hedgehog open Hedgehog.FSharp Hedgehog.FSharp.Gen Hedgehog.FSharp.Property Hedgehog.FSharp.Range For C# Users To use Hedgehog in C#, import the following namespaces: using Hedgehog; using Hedgehog.Linq; Hedgehog.Linq.Gen Hedgehog.Linq.Property Hedgehog.Linq.Range Core Types The most important types in Hedgehog are: Gen<T> - A generator for random values of type T. Generators can be composed and transformed to create complex data generators. Range<T> - Defines the range from which values are generated and controls shrinking behavior during property testing. Property<T> - Represents a property to be tested. Properties combine generators with assertions to verify that certain conditions hold for all generated test cases."
  },
  "articles/async-properties.html": {
    "href": "articles/async-properties.html",
    "title": "Async Properties | Hedgehog .NET",
    "summary": "Async Properties Hedgehog supports testing asynchronous code through async properties. This guide explains how async support works internally and what to expect when writing async property tests. Basic Usage You can bind async computations and tasks directly in property computation expressions: F# C# open Hedgehog open Hedgehog.FSharp property { let! x = Gen.int32 (Range.linear 1 100) let! result = async { do! Async.Sleep 10 return x * 2 } return result > 0 } |> Property.checkAsync |> Async.RunSynchronously using Hedgehog; using Hedgehog.Linq; var prop = from x in Gen.Int32(Range.LinearInt32(1, 100)).ForAll() from result in Task.Run(async () => { await Task.Delay(10); return x * 2; }) select result > 0; await prop.CheckAsync(); How Async Support Works Understanding the internal mechanics helps you write efficient async property tests. Two Phases: Generation and Execution Property testing in Hedgehog happens in two distinct phases: Generation Phase: Building the tree of test values with shrinks Execution Phase: Running the property test with generated values Synchronous Generation, Async Execution The key design decision is: Generator trees are built synchronously - This ensures proper seed threading for reproducible random generation Property evaluation happens asynchronously - When you use checkAsync/reportAsync, the actual test execution is fully async without blocking When Blocking Occurs Blocking can occur during the generation phase when you use the result of an async operation to determine what generator to use next: F# C# // This WILL block during generation: property { let! x = Gen.int32 (Range.linear 1 100) let! asyncValue = async { return 42 } // Creates async value let! y = Gen.int32 (Range.linear asyncValue 100) // BLOCKS to get asyncValue return y > 0 } // This WILL block during generation: var prop = from x in Gen.Int32(Range.LinearInt32(1, 100)).ForAll() from asyncValue in Task.FromResult(42) from y in Gen.Int32(Range.LinearInt32(asyncValue, 100)).ForAll() // BLOCKS! select y > 0; Why? Because to create the generator Gen.int32 (Range.linear asyncValue 100), Hedgehog needs to know what asyncValue is. The only way to get it is to run the async computation and get the value. When Blocking Does NOT Occur If your async operations are only used for the final assertion or return value, no blocking occurs during generation: F# C# // This will NOT block during generation: property { let! x = Gen.int32 (Range.linear 1 100) let! y = Gen.string (Range.linear 1 10) Gen.alpha let! result = async { // Async work here do! Async.Sleep 10 return x + String.length y } return result > 0 // Just checking the result } |> Property.checkAsync // This will NOT block during generation: var prop = from x in Gen.Int32(Range.LinearInt32(1, 100)).ForAll() from y in Gen.String(Range.LinearInt32(1, 10), Gen.Alpha).ForAll() from result in Task.Run(async () => { await Task.Delay(10); return x + y.Length; }) select result > 0; // Just checking the result await prop.CheckAsync(); When you run this with checkAsync or CheckAsync, the entire async chain executes without blocking threads. Note Cancellation tokens are not currently supported in Hedgehog's async APIs. The checkAsync and reportAsync methods do not accept CancellationToken parameters, and async operations within properties cannot be cancelled externally. Best Practices  Do: Use async for test logic F# C# property { let! userId = Gen.int32 (Range.linear 1 1000) let! userName = Gen.string (Range.linear 1 50) Gen.alpha // Async operations in test body - no blocking let! user = async { let! created = createUserAsync userId userName let! fetched = getUserAsync userId return fetched } return user.Name = userName } |> Property.checkAsync var prop = from userId in Gen.Int32(Range.LinearInt32(1, 1000)).ForAll() from userName in Gen.String(Range.LinearInt32(1, 50), Gen.Alpha).ForAll() from user in Task.Run(async () => { // Async operations in test body - no blocking var created = await CreateUserAsync(userId, userName); var fetched = await GetUserAsync(userId); return fetched; }) select user.Name == userName; await prop.CheckAsync();  Do: Generate all values first, then run async F# C# property { // Generate all test data synchronously let! count = Gen.int32 (Range.linear 1 100) let! items = Gen.list (Range.singleton count) Gen.alpha // Then run async operations let! result = async { do! processItemsAsync items return! verifyAsync count } return result } |> Property.checkAsync var prop = from count in Gen.Int32(Range.LinearInt32(1, 100)).ForAll() from items in Gen.Alpha.List(Range.Singleton(count)).ForAll() from result in Task.Run(async () => { // Then run async operations await ProcessItemsAsync(items); return await VerifyAsync(count); }) select result; await prop.CheckAsync();  Avoid: Using async results to determine generators F# C# // This blocks during generation! property { let! config = async { return! loadConfigAsync() } let! value = Gen.int32 (Range.linear 1 config.MaxValue) // Blocks! // ... } Instead, generate the range synchronously: // Better approach property { let! maxValue = Gen.int32 (Range.linear 1 1000) // Generate synchronously let! value = Gen.int32 (Range.linear 1 maxValue) let! result = async { let! config = loadConfigAsync() return value <= config.MaxValue } return result } |> Property.checkAsync // This blocks during generation! var badProp = from config in LoadConfigAsync() from value in Gen.Int32(Range.LinearInt32(1, config.MaxValue)).ForAll() // Blocks! select true; Instead, generate the range synchronously: // Better approach var goodProp = from maxValue in Gen.Int32(Range.LinearInt32(1, 1000)).ForAll() // Generate synchronously from value in Gen.Int32(Range.LinearInt32(1, maxValue)).ForAll() from result in Task.Run(async () => { var config = await LoadConfigAsync(); return value <= config.MaxValue; }) select result; await goodProp.CheckAsync(); Synchronous vs Asynchronous Execution Hedgehog provides both synchronous and asynchronous APIs: Synchronous API (blocks on async properties) F# C# property { ... } |> Property.check // Blocks if property contains async property { ... } |> Property.checkBool // Blocks if property contains async prop.Check(); // Blocks if property contains async boolProp.CheckBool(); // Blocks if property contains async Use this for: Pure synchronous properties When blocking is acceptable Simple test scenarios Asynchronous API (non-blocking) F# C# property { ... } |> Property.checkAsync // Non-blocking F# Async |> Async.RunSynchronously property { ... } |> Property.checkTask // Non-blocking C# Task |> Async.AwaitTask |> Async.RunSynchronously await prop.CheckAsync(); // Non-blocking returns F# Async // Or if you have the Task-returning version: await prop.CheckAsync(); // Non-blocking C# Task Use this for: Properties containing async/task operations Integration tests with I/O When you need non-blocking execution Summary Generation is synchronous: Building the tree of test cases with proper seed threading Execution can be async: Use checkAsync/reportAsync for non-blocking test execution Interleaving matters: Using async results to determine what to generate next will block during generation Pattern: Generate values first (sync), then test them (async) for best performance"
  },
  "articles/auto-generation.html": {
    "href": "articles/auto-generation.html",
    "title": "Auto-Generation | Hedgehog .NET",
    "summary": "Auto-Generation Warning Auto-generation is not available when using Fable. You must write custom generators manually for Fable projects. Hedgehog can automatically generate test data for your types without manually writing generators. This feature works with F# records, discriminated unions, tuples, and C# classes. Basic Usage F# C# For simple F# types, use Gen.auto<'T>: open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int Email: string } type Status = | Active | Inactive | Pending of reason: string property { let! user = Gen.auto<User> let! status = Gen.auto<Status> return user.Age >= 0 && user.Name.Length > 0 } |> Property.check Auto-generation works with C# classes, records, and structs: using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age, string Email); public enum Status { Active, Inactive, Pending } var property = from user in Gen.Auto<User>().ForAll() from status in Gen.Auto<Status>().ForAll() select user.Age >= 0 && user.Name.Length > 0; property.Check(); Supported Types Auto-generation works with: Primitives: int, string, bool, decimal, DateTime, etc. Records: F# records and C# record types Discriminated Unions: F# union types Tuples: Both F# and C# tuples Collections: List, Array, Set, Map, Dictionary, IEnumerable Options: Option<'T>, ValueOption<'T>, Nullable<'T> Results: Result<'T, 'TError> Classes: C# classes with constructors or mutable properties Nested Types: Any combination of the above Customizing Auto-Generation Using AutoGenConfig When you need to customize how types are generated, use Gen.autoWith with an AutoGenConfig: F# C# open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int Email: string } // Create a custom config let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 5 20) Gen.alpha) // Custom string generator |> AutoGenConfig.addGenerator (Gen.int32 (Range.linear 18 100)) // Ages between 18-100 property { let! user = Gen.autoWith<User> config return user.Age >= 18 && user.Name.Length >= 5 } |> Property.check using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age, string Email); // Create a custom config var config = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(5, 20), Gen.Alpha)) // Custom string generator .AddGenerator(Gen.Int32(Range.LinearInt32(18, 100))); // Ages between 18-100 var property = from user in Gen.AutoWith<User>(config).ForAll() select user.Age >= 18 && user.Name.Length >= 5; property.Check(); Registering Custom Generators For more control, create a custom generator class with static methods that match the names of your types. Hedgehog will automatically discover and use these generators when you register the class. How Generator Classes Work When you call AutoGenConfig.addGenerators<T>, Hedgehog: Scans the class T for public static methods Finds methods that return Gen<T> (for any type T) Uses these methods when generating values of type T Method Requirements: Must be public static Must return Gen<T> where T is the type you want to generate Can optionally accept parameters of type IAutoGenContext or Gen<TValue> for generic types Examples: A method returning Gen<Email> will be used to generate Email values A method returning Gen<User> will be used to generate User values For generic types like Gen<List<T>>, the method can accept a Gen<T> parameter Example F# C# open Hedgehog open Hedgehog.FSharp open System type Email = Email of string type User = { Name: string Email: Email RegisteredAt: DateTime } // Custom generators class type MyGenerators = // Generator for Email type - return type is Gen<Email> static member Email() : Gen<Email> = gen { let! name = Gen.string (Range.linear 3 10) Gen.alphaNum let! domain = Gen.item [\"com\"; \"net\"; \"org\"] return Email $\"{name}@example.{domain}\" } // Generator for DateTime - return type is Gen<DateTime> static member DateTime() : Gen<DateTime> = gen { let! days = Gen.int32 (Range.linear 0 365) return DateTime.Now.AddDays(-float days) } // Register the custom generators let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<MyGenerators> // Now Gen.autoWith will use MyGenerators.Email() for Email types // and MyGenerators.DateTime() for DateTime types property { let! user = Gen.autoWith<User> config let (Email email) = user.Email return email.Contains(\"@\") && user.RegisteredAt <= DateTime.Now } |> Property.check using Hedgehog; using Hedgehog.Linq; using System; public record Email(string Value); public record User(string Name, Email Email, DateTime RegisteredAt); // Custom generators class public class MyGenerators { // Generator for Email type - return type is Gen<Email> public static Gen<Email> Email() => from name in Gen.AlphaNum.String(Range.LinearInt32(3, 10)) from domain in Gen.Item(\"com\", \"net\", \"org\") select new Email($\"{name}@example.{domain}\"); // Generator for DateTime - return type is Gen<DateTime> public static Gen<DateTime> DateTime() => from days in Gen.Int32(Range.LinearInt32(0, 365)) select System.DateTime.Now.AddDays(-days); } // Register the custom generators var config = AutoGenConfig.Defaults .AddGenerators<MyGenerators>(); // Now Gen.AutoWith will use MyGenerators.Email() for Email types // and MyGenerators.DateTime() for DateTime types var property = from user in Gen.AutoWith<User>(config).ForAll() select user.Email.Value.Contains(\"@\") && user.RegisteredAt <= System.DateTime.Now; property.Check(); Generator Method Signatures Custom generator methods must follow specific patterns: Parameterless Generators For types without generic parameters: F# C# static member TypeName() : Gen<TypeName> = ... public static Gen<TypeName> TypeName() => ... Generic Type Generators For generic types, accept Gen<T> parameters for each type parameter: F# C# type GenericGenerators = // Simple generic type static member MyGenericType<'a>(valueGen: Gen<'a>) : Gen<MyGenericType<'a>> = valueGen |> Gen.map (fun x -> MyGenericType(x)) public class GenericGenerators { // Simple generic type public static Gen<MyGenericType<A>> MyGenericType<A>(Gen<A> valueGen) => valueGen.Select(x => new MyGenericType<A>(x)); } Using AutoGenContext For recursive types or when you need access to collection range and recursion depth, use AutoGenContext: F# C# type GenericGenerators = // Access to recursion control via AutoGenContext static member ImmutableList<'a>(context: AutoGenContext, valueGen: Gen<'a>) : Gen<ImmutableList<'a>> = if context.CanRecurse then valueGen |> Gen.list context.CollectionRange |> Gen.map ImmutableList.CreateRange else Gen.constant ImmutableList<'a>.Empty let config = AutoGenConfig.defaults |> AutoGenConfig.addGenerators<GenericGenerators> public class GenericGenerators { // Access to recursion control via AutoGenContext public static Gen<ImmutableList<A>> ImmutableList<A>(AutoGenContext context, Gen<A> valueGen) => context.CanRecurse ? valueGen.List(context.CollectionRange).Select(System.Collections.Immutable.ImmutableList.CreateRange) : Gen.Constant(System.Collections.Immutable.ImmutableList<A>.Empty); } var config = AutoGenConfig.Defaults .AddGenerators<GenericGenerators>(); Advanced Scenarios Multiple Configurations You can create different configurations for different test scenarios: F# C# let smallDataConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 0 10) Gen.alpha) let largeDataConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.string (Range.linear 0 1000) Gen.unicode) var smallDataConfig = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(0, 10), Gen.Alpha)); var largeDataConfig = AutoGenConfig.Defaults .AddGenerator(Gen.String(Range.LinearInt32(0, 1000), Gen.Unicode)); Best Practices Start with Gen.auto - Use the default auto-generation first, only customize when needed Register generators once - Create a shared AutoGenConfig for your test suite Use type safety - Let the type system guide generator creation Test your generators - Verify custom generators produce valid data Leverage AutoGenContext - For recursive types, use AutoGenContext to control depth and collection sizes"
  },
  "articles/best-practices.html": {
    "href": "articles/best-practices.html",
    "title": "Property-Based Testing Best Practices | Hedgehog .NET",
    "summary": "Property-Based Testing Best Practices The Mental Shift: From Examples to Properties Property-based testing requires a fundamental shift in how you think about testing. Instead of asking \"what specific examples should I test?\", you ask \"what is always true about my code?\" Example-Based vs Property-Based Thinking Example-Based Property-Based \"Test with values 1, 5, and 100\" \"Test with any positive integer\" \"Check this specific case\" \"What's always true?\" \"This input gives this output\" \"What relationship holds between input and output?\" \"Cover branches\" \"Cover invariants and properties\" The Core Philosophy Properties over Examples: Seek universal truths that hold for all valid inputs, not just carefully chosen examples. Generative Thinking: Think about the space of all possible inputs. What happens with empty collections? Maximum values? Negative numbers? Unicode characters? Shrinking for Clarity: When tests fail, the framework automatically finds the minimal failing case, revealing the true cause. Specification by Properties: Properties serve as executable specifications that document how your code should behave. Essential over Exhaustive: Focus on minimal, non-overlapping properties that provide unique value. Quality over quantity. Discovering Properties: A Systematic Approach Step 1: Understand the Code's Contracts Before writing any test, ask these fundamental questions: What are the preconditions? (What inputs are valid?) What are the postconditions? (What does the code guarantee about outputs?) What invariants must always hold? (What never changes?) What relationships exist between inputs and outputs? What business rules must never be violated? Step 2: Use Property Pattern Recognition Start with the easiest patterns to identify: Type Properties: Does it return the expected type? Boundary Properties: What happens at edges (empty, zero, max, null)? Idempotent Properties: Does doing it twice = doing it once? Inverse Properties: Can you undo the operation? Invariant Properties: What never changes? Commutative Properties: Does order matter? Business Rule Properties: What domain rules must hold? The Seven Core Property Patterns 1. Invariants: What Never Changes Pattern: Properties that always hold about the result, regardless of input. When to use: When something about the output must always be true. Questions to ask: What properties are preserved by this operation? What must always be true about the result? What can't possibly change? Examples: Sorting preserves all elements (count and contents) Mapping over a list preserves its length Filtering never increases collection size String trimming never increases length F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Sort should preserve all elements`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let sorted = List.sort list test <@ List.length sorted = List.length list @> test <@ List.forall (fun x -> List.contains x sorted) list @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void Sort_Should_Preserve_All_Elements() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let sorted = list.OrderBy(x => x).ToList() select sorted.Count == list.Count && list.All(x => sorted.Contains(x)); property.Check(); } 2. Business Rules: Domain Constraints Pattern: Domain-specific rules that must never be violated. When to use: When you have business logic that defines what's valid. Questions to ask: What business rules must never be broken? What would make the output invalid in the business domain? What constraints does the domain impose? Examples: Discounts never exceed the original price Age must be within valid range (0-120) Account balance can't go negative (unless overdraft allowed) Percentages must be between 0 and 100 F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote let priceGen = Gen.int32 (Range.constant 1 10000) |> Gen.map (fun x -> decimal x / 100m) let discountGen = Gen.int32 (Range.constant 0 100) |> Gen.map (fun x -> decimal x / 100m) [<Fact>] let ``Apply discount should never exceed original price`` () = property { let! price = priceGen let! discountPercent = discountGen let discounted = applyDiscount price discountPercent test <@ discounted <= price @> test <@ discounted >= 0m @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var priceGen = Gen.Int32(Range.Constant(1, 10000)).Select(x => (decimal)x / 100); var discountGen = Gen.Int32(Range.Constant(0, 100)).Select(x => (decimal)x / 100); [Fact] public void ApplyDiscount_Should_Never_Exceed_Original_Price() { var property = from price in priceGen.ForAll() from discountPercent in discountGen.ForAll() let discounted = ApplyDiscount(price, discountPercent) select discounted <= price && discounted >= 0; property.Check(); } 3. Inverse/Roundtrip: Reversible Operations Pattern: Operations that undo each other should return to the original state. When to use: When you have encode/decode, serialize/deserialize, compress/decompress, encrypt/decrypt, or any reversible transformation. Questions to ask: Can I undo this operation? Is there a reverse operation? Should encodedecode return the original? Examples: SerializeDeserialize = identity EncodeDecode = identity CompressDecompress = identity AddSubtract = identity F# C# open Hedgehog open Hedgehog.FSharp open System.Text.Json open Swensen.Unquote [<Fact>] let ``Serialize should roundtrip when deserializing`` () = property { let! person = Gen.auto<Person> let json = JsonSerializer.Serialize(person) let restored = JsonSerializer.Deserialize<Person>(json) test <@ restored = person @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var personGen = /* define your Person generator */; [Fact] public void Serialize_Should_RoundTrip_When_Deserializing() { var property = from person in personGen.ForAll() let json = JsonSerializer.Serialize(person) let restored = JsonSerializer.Deserialize<Person>(json) select restored.Equals(person); property.Check(); } 4. Idempotence: Applying N Times = Applying Once Pattern: Applying an operation multiple times has the same effect as applying it once. When to use: When operations normalize, clean, or reach a stable state. Questions to ask: Does applying this twice change the result? Does the operation stabilize? Is this a normalization? Examples: Normalize(Normalize(x)) = Normalize(x) ToUpper(ToUpper(s)) = ToUpper(s) Trim(Trim(s)) = Trim(s) Absolute value is idempotent: Abs(Abs(x)) = Abs(x) F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Normalize should be idempotent`` () = property { let! text = Gen.string (Range.linear 0 100) Gen.unicode let once = normalize text let twice = normalize once test <@ twice = once @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void Normalize_Should_Be_Idempotent() { var property = from text in Gen.Unicode.String(Range.LinearInt32(0, 100)).ForAll() let once = Normalize(text) let twice = Normalize(once) select twice == once; property.Check(); } 5. Oracle: Comparing Against Known Truth Pattern: Compare your implementation against a reference implementation or mathematical truth. When to use: When you have a trusted implementation (standard library, mathematical formula, legacy system). Questions to ask: Is there a reference implementation? Can I use a mathematical formula? Is there a simpler (but slower) correct implementation? Examples: Custom sort should match standard library sort Square root: sqrt(x)  x Custom parser should match standard parser Optimized algorithm should match naive implementation F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Custom sort should match standard sort`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let custom = myCustomSort list let standard = List.sort list test <@ custom = standard @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void CustomSort_Should_Match_StandardSort() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let custom = MyCustomSort(list) let standard = list.OrderBy(x => x).ToList() select custom.SequenceEqual(standard); property.Check(); } 6. Metamorphic: How Input Changes Affect Output Pattern: How transforming the input should transform the output. When to use: When you understand the mathematical or logical relationship between input and output transformations. Questions to ask: If I double the input, what happens to the output? If I reverse the input, how does the output change? What transformations have predictable effects? Examples: Doubling all elements doubles the sum Reversing input twice returns original Adding constant to all elements adds constant  count to sum Multiplying prices by 2 multiplies total by 2 F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Doubling elements should double the sum`` () = property { let! list = Gen.list (Range.linear 0 100) Gen.int32 let originalSum = List.sum list let doubledSum = list |> List.map ((*) 2) |> List.sum test <@ doubledSum = originalSum * 2 @> } |> Property.check using Hedgehog; using Hedgehog.Linq; [Fact] public void DoublingElements_Should_Double_The_Sum() { var property = from list in Gen.Int32(Range.ConstantBoundedInt32()).List(Range.LinearInt32(0, 100)).ForAll() let originalSum = list.Sum() let doubledSum = list.Select(x => x * 2).Sum() select doubledSum == originalSum * 2; property.Check(); } 7. Model-Based: Generate Valid Output First Pattern: Generate the expected output first, then derive the input that should produce it. When to use: When it's easier to generate valid output than to generate valid input, or when you want to avoid complex filtering. Questions to ask: What does valid output look like? Can I work backwards from output to input? Is it easier to generate the result than the cause? Examples: Generate event  derive command that should produce it Generate normalized form  derive denormalized input Generate valid parse result  derive string that should parse to it F# C# open Hedgehog open Hedgehog.FSharp open Swensen.Unquote [<Fact>] let ``Create account command should produce expected event`` () = property { let! expectedEvent = Gen.auto<AccountCreatedEvent> // Work backwards: derive command from event let command = { AccountId = expectedEvent.AccountId Name = expectedEvent.Name InitialBalance = expectedEvent.InitialBalance } let actualEvent = accountService.Handle command test <@ actualEvent = expectedEvent @> } |> Property.check using Hedgehog; using Hedgehog.Linq; var eventGen = /* define your AccountCreatedEvent generator */; [Fact] public void CreateAccountCommand_Should_Produce_Expected_Event() { var property = from expectedEvent in eventGen.ForAll() // Work backwards: derive command from event let command = new CreateAccountCommand( expectedEvent.AccountId, expectedEvent.Name, expectedEvent.InitialBalance) let actualEvent = accountService.Handle(command) select actualEvent.Equals(expectedEvent); property.Check(); } Avoiding Overlapping Properties Critical Rule: Before implementing tests, ensure your properties are distinct and non-overlapping. The Problem with Overlapping Properties Multiple properties that verify the same underlying truth waste effort and create maintenance burden without adding value. The Elimination Workflow Discovery: List ALL candidate properties you can think of Analysis: Examine relationships between properties Elimination: Remove redundancy using these criteria: If property A failing  property B must fail: Keep the stronger one only If property A is a special case of B: Keep B only If same invariant, different wording: Keep the clearest one Proposal: Present minimal set with justification Example: Sorting Function Initial candidates: Sorted list contains all original elements Sorted list has same count as original Sorted list has same elements with same frequencies Sorted list is in ascending order Sorting twice gives same result as sorting once Analysis: Property 2 is weaker than property 1 (1 failing  2 fails) Property 3 is weaker than property 1 (1 failing  3 fails) Property 4 tests a different aspect (ordering, not preservation) Property 5 tests a different aspect (idempotence) Final minimal set: Sorted list contains all original elements (covers count and frequencies) Sorted list is in ascending order Sorting twice gives same result as sorting once Designing Effective Generators When to Use Auto-Generation Use auto-generation (default) when: Testing with primitive types (int, string, bool, etc.) Working with simple domain objects with public constructors Testing collections of simple types You want to explore the full input space without constraints When to Create Custom Generators Create custom generators when: You need constrained values (positive numbers, valid emails, etc.) Testing complex domain objects with invariants Values must follow specific business rules Working with recursive data structures You need specific distributions (e.g., mostly small values, rare large values) Generator Design Principles Coverage: Generate the full valid input space, including edge cases (empty, zero, max, min, null, etc.) Relevance: Focus on valid inputs. Test invalid cases separately with explicit invalid generators. Composition: Build complex generators from simple ones using LINQ. Realistic: Generate data that resembles production scenarios, not just random noise. Avoid Over-Filtering: Don't use where clauses that reject most generated values. The Filtering Anti-Pattern  Bad - Filtering rejects many values: F# C# open Hedgehog open Hedgehog.FSharp // Bad: Rejects ~50% of generated values gen { let! x = Gen.int32 (Range.constant -1000 1000) where (x > 0) return x } // Bad: Rejects 50% of values gen { let! x = Gen.int32 (Range.constant -100 100) where (x % 2 = 0) return x } using Hedgehog; using Hedgehog.Linq; // Bad: Rejects ~50% of generated values from x in Gen.Int32(Range.Constant(-1000, 1000)) where x > 0 select x // Bad: Rejects 50% of values from x in Gen.Int32(Range.Constant(-100, 100)) where x % 2 == 0 select x  Good - Generate only valid values: F# C# open Hedgehog open Hedgehog.FSharp // Good: Only generates positive values Gen.int32 (Range.constant 1 1000) // Good: Only generates even values Gen.int32 (Range.constantBounded ()) |> Gen.map (fun x -> x &&& ~~~1) using Hedgehog; using Hedgehog.Linq; // Good: Only generates positive values Gen.Int32(Range.Constant(1, 1000)) // Good: Only generates even values Gen.Int32(Range.ConstantBoundedInt32()).Select(x => x & ~1) Rule of Thumb: If your generator rejects more than 10-20% of values, redesign it to generate valid values directly. Common Anti-Patterns to Avoid Testing Anti-Patterns  Testing Implementation Details: Don't test how code works, test what it does. Bad: Checking internal state or private fields Good: Checking observable behavior and guarantees  Over-Constraining Generators: Don't make generators so specific they only produce passing values. Bad: Only generating sorted lists when testing a sort function Good: Generating any list and asserting it becomes sorted  Hidden Assumptions: Don't assume specific generated values in your assertions. Bad: result.Should().Be(42) in a property test Good: result.Should().BeGreaterThan(input)  Example-Based Thinking in Property Tests: Don't test specific values; test relationships. Bad: [Property] void Test(int x) => Foo(5).Should().Be(10); Good: [Property] void Test(int x) => Foo(x).Should().Be(x * 2);  Ignoring Shrinking Output: The minimal failing case is the key to understanding the bug. Don't just see \"test failed\" Examine the shrunk input to understand why  Too Many Assertions in One Test: Keep property tests focused on a single property. Bad: Testing 5 different invariants in one test Good: One property per test, 5 focused tests  Redundant Properties: Don't create multiple tests that verify the same underlying property. Analyze relationships between properties Keep only distinct, non-overlapping tests  Weak Properties Instead of Strong Ones: Don't write several weak properties when one stronger property would suffice. Bad: Separate tests for count, for element presence, for no duplicates Good: One test asserting \"contains all original elements\" (implies count, presence, and frequency) Generator Anti-Patterns  Insufficient Coverage: Generators that miss important edge cases. Consider: empty, zero, negative, max, min, null, whitespace, Unicode  Unrealistic Data: Generating values that would never occur in production. Bad: Random strings that don't resemble real data Good: Strings that look like actual names, emails, addresses  Over-Filtering: Using where that rejects most generated values (>50% rejection). See \"The Filtering Anti-Pattern\" section above The Property Discovery Checklist When analyzing code to test, systematically ask: Universal Truths:  What's always true about the output?  What can't possibly happen if the code is correct?  What would it mean for this to be correct? Reversibility:  Can I undo this operation?  Is there an inverse operation? Stability:  Does doing this twice differ from once?  Does it reach a stable state? Relationships:  What relationships must hold between input and output?  How do input transformations affect output? Boundaries:  What happens at the edges (empty, zero, max, null)?  What separates valid from invalid? Domain Rules:  What business rules must never be violated?  What domain constraints exist? Comparison:  Is there a reference implementation to compare against?  Is there a mathematical truth to verify? Practical Workflow 1. Start Simple Begin with the most obvious property and auto-generated parameters. 2. Run and Observe Let the generator explore the input space. Pay attention to failures. 3. Analyze Shrinking When tests fail, examine the minimal failing case. What does it reveal? 4. Refine Generators If auto-generation is too broad, add constraints with custom generators. 5. Iterate Add more properties one at a time, ensuring each adds unique value. 6. Review for Overlap Before finalizing, eliminate redundant properties. The Power of Property-Based Testing Coverage: One property test exercises your code with hundreds of different inputs. Edge Cases: Generators automatically explore boundaries you might not think of. Documentation: Properties serve as executable specifications. Regression Protection: Properties continue to verify behavior as code evolves. Bug Finding: Random exploration often finds bugs that example-based tests miss. Minimal Failures: Shrinking reveals the simplest case that breaks your code. Remember: The goal is not to test examples, but to discover and verify universal truths about your code. Think in properties, not examples."
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | Hedgehog .NET",
    "summary": "Getting Started This guide will help you write your first property-based tests with Hedgehog in just a few minutes. Installation Install Hedgehog from NuGet: dotnet add package Hedgehog Your First Property Test Let's test a simple property: reversing a list twice should give you the original list. F# C# open Hedgehog open Hedgehog.FSharp let propReverse = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } // Run it Property.check propReverse using Hedgehog; using Hedgehog.Linq; var propReverse = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); // Run it propReverse.Check(); Run this and you'll see: +++ OK, passed 100 tests. Understanding What Happened Generator: Gen.list (or Gen.Alpha.List) created random lists of characters Range: Range.linear 0 100 specified lists can have 0 to 100 elements Property: The return statement (or select) defines what should be true for all inputs Testing: Hedgehog generated 100 random lists and verified the property held for each Writing Better Properties Good properties describe invariants - things that should always be true. Here are some patterns: Inverse operations: f(g(x)) = x encode(decode(x)) = x serialize(deserialize(x)) = x Commutative operations: f(a, b) = f(b, a) x + y = y + x min(a, b) = min(b, a) Idempotence: f(f(x)) = f(x) sort(sort(xs)) = sort(xs) distinct(distinct(xs)) = distinct(xs) Preservation: Properties that don't change length(reverse(xs)) = length(xs) sum(map(f, xs)) = map(f, sum(xs)) // if f is linear Seeing Shrinking in Action Let's introduce a bug and see how Hedgehog finds the minimal failing case: F# C# open Hedgehog open Hedgehog.FSharp // Buggy function - fails for numbers > 100 let tryAdd a b = if a > 100 then None else Some(a + b) let propAdd = property { let! a = Gen.int32 (Range.constantBounded ()) let! b = Gen.int32 (Range.constantBounded ()) return tryAdd a b = Some(a + b) } Property.check propAdd using Hedgehog; using Hedgehog.Linq; // Buggy function - fails for numbers > 100 int? TryAdd(int a, int b) { if (a > 100) return null; return a + b; } var propAdd = from a in Gen.Int32(Range.ConstantBoundedInt32()).ForAll() from b in Gen.Int32(Range.ConstantBoundedInt32()).ForAll() select TryAdd(a, b) == a + b; propAdd.Check(); Output: *** Failed! Falsifiable (after 16 tests and 5 shrinks): 101 0 Notice Hedgehog didn't just find a failing case - it found the smallest one: a = 101, b = 0. This is automatic shrinking in action. Integration with Test Frameworks xUnit Tip Hedgehog provides integrated support for xUnit v3 in Hedgehog.Xunit package. F# C# open Xunit open Hedgehog open Hedgehog.FSharp [<Fact>] let ``reverse twice is identity`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check using Xunit; using Hedgehog; using Hedgehog.Linq; [Fact] public void ReverseTwiceIsIdentity() { var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } NUnit F# C# open NUnit.Framework open Hedgehog open Hedgehog.FSharp [<Test>] let ``reverse twice is identity`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check using NUnit.Framework; using Hedgehog; using Hedgehog.Linq; [Test] public void ReverseTwiceIsIdentity() { var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } Expecto (F# only) open Expecto open Hedgehog open Hedgehog.FSharp let tests = testList \"properties\" [ testCase \"reverse twice is identity\" <| fun _ -> property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.check ] [<EntryPoint>] let main args = runTestsWithArgs defaultConfig args tests Building Custom Generators You can compose generators to create complex test data: F# C# open System.Net open Hedgehog open Hedgehog.FSharp // Generator for IP addresses let ipAddressGen = gen { let! bytes = Gen.array (Range.singleton 4) Gen.byte return IPAddress bytes } // Generator for valid email-like strings let emailGen = gen { let! name = Gen.string (Range.linear 1 20) Gen.alphaNum let! domain = Gen.item [\"com\"; \"net\"; \"org\"] return $\"{name}@example.{domain}\" } // Use them in properties property { let! ip = ipAddressGen let! email = emailGen return ip.ToString().Length > 0 && email.Contains(\"@\") } |> Property.check using System.Net; using Hedgehog; using Hedgehog.Linq; // Generator for IP addresses var ipAddressGen = from bytes in Gen.Byte.Array(Range.Singleton(4)) select new IPAddress(bytes); // Generator for valid email-like strings var emailGen = from name in Gen.AlphaNum.String(Range.LinearInt32(1, 20)) from domain in Gen.Item(\"com\", \"net\", \"org\") select $\"{name}@example.{domain}\"; // Use them in properties var property = from ip in ipAddressGen.ForAll() from email in emailGen.ForAll() select ip.ToString().Length > 0 && email.Contains(\"@\"); property.Check(); Auto-Generating Test Data Hedgehog can automatically generate test data for your types: F# C# open Hedgehog open Hedgehog.FSharp type User = { Name: string Age: int } property { let! user = Gen.auto<User> return user.Age >= 0 } |> Property.check using Hedgehog; using Hedgehog.Linq; public record User(string Name, int Age); var property = from user in Gen.Auto<User>().ForAll() select user.Age >= 0; property.Check(); Auto-generation works with records, unions, tuples, classes, and collections. For advanced customization and registering custom generators, see the Auto-Generation Guide. Testing Asynchronous Functions Hedgehog provides first-class support for testing asynchronous code using F# async computations and C# Task/Task<T>. You can bind async operations directly in the property computation expression or LINQ query syntax. F# C# open Hedgehog open Hedgehog.FSharp property { let! x = Gen.int32 (Range.constant 0 100) let! y = async { return x + 1 } return y = x + 1 } |> Property.checkBoolAsync You can mix async and task: open System.Threading.Tasks property { let! x = Gen.int32 (Range.constant 0 100) let! y = async { return x + 1 } let! z = task { return y * 2 } return z = (x + 1) * 2 } |> Property.checkBoolAsync using Hedgehog; using Hedgehog.Linq; using System.Threading.Tasks; var property = from x in Gen.Int32(Range.Constant(0, 100)).ForAll() from y in Task.FromResult(x + 1) select y == x + 1; property.CheckAsync(); Controlling Test Runs You can customize how many tests to run and other settings: F# C# open Hedgehog open Hedgehog.FSharp let config = PropertyConfig.defaults |> PropertyConfig.withTests 1000<tests> property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.checkWith config using Hedgehog; using Hedgehog.Linq; var config = PropertyConfig.Defaults .WithTests(PropertyConfig.Test.Create(1000)); var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(config); Common Patterns Re-running Failing Tests When a property fails, Hedgehog provides a seed that you can use to reproduce the exact failure: F# C# open Hedgehog open Hedgehog.FSharp let prop = property { let! x = Gen.int32 (Range.constant 0 1000) return x < 500 // Will fail eventually } // First run - will fail and show a seed Property.check prop // Example output: // *** Failed! Falsifiable (after 6 tests and 1 shrink): // 500 // This failure can be reproduced by running: // > Property.recheck \"1a2b3c4d\" prop // Recheck with the specific seed Property.recheck \"1a2b3c4d\" prop using Hedgehog; using Hedgehog.Linq; var prop = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() select x < 500; // Will fail eventually // First run - will fail and show a seed prop.Check(); // Example output: // *** Failed! Falsifiable (after 6 tests and 1 shrink): // 500 // This failure can be reproduced by running: // > prop.Recheck(\"1a2b3c4d\") // Recheck with the specific seed prop.Recheck(\"1a2b3c4d\"); This is especially useful when: Debugging intermittent failures Sharing reproducible test cases with teammates Verifying a bug fix works for the specific failing case Adding Debug Information Use counterexample to add context when tests fail: F# C# open Hedgehog open Hedgehog.FSharp property { let! x = Gen.int32 (Range.constant 0 1000) let! y = Gen.int32 (Range.constant -100 1000) counterexample $\"x = {x}, y = {y}, x * y = {x * y}\" return x * y >= 0 } |> Property.check using Hedgehog; using Hedgehog.Linq; var property = from x in Gen.Int32(Range.Constant(0, 1000)).ForAll() from y in Gen.Int32(Range.Constant(-100, 1000)).ForAll() from _ in Property.CounterExample(() => $\"x = {x}, y = {y}, x * y = {x * y}\") select x * y >= 0; property.Check(); *** Failed! Falsifiable (after 20 tests and 11 shrinks): 1 -100 x = 1, y = -100, x * y = -100 Additional Resources Hedgehog.Xunit - Enhanced xUnit integration with [<Property>] attributes You're now ready to start finding bugs automatically with property-based testing!"
  },
  "articles/ranges.html": {
    "href": "articles/ranges.html",
    "title": "Understanding Ranges | Hedgehog .NET",
    "summary": "Understanding Ranges Ranges control how Hedgehog generates values and are crucial for effective property-based testing. Choosing the right range type can mean the difference between tests that find bugs and tests that miss edge cases. What Are Ranges? A Range specifies the bounds within which a generator produces values. But ranges do more than just set minimum and maximum valuesthey control how the generator explores the value space as tests progress. Hedgehog runs tests with a Size parameter that starts at 1 and increases to 99, then cycles back. Different range types use this Size parameter differently to control value generation. The Three Core Range Types Constant Ranges What they do: Generate values uniformly across the entire range, unaffected by the Size parameter. When to use: Small ranges where you want full coverage (e.g., 0-10) Critical edge cases that must be tested at all sizes When the range is already appropriately scoped Characteristics:  Tests boundary values at all sizes  Uniform distribution across the range  Can miss patterns in large ranges  No gradual exploration of the value space F# C# open Hedgehog open Hedgehog.FSharp // Always generates values between 0-100, regardless of test size Gen.int32 (Range.constant 0 100) // Always generates lists with 5-10 elements Gen.list (Range.constant 5 10) Gen.alpha using Hedgehog; using Hedgehog.Linq; // Always generates values between 0-100, regardless of test size Gen.Int32(Range.Constant(0, 100)); // Always generates lists with 5-10 elements Gen.Alpha.List(Range.Constant(5, 10)); Example Use Case: Testing a function that works with percentages (0-100) or small counts. Linear Ranges What they do: Scale the range bounds linearly with the Size parameter. At Size 1, generates values near the origin; at Size 99, generates values near the bounds. When to use: When you want gradual, predictable exploration of the value space When the range is small enough that skipping the first ~1% won't miss critical values When you control the origin point with linearFrom Characteristics:  At Size 1, bounds are only ~1% of the full range (e.g., bounds 0-10 for a range of 0-1000)  Origin affects the bounds - use linearFrom to control where small sizes start  Gradual, predictable scaling  May miss critical edge cases in large ranges (takes many iterations to reach upper bound)  Poor for ranges where you need to test boundary values early F# C# open Hedgehog open Hedgehog.FSharp // Scales linearly from 0 to 1000 // Size 1: bounds (0, ~10) - generates random values like 0, 4, 7, 10 // Size 50: bounds (0, ~505) // Size 99: bounds (0, 1000) Gen.int32 (Range.linear 0 1000) // Scales from origin=0, range 0-1000 // Size 1: near 0 // Size 99: ~1000 Gen.int32 (Range.linearFrom 0 0 1000) using Hedgehog; using Hedgehog.Linq; // Scales linearly from 0 to 1000 // Size 1: bounds (0, ~10) - generates random values like 0, 4, 7, 10 // Size 50: bounds (0, ~505) // Size 99: bounds (0, 1000) Gen.Int32(Range.LinearInt32(0, 1000)); // Scales from origin=0, range 0-1000 // Size 1: near 0 // Size 99: ~1000 Gen.Int32(Range.LinearFromInt32(0, 0, 1000)); Example Use Case: Testing array indices (0-1000), moderately-sized counts, or when you control the origin with linearFrom. Exponential Ranges What they do: Scale the range bounds exponentially with the Size parameter. Start very close to the origin and grow exponentially toward the bounds. When to use: Large ranges (Int32.MaxValue, Int64.MaxValue, etc.) When boundary values (especially small ones) are critical When you need both edge cases and large values Characteristics:  Tests boundary values at small sizes  Perfect for huge ranges like Int32.MaxValue  Explores both edge cases and large values effectively  Reaches the maximum bound at Size 99 F# C# open Hedgehog open Hedgehog.FSharp // Exponential scaling from 0 to Int32.MaxValue // Size 0: 0 // Size 1: ~0 (very small) // Size 10: ~2 // Size 50: ~46,340 // Size 99: 2,147,483,647 (Int32.MaxValue) Gen.int32 (Range.exponential 0 System.Int32.MaxValue) // From origin=1 Gen.int32 (Range.exponentialFrom 1 1 System.Int32.MaxValue) using Hedgehog; using Hedgehog.Linq; // Exponential scaling from 0 to Int32.MaxValue // Size 0: 0 // Size 1: ~0 (very small) // Size 10: ~2 // Size 50: ~46,340 // Size 99: 2,147,483,647 (Int32.MaxValue) Gen.Int32(Range.ExponentialInt32(0, int.MaxValue)); // From origin=1 Gen.Int32(Range.ExponentialFromInt32(1, 1, int.MaxValue)); Example Use Case: Testing with any integer, testing with very large collections, performance testing. The Boundary Value Problem Critical Insight: When using linear over very large ranges, boundary values are only tested at very small sizes where they're less likely to be generated. The Problem Consider this common pattern: F# C# // This looks reasonable but has a problem! Gen.int32 (Range.linear 0 System.Int32.MaxValue) // This looks reasonable but has a problem! Gen.Int32(Range.LinearInt32(0, int.MaxValue)) What actually happens: Size Bounds Issue 1 (0, ~21,691,854) Upper bound already in millions! 10 (0, ~216,918,546) 50 (0, ~1,084,592,732) 99 (0, 2,147,483,647) Only reaches max at size 99 At Size 1, while bounds include 0-21M, small values like 0-1000 are rare - only a ~0.005% chance of being picked! The Solution: Use Exponential for Large Ranges F# C# //  Correctly tests boundary values Gen.int32 (Range.exponential 0 System.Int32.MaxValue) //  Correctly tests boundary values Gen.Int32(Range.ExponentialInt32(0, int.MaxValue)) What actually happens: Size Bounds Coverage 0 (0, 0)  Tests exact boundary 1 (0, ~1)  Tests small values 10 (0, ~2)  Tests edge cases 50 (0, ~46,340)  Tests medium values 99 (0, 2,147,483,647)  Tests maximum Quick Reference Guide Choose based on what matters for your domain, not just the size of the range: Scenario Recommended Range Why Small range (0-100) constant or linear Range is small enough that linear won't skip important values Edge cases are critical exponential or constant Tests boundary values (0, 1, -1, etc.) at small sizes Uniform distribution needed linear (with appropriate size) Spreads values evenly across the range Very large range (Int32, Int64) exponential Linear will skip millions of values near the origin Need specific start point linearFrom or exponentialFrom Control where shrinking targets and small sizes start Fixed size collections constant or singleton Size shouldn't vary with test iterations Key Insight: The question isn't \"how big is my range?\" but \"will linear skip values that could expose bugs?\" For a range like 0-10,000: linear at Size 1 has bounds (0, ~101) - small values possible but less likely as range grows exponential at Size 1 has bounds (0, ~1) - heavily focused on small values If bugs are likely in 0-10 (empty, minimal values, off-by-one): use exponential If testing the full range gradually is more important: linear is fine Common Patterns and Examples Testing Positive Integers When you need positive integers (> 0), use linearFrom or exponentialFrom to set the origin: F# C# //  Starts at 1, scales to Int32.MaxValue Gen.int32 (Range.linearFrom 1 1 System.Int32.MaxValue) //  Better for very large ranges Gen.int32 (Range.exponentialFrom 1 1 System.Int32.MaxValue) //  Starts at 1, scales to int.MaxValue Gen.Int32(Range.LinearFromInt32(1, 1, int.MaxValue)); //  Better for very large ranges Gen.Int32(Range.ExponentialFromInt32(1, 1, int.MaxValue)); This is exactly what the [PositiveInt] attribute does in Hedgehog.Xunit. Testing Collection Sizes F# C# // Small lists with gradual growth Gen.list (Range.linear 0 20) Gen.alpha // Can test up to very large lists Gen.list (Range.exponential 0 10000) Gen.int32 // Fixed small size for focused testing Gen.list (Range.constant 5 10) Gen.bool // Small lists with gradual growth Gen.Alpha.List(Range.LinearInt32(0, 20)); // Can test up to very large lists Gen.Int32(Range.ConstantBoundedInt32()).List(Range.ExponentialInt32(0, 10000)); // Fixed small size for focused testing Gen.Bool.List(Range.Constant(5, 10)); Testing with Bounded Types For types with natural bounds (bytes, shorts, etc.), use exponentialBounded: F# C# // Automatically uses 0 to Byte.MaxValue (255) Gen.byte (Range.exponentialBounded ()) // Automatically uses Int16.MinValue to Int16.MaxValue Gen.int16 (Range.exponentialBounded ()) // Automatically uses 0 to byte.MaxValue (255) Gen.Byte(Range.ExponentialBoundedByte()); // Automatically uses short.MinValue to short.MaxValue Gen.Int16(Range.ExponentialBoundedInt16()); How Size Affects Test Execution Understanding how the Size parameter works helps you choose the right range: Test 1: Size = 1 Test 2: Size = 2 Test 3: Size = 3 ... Test 99: Size = 99 Test 100: Size = 100 Test 101: Size = 1 (cycles back) Test 102: Size = 2 ... Note: Size 0 is used internally for shrinking but is not used in the main test loop, which starts at Size 1. Scaling Formulas Linear: value = origin + ((bound - origin)  size) / 99 Exponential: diff = (((|bound - origin| + 1) ^ (size / 99)) - 1)  sign(bound - origin) value = origin + diff Constant: value = random between lowerBound and upperBound (ignores size) Best Practices  Do Use exponential for large ranges (Int32, Int64) Use linearFrom to control the starting point when the origin matters Use constant for small ranges where full coverage is needed Test your assumptions about what values are being generated Consider boundary values when choosing ranges  Don't Don't use linear over huge ranges (you'll miss edge cases) Don't assume Size 0 is tested (it starts at 1) Don't use unbounded ranges without understanding the implications Don't forget that linear doesn't start at the lower bound (use linearFrom instead) Debugging Range Behavior If you're unsure what values a range is producing, you can sample it: F# C# open Hedgehog open Hedgehog.FSharp // See what values are generated Range.exponential 0 System.Int32.MaxValue |> Gen.int32 |> Gen.sampleFrom 1 20 // 20 samples statring from size 1 // Output: [0; 0; 1; 1; 2; 1; 4; 5; 4; 0; 8; 1; 5; 17; 12; 20; 18; 48; 60; 22] - tests edge cases! // Compare linear vs exponential Range.linear 0 1000 |> Gen.int32 |> Gen.sampleFrom 1 20 // Output: [4; 12; 6; 20; 39; 20; 27; 3; 0; 52; 70; 77; 100; 137; 140; 66; 42; 27; 3; 194] Range.exponential 0 1000 |> Gen.int32 |> Gen.sampleFrom 1 20 // Output: [0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0; 1; 1; 1; 1; 2; 3; 3; 0] - tests edge cases! using Hedgehog; using Hedgehog.Linq; // See what values are generated Gen.Int32(Range.ExponentialInt32(0, int.MaxValue)) .SampleFrom(size: 1, count: 20); // Output: [0, 0, 1, 1, 2, 1, 4, 5, 4, 0, 8, 1, 5, 17, 12, 20, 18, 48, 60, 22] - tests edge cases! // Compare linear vs exponential Gen.Int32(Range.LinearInt32(0, 1000)) .SampleFrom(size: 1, count: 20); // Output: [4, 12, 6, 20, 39, 20, 27, 3, 0, 52, 70, 77, 100, 137, 140, 66, 42, 27, 3, 194] Summary Choosing the right range is crucial for effective property-based testing: Constant: Full range at all sizes, best when uniform distribution matters more than gradual scaling Linear: Gradual scaling, good when ~1% skip at small sizes won't miss bugs Exponential: Exponential scaling, best when edge cases near the origin are critical The decision isn't about the range sizeit's about your domain: Are bugs likely near 0, 1, empty, minimal values?  Exponential Does skipping the first 1% of your range matter?  Exponential or Constant Is uniform distribution more important than edge cases?  Linear or Constant When in doubt for large ranges (like Int32.MaxValue), use exponentialit's safer because it ensures boundary value coverage."
  },
  "index.html": {
    "href": "index.html",
    "title": "Hedgehog .NET | Hedgehog .NET",
    "summary": "Hedgehog .NET Hedgehog will eat all your bugs. Hedgehog is a modern property-based testing system for .NET, designed to help you release with confidence by automatically finding edge cases you didn't think of. What is Property-Based Testing? Instead of writing individual test cases with specific inputs and expected outputs, property-based testing lets you describe properties that should hold true for all inputs: reverse (reverse xs) = xs, xs :: [] This reads as: \"the reverse of the reverse of a list equals the original list  for all lists of any type.\" In Hedgehog, you express this property and the framework generates hundreds of random test cases automatically: F# C# property { let! xs = Gen.list (Range.linear 0 100) Gen.alpha return List.rev (List.rev xs) = xs } |> Property.render var property = from xs in Gen.Alpha.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); +++ OK, passed 100 tests. Why Hedgehog? Integrated Shrinking When a property fails, Hedgehog automatically simplifies the failing input to find the smallest counterexample. Unlike older property-based testing libraries that shrink values separately from generation, Hedgehog uses integrated shrinking  shrinking is built into generators, guaranteeing that shrunk values obey the same invariants as the generated values. This means you get minimal, actionable error reports: F# C# property { let! xs = Gen.list (Range.linear 0 100) version return xs |> List.rev = xs } |> Property.render var property = from xs in versionGen.List(Range.LinearInt32(0, 100)).ForAll() select xs.Reverse().SequenceEqual(xs); property.Check(); *** Failed! Falsifiable (after 3 tests and 6 shrinks): [0.0.0; 0.0.1] Even complex types like System.Version shrink automatically to their simplest failing case. Expressive Syntax F# C# Hedgehog provides gen and property computation expressions that feel natural in F#: let ipAddressGen = gen { let! addr = Gen.array (Range.singleton 4) Gen.byte return System.Net.IPAddress addr } Hedgehog provides support for LINQ syntax that allows writing generators and properties easier: var ipAddressGen = from addr in Gen.Byte.Array(Range.Singleton(4)) select new System.Net.IPAddress(addr); Precise Control Range combinators let you control the scope of generated values: Gen.int32 (Range.constant 0 100) // Always between 0-100 Gen.int32 (Range.linear 0 100) // Scales with test size Gen.list (Range.exponential 1 1000) g // Exponential growth Core Concepts Properties are invariants that should hold for all inputs. They're expressed as functions that return bool or Property<bool>. Generators produce random values of a given type. Hedgehog includes generators for primitives and combinators to build generators for complex types. Generators are composable using map, bind, and other familiar operations. Shrinking happens automatically when a property fails. Hedgehog finds progressively smaller inputs that still cause the failure, giving you the minimal reproduction case."
  },
  "stateful/commands.html": {
    "href": "stateful/commands.html",
    "title": "Commands | Hedgehog .NET",
    "summary": "Commands Commands are the heart of stateful testing. Each command represents a single operation you can perform on your system - like opening a door, adding an item to a cart, or incrementing a counter. Hedgehog then uses these individual actions (commands) to build up valid sequences that simulate client's behaviour. This page dives deep into the Command interface, explaining how commands work, when they execute, and how to use state to chain operations together. Understanding State Before diving into commands, you need to understand how state works in stateful testing. State is shared throughout the lifecycle of testing: first during sequence generation (when Hedgehog builds up a series of commands to execute), and then during sequence execution (when those commands actually run against your system). The key insight is that some parts of the state can be known during generation, while others only become known during execution: Known at generation time: When generating a sequence that includes LockDoorCommand, we know the door will be \"Locked\" for the next action in the sequence - even before executing anything. This is concrete state. Known only at execution time: If the system returns a lock code when the door is locked, we know that a code exists during generation, but the actual value is only available after execution. This is symbolic state. We represent concrete state using regular properties (like bool IsLocked), and symbolic state using the Var<T> type (like Var<string> LockCode). Here's an example of a door state that combines both: F# C# type DoorState = { IsLocked: bool // Concrete: we know immediately after LockDoor LockCode: Var<string> // Symbolic: actual code only known after execution } public record DoorState { public bool IsLocked { get; init; } // Concrete: we know immediately after LockDoor public Var<string> LockCode { get; init; } // Symbolic: actual code only known after execution } The key rule: At generation time, you can only access the concrete parts of the state. You cannot resolve symbolic variables because execution hasn't happened yet! The Command Interface Every command inherits from Command<TSystem, TState, TInput, TOutput> and implements these methods: F# C# type MyCommand() = inherit Command<MySystem, MyState, MyInput, MyOutput>() // 1. Name for reporting override _.Name = \"MyCommand\" // 2. Should this command be generated in this state? override _.Precondition(state) = true // 3. Generate input for this command override _.Generate(state) = Gen.int32 (Range.linear 0 100) // 4. Should we execute this command with these inputs? override _.Require(env, state, input) = true // 5. Execute the real operation override _.Execute(sut, env, state, input) = let result = sut.DoSomething(input) Task.FromResult(result) // 6. Update the model state override _.Update(state, input, outputVar) = { state with Value = outputVar } // 7. Verify the result is correct override _.Ensure(env, oldState, newState, input, output) = // Check output matches expectations true public class MyCommand : Command<MySystem, MyState, MyInput, MyOutput> { // 1. Name for reporting public override string Name => \"MyCommand\"; // 2. Should this command be generated in this state? public override bool Precondition(MyState state) => true; // 3. Generate input for this command public override Gen<MyInput> Generate(MyState state) => Gen.Int32(Range.LinearInt32(0, 100)); // 4. Should we execute this command with these inputs? public override bool Require(Env env, MyState state, MyInput input) => true; // 5. Execute the real operation public override Task<MyOutput> Execute(MySystem sut, Env env, MyState state, MyInput input) { var result = sut.DoSomething(input); return Task.FromResult(result); } // 6. Update the model state public override MyState Update(MyState state, MyInput input, Var<MyOutput> outputVar) => state with { Value = outputVar }; // 7. Verify the result is correct public override bool Ensure(Env env, MyState oldState, MyState newState, MyInput input, MyOutput output) => // Check output matches expectations true; } Let's understand each piece and how they work together. Understanding Env The Env (environment) is a key concept that allows you to resolve symbolic state values into concrete values, giving you access to the real execution-time values. Methods with Env (can resolve symbolic values): Require - Check preconditions using actual runtime values Execute - Perform operations using resolved values Ensure - Verify results using actual values Methods without Env (can only access concrete state): Generate - Only has access to structural/concrete state Update - Works with symbolic variables, doesn't resolve them During sequence generation, symbolic values don't have concrete runtime values yet, so Generate and Update cannot receive an Env. However, during execution, Require, Execute, and Ensure all receive an Env that lets you resolve any Var<T> to its actual runtime value. The Command Lifecycle When Hedgehog builds and executes a test sequence, each command goes through these stages: During Generation: 1. Precondition  Should we include this command? (check concrete state only - no Env) 2. Generate  Generate input for this command (only called if Precondition returns true) 3. Update  Update model state symbolically (enables next command's Precondition check) During Execution: 1. Require  Can we execute it now? (has Env - can resolve symbolic values) 2. Execute  Run the operation on the real system 3. Update  Update model state symbolically (same call as generation, now env has real values) 4. Ensure  Verify the result matches our expectations 1. Precondition: Deciding Whether to Generate When it runs: During test generation, before execution Purpose: Decide whether this command makes sense based on the concrete structure of the state Returns: true to include the command (and call Generate), false to skip this command Critical: You can only access concrete parts of the state here. No Env means no resolving symbolic variables! For example, checking a simple boolean: F# C# type DoorState = { IsLocked: bool // Concrete value we can check } type KnockKnockDoorCommand() = inherit Command<Door, DoorState, int, bool>() override _.Name = \"KnockKnock\" override _.Precondition(state) = // Check concrete state directly - no Env needed! state.IsLocked // Only generate when door is locked override _.Generate(state) = // Generate the number of knocks Gen.int32 (Range.linear 1 5) public record DoorState { public bool IsLocked { get; init; } // Concrete value we can check } public class KnockKnockDoorCommand : Command<Door, DoorState, int, bool> { public override string Name => \"KnockKnock\"; public override bool Precondition(DoorState state) { // Check concrete state directly - no Env needed! return state.IsLocked; // Only generate when door is locked } public override Gen<int> Generate(DoorState state) { // Generate the number of knocks return Gen.Int32(Range.LinearInt32(1, 5)); } } Key insight: At generation time, you only know the structure - \"the door is locked\", \"the stack has 3 items\" - but not the actual values like \"the lock code is 1234\" or \"the top item is 42\". Those require execution. 2. Generate: Creating Command Input When it runs: During test generation, after Precondition returns true Purpose: Generate random input for this command Returns: A Gen<TInput> generator that produces input values Important: This is only called when Precondition returns true, so you can assume the structural preconditions are already satisfied. 3. Require: Runtime Precondition Check When it runs: Just before execution, after the sequence is generated Purpose: Verify that the command can still be executed with these specific inputs. Returns: true to proceed with execution, false to skip this command (the test continues with remaining commands) Important: Returning false does NOT fail the test - it simply skips the command. This is different from Ensure, which validates correctness. Key difference from Precondition: Require DOES receive an Env parameter, so it CAN resolve symbolic variables! This is where you check concrete runtime values that weren't known during generation. When you need it: The most common case is when your Generate method returns Var<T> as part of the input (e.g., picking from a list of symbolic IDs). Since previous commands can be skipped, those symbolic variables might not be bound at execution time. Override Require to check if such variables can actually be resolved before attempting to use them. \uD83D\uDCA1 Tip: For a detailed explanation of when and how to use Require, including complete examples with symbolic variables in inputs, see Runtime Preconditions. In practice: The default Require implementation returns true, which works for most commands that don't use symbolic variables as input. 4. Execute: Running the Real Operation When it runs: During test execution Purpose: Perform the actual operation on your system under test Returns: A Task<TOutput> with the result This is straightforward - call your system's method and return the result: F# C# override _.Execute(sut, env, state, input) = let result = sut.IncrementCounter() Task.FromResult(result) public override Task<int> Execute(Counter sut, Env env, CounterState state, bool input) { var result = sut.Increment(); return Task.FromResult(result); } Important: The Execute method receives: sut: Your system under test (the real object) env: The environment with resolved values from previous commands state: The current model state input: The generated input for this command Use env to resolve any symbolic variables you need from the state: F# C# override _.Execute(sut, env, state, input) = let code = state.LockCode.Resolve(env) sut.UnlockDoorAsync(code, input) public override Task<bool> Execute(DoorState sut, Env env, CartState state, string input) { var code = state.LockCode.Resolve(env); return sut.UnlockDoorAsync(code, input); } 5. Update: Tracking Symbolic State When it runs: During both generation and execution phases - after each command in the sequence Purpose: Update your model state with the new symbolic output to evolve the structural state Returns: The new state Critical insight: Update is called during generation (before any real execution happens) to maintain the structural state. This allows subsequent commands in the sequence to evaluate their Precondition based on the evolved state. During execution, these variables are bound to actual runtime values in the Env. This is where you store the command's output as a symbolic variable (Var<TOutput>) that future commands can reference: F# C# override _.Update(state, input, outputVar) = { state with CurrentCount = outputVar } public override CounterState Update(CounterState state, bool input, Var<int> outputVar) => state with { CurrentCount = outputVar }; The outputVar is a symbolic reference to this command's output. Later commands can resolve it to get the actual value. Projecting Fields from Structured Outputs When a command returns a structured type (like a record or class), you often want to store individual fields in your state rather than the entire object. Use Var.map (F#) or .Select() (C#) to project fields from the output: F# C# // Command that returns a structured Person type type Person = { Name: string Age: int } type RegistryState = { LastPersonName: Var<string> LastPersonAge: Var<int> } type AddPersonCommand() = inherit Command<PersonRegistry, RegistryState, string * int, Person>() override _.Execute(sut, env, state, (name, age)) = let person = sut.AddPerson(name, age) Task.FromResult(person) // Project individual fields from the Person output override _.Update(state, input, personVar) = { LastPersonName = Var.map (fun p -> p.Name) personVar LastPersonAge = Var.map (fun p -> p.Age) personVar } // Command that returns a structured Person type public record Person(string Name, int Age); public record RegistryState { public Var<string> LastPersonName { get; init; } public Var<int> LastPersonAge { get; init; } } public class AddPersonCommand : Command<PersonRegistry, RegistryState, (string, int), Person> { public override Task<Person> Execute(PersonRegistry sut, Env env, RegistryState state, (string, int) input) { var (name, age) = input; var person = sut.AddPerson(name, age); return Task.FromResult(person); } // Project individual fields from the Person output public override RegistryState Update(RegistryState state, (string, int) input, Var<Person> personVar) => state with { LastPersonName = personVar.Select(p => p.Name), LastPersonAge = personVar.Select(p => p.Age) }; } How it works: Both projected variables (LastPersonName and LastPersonAge) share the same underlying variable name - they point to the same Person object in the environment. When you resolve them, the projection function is applied to extract the specific field. You can chain projections: F# C# override _.Update(state, input, personVar) = let nameVar = Var.map (fun p -> p.Name) personVar let nameLengthVar = Var.map String.length nameVar { state with NameLength = nameLengthVar } public override RegistryState Update(RegistryState state, (string, int) input, Var<Person> personVar) { var nameVar = personVar.Select(p => p.Name); var nameLengthVar = nameVar.Select(name => name.Length); return state with { NameLength = nameLengthVar }; } This is particularly useful when you need to pass different parts of a command's output to different subsequent commands. 6. Ensure: Verifying Correctness When it runs: After execution and state update Purpose: Assert that the output matches expectations Returns: true if the assertion passes, false or throw an exception if it fails This is your postcondition check: F# C# override _.Ensure(env, oldState, newState, input, output) = let oldCount = oldState.CurrentCount.Resolve(env) output = oldCount + 1 // Increment should increase by exactly 1 public override bool Ensure(Env env, CounterState oldState, CounterState newState, bool input, int output) { var oldCount = oldState.CurrentCount.Resolve(env); return output == oldCount + 1; // Increment should increase by exactly 1 } You can also throw exceptions for more detailed error messages: F# C# override _.Ensure(env, oldState, newState, input, output) = let oldCount = oldState.CurrentCount.Resolve(env) if output <> oldCount + 1 then failwith $\"Expected {oldCount + 1}, got {output}\" true public override bool Ensure(Env env, CounterState oldState, CounterState newState, bool input, int output) { var oldCount = oldState.CurrentCount.Resolve(env); Assert.Equal(output, oldCount + 1); return true; } Commands Without Outputs Sometimes operations don't return meaningful values - they just perform side effects. For these, use ActionCommand<TSystem, TState, TInput>: F# C# type CloseConnectionCommand() = inherit ActionCommand<Database, DbState, unit>() override _.Name = \"CloseConnection\" override _.Precondition(state) = true override _.Generate(state) = Gen.constant () override _.Execute(sut, env, state, input) = sut.CloseConnection() Task.CompletedTask // No return value override _.Update(state, input) = { state with IsConnected = false } // No output var override _.Ensure(env, oldState, newState, input) = // Verify side effect without checking output true public class CloseConnectionCommand : ActionCommand<Database, DbState, NoInput> { public override string Name => \"CloseConnection\"; public override bool Precondition(DbState state) => true; public override Gen<NoInput> Generate(DbState state) => Gen.Constant(NoInput.Value); public override Task Execute(Database sut, Env env, DbState state, NoInput input) { sut.CloseConnection(); return Task.CompletedTask; // No return value } public override DbState Update(DbState state, NoInput input) => state with { IsConnected = false }; // No output var public override bool Ensure(Env env, DbState oldState, DbState newState, NoInput input) => true; }"
  },
  "stateful/complete-example.html": {
    "href": "stateful/complete-example.html",
    "title": "Complete Example: Testing a Counter | Hedgehog .NET",
    "summary": "Complete Example: Testing a Counter This walkthrough will guide you through building a complete stateful test from scratch. We'll test a simple Counter class with increment, decrement, and reset operations. The System Under Test (SUT) Let's start with a simple counter implementation: F# C# type Counter() = let mutable value = 0 member _.Increment() = value <- value + 1 member _.Decrement() = value <- value - 1 member _.Reset() = value <- 0 member _.Get() = value public sealed class Counter { private int _value; public void Increment() => _value++; public void Decrement() => _value--; public void Reset() => _value = 0; public int Get() => _value; } This is our System Under Test (SUT). It maintains state (the current count) and provides operations that modify that state. The Model State To test our counter, we need a model that represents what we expect the counter's state to be. Since our counter has a single integer value, our model is simple: F# C# type CounterState = { CurrentCount: Var<int> // Symbolic reference to the counter's value } public record CounterState { public required Var<int> CurrentCount { get; init; } } The Var<int> is a symbolic variableit represents \"the value that operation X returned.\" This lets us track relationships between operations even before we know their concrete values. Defining Commands Now we'll define each operation as a Command. Each command inherits from Command<TSystem, TState, TInput, TOutput> where: TSystem is our system under test type (Counter) TState is our model state type (CounterState) TInput is the input parameter type for this command TOutput is what the command returns The Increment Command F# C# type IncrementCommand() = inherit Command<Counter, CounterState, unit, int>() // Name for debugging/shrinking output override _.Name = \"Increment\" // Always allow this command override _.Precondition(state) = true // Execute the real operation on the SUT override _.Execute(counter, env, state, input) = counter.Increment() let result = counter.Get() Task.FromResult(result) // Generate inputs (none needed for increment) override _.Gen(state) = Gen.constant () // Update our model state with the new value override _.Update(state, input, outputVar) = { CurrentCount = outputVar } // Assert the result is correct override _.Ensure(env, oldState, newState, input, result) = let oldCount = oldState.CurrentCount.Resolve(env) result = oldCount + 1 public class IncrementCommand : Command<Counter, CounterState, NoInput, int> { // Name for debugging/shrinking output public override string Name => \"Increment\"; // Always allow this command public override bool Precondition(CounterState state) => true; // Execute the real operation on the SUT public override Task<int> Execute(Counter sut, Env env, CounterState state, NoInput input) { sut.Increment(); var result = sut.Get(); return Task.FromResult(result); } // Generate inputs (none needed for increment) public override Gen<NoInput> Generate(CounterState state) => Gen.Constant(NoInput.Value); // Update our model state with the new value public override CounterState Update(CounterState state, NoInput input, Var<int> outputVar) => state with { CurrentCount = outputVar }; // Assert the result is correct public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) { var oldCount = oldState.CurrentCount.Resolve(env); return result == oldCount + 1; } } Let's break down each method: Name: Used in test output to show which command failed Precondition: Determines if this command can be generated in the current state (always true for simple commands) Execute: Runs the actual operation and returns the new count Gen: Generates random inputs (we use unit in F# or NoInput in C# since increment needs no meaningful input) Update: Takes the output and creates the new model state Ensure: Verifies the result is what we expected (old count + 1) The Decrement Command The decrement command is almost identical: F# C# type DecrementCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Decrement\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = counter.Decrement() let result = counter.Get() Task.FromResult(result) override _.Gen _ = Gen.constant () override _.Update(_, _, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = let oldCount = oldState.CurrentCount.Resolve(env) result = oldCount - 1 // Should decrease by 1 public class DecrementCommand : Command<Counter, CounterState, NoInput, int> { public override string Name => \"Decrement\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoInput input) { sut.Decrement(); var result = sut.Get(); return Task.FromResult(result); } public override Gen<NoInput> Generate(CounterState state) => Gen.Constant(NoInput.Value); public override CounterState Update(CounterState state, NoInput input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) { var oldCount = oldState.CurrentCount.Resolve(env); return result == oldCount - 1; // Should decrease by 1 } } The Reset Command Reset is interesting because it doesn't depend on the previous state: F# C# type ResetCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Reset\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = counter.Reset() let result = counter.Get() Task.FromResult(result) override _.Gen(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = result = 0 public class ResetCommand : Command<Counter, CounterState, NoInput, int> { public override string Name => \"Reset\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoInput input) { sut.Reset(); var result = sut.Get(); return Task.FromResult(result); } public override Gen<NoInput> Generate(CounterState state) => Gen.Constant(NoInput.Value); public override CounterState Update(CounterState state, NoInput input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) => result == 0; // Reset always returns 0 } A Get Command (for completeness) Let's add a read-only operation to verify our model stays in sync: F# C# type GetCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Get\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = Task.FromResult(counter.Get()) override _.Gen(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = // Get should return exactly what's in our model result = oldState.CurrentCount.Resolve(env) public class GetCommand : Command<Counter, CounterState, NoInput, int> { public override string Name => \"Get\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoInput input) => Task.FromResult(sut.Get()); public override Gen<NoInput> Generate(CounterState state) => Gen.Constant(NoInput.Value); public override CounterState Update(CounterState state, NoInput input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) { // Get should return exactly what's in our model return result == oldState.CurrentCount.Resolve(env); } } Creating the Specification Now we tie it all together with a SequentialSpecification: F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() // Start each test from 0 override _.SetupCommands = [| ResetCommand() |] // The initial model state override _.InitialState = { CurrentCount = Var.symbolic 0 } // How many commands to generate (1-50) override _.Range = Range.linear 1 50 // All available commands override _.Commands = [| IncrementCommand() DecrementCommand() ResetCommand() GetCommand() |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { // Start each test from 0 public override ICommand<Counter, CounterState>[] SetupCommands => [new ResetCommand()]; // The initial model state public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // How many commands to generate (1-50) public override Range<int> Range => Hedgehog.Linq.Range.LinearInt32(1, 50); // All available commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new ResetCommand(), new GetCommand() ]; } Running the Test Finally, we write our test: F# C# [<Fact>] let ``Counter behaves correctly under random operations``() = let sut = Counter() CounterSpec().ToProperty(sut).Check() [Fact] public void CounterBehavesCorrectlyUnderRandomOperations() { var sut = new Counter(); new CounterSpec().ToProperty(sut).Check(); } That's it! When you run this test, Hedgehog will: Generate random sequences of commands (e.g., \"Increment, Increment, Reset, Decrement, Get\") Execute each sequence against your actual counter Verify each operation produces the expected result If any assertion fails, shrink the sequence to find the minimal failing case Example Test Scenarios Here are some sequences Hedgehog might generate: Simple sequence: 1. Reset  expect 0 2. Increment  expect 1 3. Increment  expect 2 4. Get  expect 2 Edge case: 1. Reset  expect 0 2. Decrement  expect -1 3. Decrement  expect -2 4. Reset  expect 0 5. Get  expect 0 Complex sequence: 1. Increment  expect 1 2. Increment  expect 2 3. Decrement  expect 1 4. Increment  expect 2 5. Reset  expect 0 6. Increment  expect 1 If any command returns an unexpected value, Hedgehog will report exactly which sequence caused the failure and shrink it to the smallest reproduction case. Testing new behaviours Let's assume that now Counter adds a new API method Set: F# C# type Counter() = member _.Set(n: int) = value <- n // the rest of the members public sealed class Counter { public void Set(int n) => _value = n; // the rest of the members } To test it we need to define some SetCommand: F# C# type SetCommand() = inherit Command<Counter, CounterState, int, int>() override _.Name = \"Set\" override _.Precondition(state) = true override _.Execute(counter, _, value) = counter.Set(value) let result = counter.Get() Task.FromResult(result) // Generate random integers between -10 and 100 override _.Gen _ = Gen.int32 (Range.linearFrom 0 -10 100) override _.Update(_, _, outputVar) = { CurrentCount = outputVar } override _.Ensure(_, _, _, input, result) = result = input public class SetCommand : Command<Counter, CounterState, int, int> { public override string Name => \"Set\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, int value) { sut.Set(value); var result = sut.Get(); return Task.FromResult(result); } // Generate random integers between -10 and 100 public override Gen<int> Generate(CounterState state) => Hedgehog.Linq.Gen.Int32(Range.LinearFromInt32(0, -10, 100)); public override CounterState Update(CounterState state, int input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, int input, int result) { return result == input; // Set should set the exact value } } Then add SetCommand() to your Commands array in the specification. Now Hedgehog will use it in generating sequence and will generate sequences like: 1. Set(42)  expect 42 2. Increment  expect 43 3. Set(-5)  expect -5 4. Get  expect -5 What About Bugs? Let's introduce a bug in our counter to see what happens: F# C# member _.Decrement() = if value > 10 then value <- value - 1 else value <- value - 2 // SIMULATE BUG: decrements by 2 when <= 10 public void Decrement() { if (_value > 10) _value--; else _value -= 2; // SIMULATE BUG: decrements by 2 when <= 10 } When you run the test, Hedgehog will find this bug and report something like: *** Failed! Falsifiable (after 8 tests and 1 shrink): You can reproduce this failure with the following Recheck Seed: \"7_13402950062986702852_14277380902303697685_0\" Generated values: { Initial = CounterState { CurrentCount = 0 (symbolic) } Steps = [Reset ; Decrement ] } Counterexamples: Final state: CounterState { CurrentCount = 0 (symbolic) } + Reset Decrement Hedgehog automatically found the minimal reproduction case: decrement once (you can see \"+ Reset\" in the list because Reset is defined as a Setup step and is always executed first). Summary You've learned how to: Define a model state that represents what you expect Create commands for each operation on your SUT Implement the key methods for each command: Name: for debugging Precondition: to control when the command can be generated Gen: to generate inputs Execute: to run the real operation Update: to update the model state Ensure: to verify correctness Create a specification that ties everything together Run the test and let Hedgehog find bugs automatically The beauty of this approach is that Hedgehog explores hundreds or thousands of different sequences automatically, finding edge cases you might never think to test manually."
  },
  "stateful/index.html": {
    "href": "stateful/index.html",
    "title": "What is stateful testing? | Hedgehog .NET",
    "summary": "What is stateful testing? Most property-based tests check individual operations in isolation: \"if I sort this list, is it actually sorted?\" But real systems have state that changes over time. A user logs in, makes changes, logs out. A door locks and unlocks. A shopping cart adds and removes items. Stateful testing lets you test sequences of actions on systems that maintain state. Instead of testing one operation at a time, you define each possible action as a Command. Hedgehog then generates random sequences of these commands - essentially, complete scenarios of how your system might be used. When something goes wrong, Hedgehog automatically shrinks both the sequence of actions and their parameters to find you the minimal failing case. Imagine testing a login system. Instead of manually writing test cases like \"login, then logout\" or \"login, change password, logout,\" Hedgehog generates hundreds of different sequences and finds edge cases you never thought oflike what happens when you try to change a password twice in a row, or logout when already logged out. Building blocks: Commands Let's build up the idea step by step. We'll use pseudocode to focus on concepts rather than specific syntax. Step 1: Naming your command Every command needs a name for clarity: Command { Name: \"LogIn\" } Step 2: Defining preconditions Here's where stateful testing gets interesting. Not all commands make sense at all times. You can't log out if you're not logged in. You can't lock a door that's already locked. We track this with a model statea simple state representing what we know from interacting with the system. Commands can check this state and decide whether they're allowed to run: Command { Name: \"LogOut\" Precondition(currentState): currentState.isLoggedIn // Only generate when logged in } This way, Hedgehog only generates valid sequences. The LogOut command appears only when the user is logged in (when Precondition returns true). The LockDoor command appears only when the door is unlocked. Step 3: Generating command inputs Just like regular property tests, commands need test data. Each command defines how to generate its input: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() } Step 4: Executing the command Now we need to actually run the command against the real system: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) } The Execute method takes the generated input and performs the actual operation, returning whatever the system returns. Step 5: Updating the model state After executing a command, we need to update our model state to reflect what happened: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) UpdateState(oldState, input, output): oldState with { isLoggedIn: true, username: input.username } } This method takes the old state, the input we used, and the output we got, and produces the new state. Step 6: Making assertions Finally, we need to verify that the system behaved correctly. The Ensure method checks whether everything went as expected: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) UpdateState(oldState, input, output): oldState with { isLoggedIn: true, username: input.username } Ensure(oldState, newState, input, output): assert output.success == true assert output.username == input.username } With both states available, you can make rich assertions: \"after logging in, the user should be logged in,\" \"after adding an item, the cart count should increase by one,\" and so on. Putting it all together Define all your commands (LogIn, LogOut, ChangePassword, etc.), and Hedgehog will: Generate random sequences of commands Check preconditions to ensure valid sequences Execute each command against your real system Update the model state after each command Assert that everything worked correctly If something fails, shrink the sequence to find the minimal reproduction case You get comprehensive testing of complex stateful scenarios with minimal effort, and when bugs appear, you get a short, clear sequence showing exactly how to reproduce them."
  },
  "stateful/require.html": {
    "href": "stateful/require.html",
    "title": "Runtime Preconditions with Require | Hedgehog .NET",
    "summary": "Runtime Preconditions with Require When you generate a test sequence, Hedgehog creates a plan of actions to execute. But what happens when that plan includes references to values that might not exist when execution time arrives? This is where the Require method becomes essential. The Problem: Symbolic Variables as Input Consider a user registry system where commands can look up previously registered users. Your state might track registered user IDs: F# C# type RegistryState = { RegisteredIds: Var<int> list // List of IDs from previous Register commands } public record RegistryState { public List<Var<int>> RegisteredIds { get; init; } = new(); } When generating a LookupUser command, you need to pick an ID from this list: F# C# type LookupUserCommand() = inherit Command<UserRegistry, RegistryState, Var<int>, UserInfo option>() override _.Precondition(state) = not (List.isEmpty state.RegisteredIds) override _.Generate(state) = Gen.item state.RegisteredIds // Returns a Var<int> from the list public class LookupUserCommand : Command<UserRegistry, RegistryState, Var<int>, UserInfo?> { public override bool Precondition(RegistryState state) => state.RegisteredIds.Count > 0; public override Gen<Var<int>> Generate(RegistryState state) => Gen.Element(state.RegisteredIds); // Returns a Var<int> from the list } Notice: Generate returns a Var<int> - a symbolic reference to an ID that some previous command produced. The Hidden Danger: Shrinking Can Leave Variables Unbound Here's the subtle problem. Imagine Hedgehog generates this sequence (which passes): 1. RegisterUser(\"Alice\")  Var 2. RegisterUser(\"Bob\")  Var 3. RegisterUser(\"Charlie\")  Var 4. LookupUser(Var)  succeeds 5. DeleteUser(Var) 6. SomeOtherOperation()  THIS FAILS! The test fails at step 6. Now Hedgehog tries to shrink the sequence to find the minimal failing case. It might try removing step 2: 1. RegisterUser(\"Alice\")  Var [step 2 removed - \"Bob\" never registered] 3. RegisterUser(\"Charlie\")  Var 4. LookupUser(Var)  CRASH! Var is unbound 5. DeleteUser(Var) 6. SomeOtherOperation() What happened? When step 4 was originally generated, the state had [Var, Var] in RegisteredIds Generate picked Var randomly from that list During shrinking, step 2 (which produced Var) was removed Step 4 still has Var as its input, but Var was never bound to a concrete value Without Require, calling Var.Resolve(env) will throw an exception This isn't a problem with the test logicit's a fundamental aspect of how shrinking works. Actions are removed from sequences, but the inputs to remaining actions are fixed when they're generated. The fix: Override Require to check idVar.TryResolve(env, out var _). During shrinking, if the var can't be resolved, Require returns false and the action is skipped (not failed). The shrinking process continues and finds a valid minimal sequence. The Solution: Override Require The Require method is your runtime safety check. Unlike Precondition (which only sees the structural state during generation), Require receives the Env parameter and can resolve symbolic variables to check if they're actually valid. Here's the safe version: F# C# type LookupUserCommand() = inherit Command<UserRegistry, RegistryState, Var<int>, UserInfo option>() override _.Name = \"LookupUser\" // Structural precondition: we need at least one ID in our list override _.Precondition(state) = not (List.isEmpty state.RegisteredIds) // Pick a random ID from the list override _.Generate(state) = Gen.item state.RegisteredIds // Runtime check: can we actually resolve this ID? override _.Require(env, state, idVar) = idVar |> Var.tryResolve env |> Result.isOk override _.Execute(registry, env, state, idVar) = let actualId = idVar.Resolve(env) Task.FromResult(registry.Lookup(actualId)) override _.Ensure(env, oldState, newState, idVar, result) = result.IsSome // Should always find the user public class LookupUserCommand : Command<UserRegistry, RegistryState, Var<int>, UserInfo?> { public override string Name => \"LookupUser\"; // Structural precondition: we need at least one ID in our list public override bool Precondition(RegistryState state) => state.RegisteredIds.Count > 0; // Pick a random ID from the list public override Gen<Var<int>> Generate(RegistryState state) => Gen.Element(state.RegisteredIds); // Runtime check: can we actually resolve this ID? public override bool Require(Env env, RegistryState state, Var<int> idVar) => idVar.TryResolve(env, out var _); // Returns false if not bound yet public override Task<UserInfo?> Execute(UserRegistry sut, Env env, RegistryState state, Var<int> idVar) { var actualId = idVar.Resolve(env); return Task.FromResult(sut.Lookup(actualId)); } public override bool Ensure(Env env, RegistryState oldState, RegistryState newState, Var<int> idVar, UserInfo? result) => result is not null; // Should always find the user } What changes: We override Require to check if idVar can actually be resolved If TryResolve returns false, the command is skipped (not failed!) The test continues with the remaining actions This prevents trying to lookup a user ID that was never actually created. When to Override Require Override Require when: Your Generate returns Var<T> as part of the input - You're selecting from a list of symbolic variables Commands can be skipped - Previous commands might not execute, leaving vars unbound You need runtime value checks - Validate concrete values that weren't available during generation You can skip Require when: Generate returns concrete values only - No symbolic variables in the input Simple preconditions - Structural checks that Precondition already handles All commands always execute - No risk of skipped actions (rare in practice) Best Practices 1. Use TryResolve for Safety Don't use Resolve directly in Require - it throws if the variable isn't bound. In F#, use the idiomatic Var.tryResolve which returns a Result: F# C# override _.Require(env, state, input) = input.SomeVarField |> Var.tryResolve env |> Result.isOk In C#, use TryResolve with an out parameter: public override bool Require(Env env, MyState state, MyInput input) => input.SomeVarField.TryResolve(env, out var _); 2. Check the Symbolic Inputs You Use If your command's input contains Var<T> fields that come from previous command outputs, and your Execute method will resolve them, you should check those in Require: F# C# type TransferInput = { FromAccount: Var<AccountId> // From a previous CreateAccount command ToAccount: Var<AccountId> // From a previous CreateAccount command Amount: decimal } override _.Require(env, state, input) = // Check both vars since Execute will resolve both (input.FromAccount |> Var.tryResolve env |> Result.isOk) && (input.ToAccount |> Var.tryResolve env |> Result.isOk) public record TransferInput { // From previous CreateAccount commands public required Var<AccountId> FromAccount { get; init; } public required Var<AccountId> ToAccount { get; init; } public decimal Amount { get; init; } } public override bool Require(Env env, BankState state, TransferInput input) => // Check both vars since Execute will resolve both input.FromAccount.TryResolve(env, out var _) && input.ToAccount.TryResolve(env, out var _); Important distinctions: Vars from command inputs (produced by Generate picking from state lists): These can become unbound during shrinking and need to be checked in Require Vars in the state (created with Var.symbolic in InitialState): These always have default values and are always resolvable, so they don't need Require checks Only check what you use: Only check the Var<T> fields that your Execute method actually resolves. If your command doesn't use a particular var from the input, you don't need to check it in Require Require vs Precondition It's important to understand the difference between these two methods: Aspect Precondition Require When called During generation & execution Only during execution Has Env?  No - cannot resolve vars  Yes - can resolve vars Purpose Structural check (\"do we have IDs?\") Runtime check (\"can we resolve this ID?\") Return false means Don't generate this command Skip this command (continue test) Check frequency Every candidate command Only generated commands In practice: Use Precondition for structural state checks, and Require for validating symbolic variable inputs. Summary The Rule: If your Generate method returns a Var<T> (or contains one as a part of a generated input), always override Require to check if that variable can be resolved. Why: Commands can be skipped during execution, leaving symbolic variables unbound. Without Require, you'll crash trying to resolve non-existent values. How: Use TryResolve to safely check if a variable is bound before attempting to use it in Execute. This pattern keeps your stateful tests robust and prevents mysterious failures from unresolved symbolic variables."
  },
  "stateful/specifications.html": {
    "href": "stateful/specifications.html",
    "title": "Specifications | Hedgehog .NET",
    "summary": "Specifications Once you've defined your commands, you need a specification that ties everything together. A specification declares: The initial state of your model Which commands are available How many actions to generate Whether to test sequentially or in parallel Hedgehog provides two types of specifications: SequentialSpecification: Tests sequences of operations running one after another ParallelSpecification: Tests concurrent operations to verify linearizability Sequential Specifications Sequential specifications test your system by generating and executing sequences of commands one at a time. This is the most common type of stateful test. Basic Structure F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() // The starting state of your model override _.InitialState = { CurrentCount = Var.symbolic 0 } // How many actions to generate (1 to 10) override _.Range = Range.linear 1 10 // Available commands override _.Commands = [| IncrementCommand() DecrementCommand() ResetCommand() |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { // The starting state of your model public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // How many actions to generate (1 to 10) public override Range<int> Range => Range.Linear(1, 10); // Available commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new ResetCommand() ]; } Running the Test Convert the specification to a property and check it as a regular property: F# C# [<Fact>] let ``Counter behaves correctly``() = // obtain sut somehow let sut = Counter() CounterSpec().ToProperty(sut).Check() [Fact] public void Counter_BehavesCorrectly() { // obtain sut somehow var sut = new Counter(); new CounterSpec().ToProperty(sut).Check(); } Setup and Cleanup Sequential specifications support setup and cleanup commands that run before and after each test sequence: F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() override _.InitialState = { CurrentCount = Var.symbolic 0 } override _.Range = Range.linear 1 10 // Setup runs BEFORE the test sequence override _.SetupCommands = [| InitializeCommand() // e.g., set counter to a random value |] // Main test commands override _.Commands = [| IncrementCommand() DecrementCommand() |] // Cleanup runs AFTER the test sequence override _.CleanupCommands = [| ResetCommand() // e.g., reset counter to 0 |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; public override Range<int> Range => Range.Linear(1, 10); // Setup runs BEFORE the test sequence public override ICommand<Counter, CounterState>[] SetupCommands => [ InitializeCommand() // e.g., set counter to a random value ]; // Main test commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand() ]; // Cleanup runs AFTER the test sequence public override ICommand<Counter, CounterState>[] CleanupCommands => [ new ResetCommand() // e.g., reset counter to 0 ]; } Key points about setup and cleanup: Setup commands execute in order before test commands. Cleanup commands execute in order after test commands. Cleanup runs even if the test fails Both setup and cleanup commands can have their parameters shrink, but they cannot be removed from the sequence during shrinking. Parallel Specifications Parallel specifications test whether your system is linearizablemeaning concurrent operations behave as if they executed in some sequential order. What is Linearizability? When operations run concurrently, they can interfere with each other. A linearizable system guarantees that despite this interference, the results match what could have happened if the operations ran sequentially. For example, if two threads both increment a counter, linearizability ensures the counter increases by 2not 1 (which would indicate a lost update). How Parallel Testing Works Parallel testing has three phases: Sequential Prefix: Run some operations sequentially to set up initial state Parallel Branches: Run two sequences of operations in parallel on the same system Linearizability Check: Verify the results match some interleaving of the operations Basic Structure F# C# type ParallelCounterSpec() = inherit ParallelSpecification<ThreadSafeCounter, CounterState>() // Starting state override _.InitialState = { CurrentCount = Var.symbolic 0 } // Length of sequential prefix (0-3 operations) override _.PrefixRange = Range.linear 0 3 // Length of each parallel branch (1-5 operations each) override _.BranchRange = Range.linear 1 5 // Commands that can run in parallel override _.Commands = [| IncrementCommand() DecrementCommand() GetCommand() |] public class ParallelCounterSpec : ParallelSpecification<ThreadSafeCounter, CounterState> { // Starting state public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // Length of sequential prefix (0-3 operations) public override Range<int> PrefixRange => Range.Linear(0, 3); // Length of each parallel branch (1-5 operations each) public override Range<int> BranchRange => Range.Linear(1, 5); // Commands that can run in parallel public override ICommand<ThreadSafeCounter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new GetCommand() ]; } Running Parallel Tests F# C# [<Fact>] let ``Counter is thread-safe``() = let sut = ThreadSafeCounter() ParallelCounterSpec().ToProperty(sut).Check() [Fact] public void Counter_IsThreadSafe() { var sut = new ThreadSafeCounter(); new ParallelCounterSpec().ToProperty(sut).Check(); } Important: Sharing the SUT The same SUT instance is intentionally shared between parallel branches. This is not a bug - it's the whole point! We want operations to interfere with each other because we're testing whether the system handles concurrent access correctly. If the system is properly thread-safe, all results will be linearizable. If it has concurrency bugs, some test runs will produce results that can't be explained by any sequential ordering. Writing Commands for Parallel Testing When writing commands for parallel testing, remember: Preconditions and Require still check the model state Ensure should verify weak postconditionslinearizability checking handles the strong guarantees Return values matterthe framework uses them to verify linearizability Example of a weak postcondition in parallel context: F# C# type IncrementCommand() = inherit Command<ThreadSafeCounter, CounterState, unit, int>() override _.Name = \"Increment\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = Task.FromResult(counter.Increment()) override _.Generate(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } // Weak postcondition: we can't assert the exact value // Linearizability checking verifies the sequence is valid override _.Ensure(env, oldState, newState, input, result) = result > 0 // After increment, should be positive public class IncrementCommand : Command<ThreadSafeCounter, CounterState, NoInput, int> { public override string Name => \"Increment\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(ThreadSafeCounter sut, Env env, CounterState state, NoInput input) => Task.FromResult(sut.Increment()); public override Gen<NoInput> Generate(CounterState state) => Gen.Constant(NoInput.Value); public override CounterState Update(CounterState state, NoInput input, Var<int> outputVar) => state with { CurrentCount = outputVar }; // Weak postcondition: we can't assert the exact value // Linearizability checking verifies the sequence is valid public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) => result > 0; // After increment, should be positive } Setup and Cleanup in Parallel Tests Parallel specifications also support setup and cleanup: F# C# type ParallelCounterSpec() = inherit ParallelSpecification<ThreadSafeCounter, CounterState>() override _.InitialState = { CurrentCount = Var.symbolic 0 } override _.PrefixRange = Range.linear 0 3 override _.BranchRange = Range.linear 1 5 // Setup runs BEFORE prefix and parallel branches override _.SetupCommands = [| InitializeCommand() |] override _.Commands = [| IncrementCommand() DecrementCommand() |] // Cleanup runs AFTER parallel branches complete override _.CleanupCommands = [| ResetCommand() |] public class ParallelCounterSpec : ParallelSpecification<ThreadSafeCounter, CounterState> { public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; public override Range<int> PrefixRange => Range.Linear(0, 3); public override Range<int> BranchRange => Range.Linear(1, 5); // Setup runs BEFORE prefix and parallel branches public override ICommand<ThreadSafeCounter, CounterState>[] SetupCommands => [ new InitializeCommand() ]; public override ICommand<ThreadSafeCounter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand() ]; // Cleanup runs AFTER parallel branches complete public override ICommand<ThreadSafeCounter, CounterState>[] CleanupCommands => [ new ResetCommand() ]; } Note: Cleanup is generated using the state after the prefix (before parallel execution), since the parallel branches can't be used to predict a single final state. But it is executed at the end of the whole sequence. Using Fresh SUTs Instead of creating the SUT yourself and passing it to the specification, you can provide a factory function that creates a fresh SUT for each test run: F# C# [<Fact>] let ``Counter test with fresh SUT``() = // Factory creates a new Counter for each test let createSut() = Counter() CounterSpec().ToPropertyWith(createSut).Check() [Fact] public void Counter_TestWithFreshSUT() { // Factory creates a new Counter for each test Func<Counter> createSut = () => new Counter(); new CounterSpec().ToPropertyWith(createSut).Check(); } This approach ensures test isolationeach test run gets a completely fresh system. Summary Sequential Specifications: Test operations running one after another Use SequentialSpecification<TSystem, TState> Define InitialState, Range, and Commands Optionally add SetupCommands and CleanupCommands Parallel Specifications: Test concurrent operations for linearizability Use ParallelSpecification<TSystem, TState> Define InitialState, PrefixRange, BranchRange, and Commands The same SUT is intentionally shared between parallel branches Linearizability checking verifies results match some sequential interleaving Optionally add SetupCommands and CleanupCommands Both specifications provide: Automatic shrinking of test sequences Setup/cleanup command support Clear failure reporting Integration with property-based testing frameworks"
  },
  "xunit/attributes.html": {
    "href": "xunit/attributes.html",
    "title": "Generator Attributes | Hedgehog .NET",
    "summary": "Generator Attributes Hedgehog.Xunit provides a collection of built-in attributes that make it easy to generate test data for your property-based tests. These attributes inherit from GenAttribute<'T> and can be applied directly to test method parameters. Why Use Generator Attributes? Generator attributes provide a declarative, reusable way to specify test data generation. They offer several key benefits: Readability and Intent: Attributes make your test's data requirements immediately visible in the method signature. Instead of scrolling through generator setup code, you can see at a glance that a parameter needs to be a positive integer or a valid email address. Reusability: Define a generator once as an attribute, then reuse it across multiple tests. This eliminates duplication and ensures consistency in how you generate specific types of data throughout your test suite. Composability: Combine multiple attributes in a single test to generate complex test scenarios. Each parameter can have its own specialized generator without cluttering your test logic. Discoverability: Built-in attributes serve as documentation, showing what kinds of constrained data generation are available. When you need a specific type of data, you can often find an existing attribute rather than writing a custom generator. Separation of Concerns: Keep your test logic focused on the property being tested, while data generation concerns are handled declaratively through attributes. When to Create Custom Attributes Consider creating your own GenAttribute when you: Need to generate domain-specific types (e.g., valid credit card numbers, postal codes, product SKUs) Have generation logic that's reused across multiple tests Want to make test signatures more self-documenting Need parameterized generators with sensible defaults Basic Usage Instead of manually creating generators, you can use attributes to declaratively specify what kind of data you want: F# C# open Hedgehog.Xunit open Xunit [<Property>] let ``reversing a list twice returns the original`` ([<PositiveInt>] length: int) = let list = List.init length id let reversed = List.rev (List.rev list) list = reversed using Hedgehog.Xunit; using Xunit; public class ListTests { [Property] public bool ReversingListTwiceReturnsOriginal([PositiveInt] int length) { var list = Enumerable.Range(0, length).ToList(); var reversed = list.AsEnumerable().Reverse().Reverse().ToList(); return list.SequenceEqual(reversed); } } Available Attributes Numeric Attributes Int Attribute Generates integers within a specified range using linear distribution. F# C# // With custom range [<Property>] let ``dice roll`` ([<Int(1, 6)>] roll: int) = roll >= 1 && roll <= 6 // Percentage range [<Property>] let ``percentage values`` ([<Int(0, 100)>] percentage: int) = percentage >= 0 && percentage <= 100 // With custom range [Property] public bool DiceRoll([Int(1, 6)] int roll) { return roll >= 1 && roll <= 6; } // Percentage range [Property] public bool PercentageValues([Int(0, 100)] int percentage) { return percentage >= 0 && percentage <= 100; } Odd and Even Attributes Generate odd or even integers within a specified range. F# C# [<Property>] let ``odd numbers are not divisible by 2`` ([<Odd>] n: int) = n % 2 <> 0 [<Property>] let ``even numbers are divisible by 2`` ([<Even>] n: int) = n % 2 = 0 // With custom range [<Property>] let ``small odd numbers`` ([<Odd(1, 100)>] n: int) = n >= 1 && n <= 100 && n % 2 <> 0 [Property] public bool OddNumbersAreNotDivisibleBy2([Odd] int n) { return n % 2 != 0; } [Property] public bool EvenNumbersAreDivisibleBy2([Even] int n) { return n % 2 == 0; } // With custom range [Property] public bool SmallOddNumbers([Odd(1, 100)] int n) { return n >= 1 && n <= 100 && n % 2 != 0; } PositiveInt Attribute Generates positive integers (greater than 0). F# C# [<Property>] let ``positive integers are greater than zero`` ([<PositiveInt>] n: int) = n > 0 // With custom maximum [<Property>] let ``small positive integers`` ([<PositiveInt(100)>] n: int) = n > 0 && n <= 100 [Property] public bool PositiveIntegersAreGreaterThanZero([PositiveInt] int n) { return n > 0; } // With custom maximum [Property] public bool SmallPositiveIntegers([PositiveInt(100)] int n) { return n > 0 && n <= 100; } NonNegativeInt Attribute Generates non-negative integers (greater than or equal to 0). F# C# [<Property>] let ``array length is non-negative`` ([<NonNegativeInt>] length: int) = let arr = Array.zeroCreate length arr.Length >= 0 [Property] public bool ArrayLengthIsNonNegative([NonNegativeInt] int length) { var arr = new int[length]; return arr.Length >= 0; } NonZeroInt Attribute Generates integers that are not zero. F# C# [<Property>] let ``division by non-zero is safe`` ([<NonZeroInt>] divisor: int) = let result = 100 / divisor true // Won't throw DivideByZeroException [Property] public bool DivisionByNonZeroIsSafe([NonZeroInt] int divisor) { var result = 100 / divisor; return true; // Won't throw DivideByZeroException } String Attributes Identifier Attribute Generates valid programming identifiers. F# C# [<Property>] let ``identifiers start with letter or underscore`` ([<Identifier>] id: string) = let firstChar = id.[0] Char.IsLetter(firstChar) || firstChar = '_' // With custom max length [<Property>] let ``short identifiers`` ([<Identifier(10)>] id: string) = id.Length <= 10 [Property] public bool IdentifiersStartWithLetterOrUnderscore([Identifier] string id) { var firstChar = id[0]; return char.IsLetter(firstChar) || firstChar == '_'; } // With custom max length [Property] public bool ShortIdentifiers([Identifier(10)] string id) { return id.Length <= 10; } LatinName Attribute Generates human-readable Latin names. F# C# [<Property>] let ``names are capitalized`` ([<LatinName>] name: string) = Char.IsUpper(name.[0]) [Property] public bool NamesAreCapitalized([LatinName] string name) { return char.IsUpper(name[0]); } SnakeCase and KebabCase Attributes Generate strings in snake_case or kebab-case format. F# C# [<Property>] let ``snake case uses underscores`` ([<SnakeCase>] s: string) = not (s.Contains(\"-\")) [<Property>] let ``kebab case uses hyphens`` ([<KebabCase>] s: string) = not (s.Contains(\"_\")) // With custom parameters (maxWordLength, maxWordsCount) [<Property>] let ``short snake case`` ([<SnakeCase(3, 2)>] s: string) = true [Property] public bool SnakeCaseUsesUnderscores([SnakeCase] string s) { return !s.Contains(\"-\"); } [Property] public bool KebabCaseUsesHyphens([KebabCase] string s) { return !s.Contains(\"_\"); } // With custom parameters (maxWordLength, maxWordsCount) [Property] public bool ShortSnakeCase([SnakeCase(3, 2)] string s) { return true; } AlphaNumString Attribute Generates strings containing only alphanumeric characters. F# C# [<Property>] let ``alphanumeric strings contain no special chars`` ([<AlphaNumString>] s: string) = s |> Seq.forall Char.IsLetterOrDigit // With length constraints (minLength, maxLength) [<Property>] let ``bounded alphanumeric`` ([<AlphaNumString(5, 20)>] s: string) = s.Length >= 5 && s.Length <= 20 [Property] public bool AlphanumericStringsContainNoSpecialChars([AlphaNumString] string s) { return s.All(char.IsLetterOrDigit); } // With length constraints (minLength, maxLength) [Property] public bool BoundedAlphanumeric([AlphaNumString(5, 20)] string s) { return s.Length >= 5 && s.Length <= 20; } UnicodeString Attribute Generates strings with Unicode characters. F# C# [<Property>] let ``unicode strings can contain emoji`` ([<UnicodeString(1, 50)>] s: string) = s.Length >= 1 && s.Length <= 50 [Property] public bool UnicodeStringsCanContainEmoji([UnicodeString(1, 50)] string s) { return s.Length >= 1 && s.Length <= 50; } Network Attributes DomainName Attribute Generates valid domain names. F# C# [<Property>] let ``domain names contain dots`` ([<DomainName>] domain: string) = domain.Contains(\".\") [Property] public bool DomainNamesContainDots([DomainName] string domain) { return domain.Contains(\".\"); } Email Attribute Generates valid email addresses. F# C# [<Property>] let ``emails contain @ symbol`` ([<Email>] email: string) = email.Contains(\"@\") [Property] public bool EmailsContainAtSymbol([Email] string email) { return email.Contains(\"@\"); } Ipv4Address and Ipv6Address Attributes Generate IP addresses (IPv4 or IPv6). F# C# open System.Net [<Property>] let ``IPv4 addresses are valid`` ([<Ipv4Address>] ip: IPAddress) = ip.AddressFamily = Sockets.AddressFamily.InterNetwork [<Property>] let ``IPv6 addresses are valid`` ([<Ipv6Address>] ip: IPAddress) = ip.AddressFamily = Sockets.AddressFamily.InterNetworkV6 using System.Net; using System.Net.Sockets; [Property] public bool IPv4AddressesAreValid([Ipv4Address] IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetwork; } [Property] public bool IPv6AddressesAreValid([Ipv6Address] IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetworkV6; } Date and Time Attributes DateTime Attribute Generates DateTime values. F# C# open System [<Property>] let ``dates are in default range`` ([<DateTime>] dt: DateTime) = dt >= DateTime(2000, 1, 1) && dt < DateTime(2010, 1, 1) // With custom range (from, duration) [<Property>] let ``recent dates`` ([<DateTime(DateTime(2020, 1, 1), TimeSpan.FromDays(365))>] dt: DateTime) = dt.Year >= 2020 // With specific DateTimeKind [<Property>] let ``UTC dates`` ([<DateTime(DateTimeKind.Utc)>] dt: DateTime) = dt.Kind = DateTimeKind.Utc using System; [Property] public bool DatesAreInDefaultRange([DateTime] DateTime dt) { return dt >= new DateTime(2000, 1, 1) && dt < new DateTime(2010, 1, 1); } // With custom range (from, duration) [Property] public bool RecentDates([DateTime(typeof(DateTime), \"2020-01-01\", \"365.00:00:00\")] DateTime dt) { return dt.Year >= 2020; } // With specific DateTimeKind [Property] public bool UtcDates([DateTime(DateTimeKind.Utc)] DateTime dt) { return dt.Kind == DateTimeKind.Utc; } DateTimeOffset Attribute Generates DateTimeOffset values. F# C# [<Property>] let ``date offsets preserve timezone`` ([<DateTimeOffset>] dto: DateTimeOffset) = dto.Offset.TotalHours >= -14.0 && dto.Offset.TotalHours <= 14.0 [Property] public bool DateOffsetsPreserveTimezone([DateTimeOffset] DateTimeOffset dto) { return dto.Offset.TotalHours >= -14.0 && dto.Offset.TotalHours <= 14.0; } Combining Multiple Attributes You can use multiple attributes in a single test to generate different types of data: F# C# [<Property>] let ``user registration with generated data`` ([<Identifier>] username: string) ([<Email>] email: string) ([<PositiveInt(150)>] age: int) ([<LatinName>] firstName: string) ([<LatinName>] lastName: string) = // Test user registration logic let user = createUser username email age firstName lastName user.Username = username && user.Email = email && user.Age > 0 [Property] public bool UserRegistrationWithGeneratedData( [Identifier] string username, [Email] string email, [PositiveInt(150)] int age, [LatinName] string firstName, [LatinName] string lastName) { // Test user registration logic var user = CreateUser(username, email, age, firstName, lastName); return user.Username == username && user.Email == email && user.Age > 0; } Creating Custom Attributes You can create your own generator attributes by inheriting from GenAttribute<'T>: F# C# open Hedgehog open Hedgehog.FSharp /// Generates a valid US phone number type UsPhoneNumberAttribute() = inherit GenAttribute<string>() override _.Generator = gen { let! areaCode = Gen.int32 (Range.constant 200 999) let! exchange = Gen.int32 (Range.constant 200 999) let! number = Gen.int32 (Range.constant 0 9999) return sprintf \"(%03d) %03d-%04d\" areaCode exchange number } [<Property>] let ``phone numbers are formatted correctly`` ([<UsPhoneNumber>] phone: string) = phone.Length = 14 && phone.[0] = '(' && phone.[4] = ')' using Hedgehog; using Hedgehog.Linq; using Range = Hedgehog.Linq.Range; /// <summary>Generates a valid US phone number</summary> public class UsPhoneNumberAttribute : GenAttribute<string> { public override Gen<string> Generator => from areaCode in Gen.Int32(Range.Constant(200, 999)) from exchange in Gen.Int32(Range.Constant(200, 999)) from number in Gen.Int32(Range.Constant(0, 9999)) select $\"({areaCode:000}) {exchange:000}-{number:0000}\"; } [Property] public bool PhoneNumbersAreFormattedCorrectly([UsPhoneNumber] string phone) { return phone.Length == 14 && phone[0] == '(' && phone[4] == ')'; } Best Practices Use Specific Attributes: Choose the most specific attribute for your needs (e.g., [<PositiveInt>] instead of [<NonNegativeInt>] when you need values > 0) Set Reasonable Ranges: Use constructor parameters to limit ranges to realistic values for your domain Combine with Property Attribute: Always use generator attributes with [<Property>] or [<Properties>] attributes Document Custom Attributes: When creating custom attributes, add XML documentation to explain what they generate"
  },
  "xunit/best-practices.html": {
    "href": "xunit/best-practices.html",
    "title": "Best Practices | Hedgehog .NET",
    "summary": "Best Practices This page provides tips for effective property-based testing with xUnit integration. Start Simple Begin with simple [<Property>] attributes and auto-generated data. Only add custom configuration when you need it. F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``basic property`` (x: int) (y: int) = x + y = y + x using Hedgehog.Xunit; public class BasicTests { [Property] public bool BasicProperty(int x, int y) { return x + y == y + x; } } Use Descriptive Test Names Good test names describe the property being tested: F# C# [<Property>] let ``addition is commutative`` (x: int) (y: int) = x + y = y + x [<Property>] let ``reversing twice gives original list`` (xs: int list) = List.rev (List.rev xs) = xs using Hedgehog.Xunit; using System.Linq; public class PropertyTests { [Property] public bool AdditionIsCommutative(int x, int y) { return x + y == y + x; } [Property] public bool ReversingTwiceGivesOriginalList(int[] xs) { return xs.Reverse().Reverse().SequenceEqual(xs); } } Use Module/Class Level Config for Related Tests Group related tests with similar configuration needs. This is particularly useful for sharing AutoGenConfig settings or test counts across multiple related properties: F# C# open Hedgehog open Hedgehog.Xunit [<Properties(1000<tests>, AutoGenConfig = \"autoGenConfig\")>] module ``Performance critical properties`` = let autoGenConfig = AutoGenConfig.defaults |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 1000)) [<Property>] let ``property 1`` (x: int) = x + 1 > x [<Property>] let ``property 2`` (x: int) = x * 2 >= x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Properties(Tests = 1000, AutoGenConfig = nameof(AutoGenConfig))] public class PerformanceCriticalProperties { public static IAutoGenConfig AutoGenConfig { get; } = Hedgehog.AutoGenConfig.defaults .AddGenerator(Gen.Int32(Range.Constant(1, 1000))); [Property] public bool Property1(int x) => x + 1 > x; [Property] public bool Property2(int x) => x * 2 >= x; } Comparison with Manual Integration F# C# Without Hedgehog.Xunit: open Xunit open Hedgehog open Hedgehog.FSharp [<Fact>] let ``manual property test`` () = property { let! xs = Gen.list (Range.linear 0 100) Gen.int32 return List.rev (List.rev xs) = xs } |> Property.check With Hedgehog.Xunit: open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``automatic property test`` (xs: int list) = List.rev (List.rev xs) = xs Without Hedgehog.Xunit: using Xunit; using Hedgehog; using Hedgehog.Linq; using System.Linq; public class ManualTests { [Fact] public void ManualPropertyTest() { var property = from xs in Gen.Int32().List(Range.Linear(0, 100)) select xs.Reverse().Reverse().SequenceEqual(xs); property.Check(); } } With Hedgehog.Xunit: using Hedgehog.Xunit; using System.Linq; public class AutomaticTests { [Property] public bool AutomaticPropertyTest(int[] xs) { return xs.Reverse().Reverse().SequenceEqual(xs); } } The [<Property>] attribute eliminates boilerplate while providing more features like rechecking, custom generators per parameter, and class/module-level configuration."
  },
  "xunit/configuration.html": {
    "href": "xunit/configuration.html",
    "title": "Configuration | Hedgehog .NET",
    "summary": "Configuration This page covers how to configure property tests using the Property and Properties attributes. Test Parameters Number of Tests Control how many test cases to run: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property(1000<tests>)>] let ``run 1000 times`` (x: int) = x + 0 = x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Property(Tests = 1000)] public bool Run1000Times(int x) { return x + 0 == x; } Number of Shrinks Limit the number of shrinking attempts: F# C# [<Property(100<tests>, 50<shrinks>)>] let ``limited shrinking`` (x: int) = x < 1000 [Property(Tests = 100, Shrinks = 50)] public bool LimitedShrinking(int x) { return x < 1000; } Size Parameter Control the size of generated data: F# C# [<Property(Size = 50)>] let ``with specific size`` (xs: int list) = xs.Length <= 50 [Property(Size = 50)] public bool WithSpecificSize(List<int> xs) { return xs.Count <= 50; } Class and Module Level Configuration Use [<Properties>] to set defaults for all properties in a class or module: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Properties(1000<tests>)>] module ``Fast running tests`` = [<Property>] let ``uses 1000 tests`` (x: int) = x + 0 = x [<Property(500<tests>)>] let ``overrides with 500 tests`` (x: int) = x * 1 = x using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Properties(Tests = 1000)] public class FastRunningTests { [Property] public bool Uses1000Tests(int x) { return x + 0 == x; } [Property(Tests = 500)] public bool OverridesWith500Tests(int x) { return x * 1 == x; } } Individual [<Property>] attributes can override settings from [<Properties>]."
  },
  "xunit/csharp-chatmode.html": {
    "href": "xunit/csharp-chatmode.html",
    "title": "Copilot chatmode for Hedgehog and xUnit | Hedgehog .NET",
    "summary": "Copilot chatmode for Hedgehog and xUnit Hedgehog provides a specialized chatmode for GitHub Copilot to help C# developers write property-based tests. Since Hedgehog is not widely known to AI models, this chatmode includes a comprehensive API reference and property-based testing patterns to guide AI agents in discovering universal properties and generating effective test cases. Download chatmode instructions --- description: 'Expert in property-based testing using Hedgehog.Xunit library in C#. Focuses on discovering universal properties and generating comprehensive test cases through the property-based testing mindset.' tools: ['edit', 'usages', 'changes', 'search', 'fetch', 'problems', 'runCommands', 'vscodeAPI'] --- # Property-Based Testing Agent (Hedgehog.Xunit C#) ## Role & Mission You are a **Property-Based Testing Specialist** who thinks in terms of **universal properties** and **invariants** rather than specific examples. Your mission is to help developers discover and implement property-based tests using the **Hedgehog.Xunit library** in C#, moving beyond example-based testing to find deeper truths about code behavior. ## Hedgehog.Xunit Library Fundamentals ### Core Concepts **[Property] Attribute**: Marks a test method for property-based testing - Method parameters are **automatically generated** using `Gen.Auto<T>()` - Test runs 100 times by default with different generated values - Automatically shrinks failing inputs to minimal case **Generator (`Gen<T>`)**: Used with LINQ syntax for custom generation - Used when creating custom generators via `GenAttribute` - Used in `AutoGenConfig` for global configuration - Built with LINQ query expressions **Shrinking**: Automatically finds minimal failing case - Hedgehog automatically shrinks failing inputs - No manual shrinking configuration needed - Reports the simplest input that reproduces the failure ### Hedgehog.Linq API Quick Reference **Numbers**: `Gen.Int32(range)`, `Gen.Int64(range)`, `Gen.Double(range)`, `Gen.Byte(range)` **Characters** (properties): `Gen.Alpha`, `Gen.Digit`, `Gen.AlphaNumeric`, `Gen.Lower`, `Gen.Upper`, `Gen.Unicode`, `Gen.Ascii` **Strings**: `Gen.Alpha.String(Range.Constant(1, 50))` - Use character gen + `.String(range)` extension.  `Gen.String(...)` does NOT exist. **Collections**: `gen.List(range)`, `gen.Array(range)`, `Gen.Shuffle(collection)` - Extensions on generators.  `Gen.List(...)` and `Gen.Array(...)` do NOT exist. **Choice**: `Gen.Constant(value)`, `Gen.Choice(gen1, gen2, gen3)`, `Gen.Frequency((weight1, gen1), (weight2, gen2))`, `Gen.Item(\"a\", \"b\", \"c\")` **Other**: `Gen.Bool`, `Gen.Guid`, `Gen.Identifier(maxLen)`, `Gen.LatinName(maxLen)`, `Gen.DomainName`, `Gen.Email`, `Gen.Uri`, `Gen.KebabCase(wordLenRange, wordCountRange)`, `Gen.SnakeCase(wordLenRange, wordCountRange)`, `Gen.ShuffleCase(str)` **Critical Pattern**: Generators are composed using LINQ query syntax (`from ... select`) or method chaining (`.Select()`, `.Where()` - avoid where!) ### Essential Hedgehog.Xunit Patterns #### Usings Always include these usings to C# files: ```csharp using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; ``` #### Basic Property Test Structure ```csharp using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; using AwesomeAssertions; public class MyComponentPropertyTests { [Property] public void DoSomething_Should_Always_Hold_Invariant(int x) { var result = DoSomething(x); result.InvariantHolds().Should().BeTrue(); } } ``` #### Built-in GenAttribute Extensions Hedgehog.Xunit provides many ready-to-use GenAttribute extensions. **Check these first before creating custom generators.** **Available Attributes:** - **Numeric**: `[Odd]`, `[Even]`, `[PositiveInt]`, `[NonNegativeInt]`, `[NonZeroInt]`, `[Int(min, max)]` - **String**: `[AlphaNumString]`, `[AlphaNumString(minLength, maxLength)]`, `[UnicodeString(minLength, maxLength)]`, `[Identifier]`, `[LatinName]`, `[SnakeCase]`, `[KebabCase]` - **Network**: `[Email]`, `[DomainName]`, `[Ipv4Address]`, `[Ipv6Address]` ```csharp [Property] public void Example_Using_Built_In_Attributes( [PositiveInt] int positive, [Int(-50, 50)] int ranged, [AlphaNumString(minLength: 5, maxLength: 10)] string alphaNum, [Identifier] string identifier, [Email] string email) { positive.Should().BeGreaterThan(0); ranged.Should().BeInRange(-50, 50); alphaNum.Length.Should().BeInRange(5, 10); identifier.Should().MatchRegex(\"^[a-z][a-zA-Z0-9_]*$\"); email.Should().Contain(\"@\"); } ``` **When to Use Built-in vs Custom:** -  Use built-in for common patterns (positive numbers, emails, identifiers) -  Create custom for domain-specific types (Price, Discount, OrderStatus) or complex compositions #### Custom Generators via GenAttribute When you need more control than auto-generation provides and built-in attributes don't fit your needs: ```csharp // Define a custom generator by extending GenAttribute<T> public class PriceAttribute : GenAttribute<decimal> { public override Gen<decimal> Generator => from x in Gen.Int32(Range.Constant(1, 10000)) select (decimal)x / 100; } public class DiscountAttribute : GenAttribute<decimal> { public override Gen<decimal> Generator => from x in Gen.Int32(Range.Constant(0, 100)) select (decimal)x / 100; } [Property] public void ApplyDiscount_Should_Never_Exceed_Original_Price([Price] decimal price, [Discount] decimal discountPercent) => ApplyDiscount(price, discountPercent).Should().BeLessThanOrEqualTo(price); ``` #### Global Custom Generators via AutoGenConfig For types used across multiple tests: ```csharp public sealed class MyGenerators { // Can generate simple values public static Gen<Name> NameGen() => from s in Gen.Alpha.String(Range.Constant(1, 50)) select new Name(s); // Can generate generic structures receiving other generators from parameters public static Gen<ImmutableList<T>> ImmutableList<T>(Gen<T> valueGen) => from xs in valueGen.List(Range.Constant(0, 100)) select xs.ToImmutableList(); // Can receive other generators from parameters public static Gen<Person> PersonGen(Gen<Name> nameGen, Gen<int> ageGen) => from name in nameGen from age in ageGen select new Person(name, age); } public class MyAutoGenConfig { private static Gen<CustomType> CustomTypeGen => Gen.Int32(Range.Constant(0, 100)).Select(x => new CustomType(x)); public static AutoGenConfig Defaults => AutoGenConfig.Empty .AddGenerator(CustomTypeGen) .AddGenerators<MyGenerators>(); } [Properties(typeof(MyAutoGenConfig))] public sealed class MyTests { public void CustomTypes_Should_Be_Generated_From_GlobalConfig(CustomType ct, ImmutableList<Person> people) { // Uses generators from MyAutoGenConfig } } ``` #### Generator Anti-Patterns to Avoid Using `where` clauses can cause excessive rejection of generated values. **Solution**: Generate only valid values directly, not by filtering.  **Bad** - Filtering rejects many values: ```csharp from x in Gen.Int32(Range.Constant(-1000, 1000)) where x > 0 select x from x in Gen.Int32(Range.Constant(-100, 100)) where x % 2 == 0 select x // rejects 50% of values ```  **Good** - Generate only valid values: ```csharp from x in Gen.Int32(Range.Constant(1, Int32.MaxValue)) select x from x in Gen.Int32(Range.Constant(-100, 100)) select x & ~1 // bitwise operation to make even ``` ## Core Philosophy & Principles ### Property-Based Testing Mindset - **Properties over Examples**: Seek universal truths that hold for all valid inputs - **Generative Thinking**: Think about the *space of all possible inputs*, not just a few cases - **Shrinking for Clarity**: When tests fail, automatically find the minimal failing case - **Specification by Properties**: Properties serve as executable specifications - **Discover, Don't Prescribe**: Let the generator explore the input space systematically - **Essential over Exhaustive**: Focus on minimal, non-overlapping properties that provide unique value ### The Mental Shift from Example-Based Testing | Example-Based Thinking | Property-Based Thinking | |----------------------------------|-----------------------------------------------------| | \"Test with values 1, 5, and 100\" | \"Test with any positive integer\" | | \"Check this specific case\" | \"What's always true?\" | | \"This input gives this output\" | \"What relationship holds between input and output?\" | | \"Cover branches\" | \"Cover invariants and properties\" | ### Core Property Patterns Quick Reference | Pattern | What It Tests | Example | |-----------------------|------------------------------------------------------------------|--------------------------------------------------------------------| | **Invariants** | Properties that always hold about the result | \"Sorting twice = sorting once\", \"List size preserved after map\" | | **Business Rules** | Domain constraints that must never be violated | \"Discount never exceeds price\", \"Age within valid range\" | | **Inverse/Roundtrip** | Operations that undo each other | \"Serialize then deserialize = identity\", \"Encode then decode\" | | **Idempotence** | Applying N times = applying once | \"Normalize(Normalize(x)) = Normalize(x)\", \"ToUpper twice\" | | **Oracle** | Compare against reference/known truth | \"Custom sort = standard library sort\", \"sqrt(x)  x\" | | **Metamorphic** | How output changes with input transformations | \"Double inputs  double output\", \"Reverse twice = original\" | | **Model-Based** | Generate valid output first, derive input that should produce it | \"Generate event -> derive command -> handle it -> assert an event\" | *Full implementations with code examples are in the **Property-Based Testing Strategies** section below.* ## Property Discovery Process ###  MANDATORY: Avoid Overlapping Properties  **Before writing any test code, you MUST follow this workflow:** 1. **Discovery**: List ALL candidate properties from the code 2. **Analysis**: Ensure that the properties are distinct and non-overlapping 3. **Elimination**: Remove overlaps using these criteria: - If property A failing  property B fails: Keep stronger one only - If property A is a special case of B: Keep B only - If same invariant, different wording: Keep clearest one 4. **Proposal**: Present minimal set with justification before implementing ### 1. Understand the Code's Contracts Ask these questions: - What are the **preconditions** (valid inputs)? - What are the **postconditions** (guarantees about outputs)? - What **invariants** must always hold? - What **relationships** exist between inputs and outputs? - Are there any **business rules** that must never be violated? ### 2. Identify Property Categories **Start with the easiest to find:** 1. **Type Properties**: Does it return the expected type? 2. **Boundary Properties**: What happens at edges (empty, zero, max, null)? 3. **Idempotent Properties**: Does doing it twice = doing it once? 4. **Inverse Properties**: Can you undo the operation? 5. **Invariant Properties**: What never changes? 6. **Commutative Properties**: Does order matter? 7. **Business Rule Properties**: What domain rules must hold? ### 3. Design Generators **When to use Auto-Generation (default):** - Primitive types (int, string, bool, etc.) - Simple domain objects with public constructors - Collections of auto-generatable types - Most straightforward test scenarios **When to create Custom Generators:** - Constrained values (positive numbers, valid emails, etc.) - Complex domain objects with invariants - Values with specific business rules - Recursive data structures - Values needing specific distributions **Generator Design Principles:** - **Coverage**: Generate the full input space, including edges - **Relevance**: Focus on valid inputs (test invalid cases separately) - **Composition**: Build complex generators from simple ones using LINQ - **Realistic**: Generate data that resembles production scenarios ### 4. Implement and Iterate 1. **Start Simple**: Begin with auto-generated parameters and the most obvious property 2. **One Property Per Test**: Keep tests focused and clear 3. **Name Descriptively**: Property name should describe what's always true 4. **Add Constraints**: Use custom generators when auto-generation is too broad 5. **Handle Shrinking**: Understand what the minimal failing case tells you 6. **Refine Generators**: Adjust ranges and constraints based on failures ## Property-Based Testing Strategies *These strategies implement the property patterns listed in the philosophy section.* ### Strategy 1: Roundtrip/Inverse Properties **When**: Encode/decode, serialize/deserialize, compress/decompress, encrypt/decrypt ```csharp [Property] public void Serialize_Should_RoundTrip_When_Deserializing(Person person) { var json = JsonSerializer.Serialize(person); var restored = JsonSerializer.Deserialize<Person>(json); restored.Should().BeEquivalentTo(person); } ``` ### Strategy 2: Oracle Properties **When**: You have a reference implementation or mathematical truth to compare against ```csharp [Property] public void CustomSort_Should_Match_StandardSort(List<int> list) { var custom = MyCustomSort(list); var standard = list.OrderBy(x => x).ToList(); custom.Should().BeEquivalentTo(standard); } ``` ### Strategy 3: Invariant Properties **When**: Something must always be true about the result, regardless of input ```csharp [Property] public void Sort_Should_Preserve_All_Elements(List<int> list) { var sorted = list.OrderBy(x => x).ToList(); sorted.Should().HaveCount(list.Count); sorted.Should().Contain(list); } ``` ### Strategy 4: Metamorphic Properties **When**: You know how transforming input should transform output ```csharp [Property] public void DoublingElements_Should_Double_The_Sum(List<int> list) { var originalSum = list.Sum(); var doubledSum = list.Select(x => x * 2).Sum(); doubledSum.Should().Be(originalSum * 2); } ``` ### Strategy 5: Idempotence Properties **When**: Applying operation multiple times has same effect as once ```csharp [Property] public void Normalize_Should_Be_Idempotent(string text) { var once = Normalize(text); var twice = Normalize(once); twice.Should().Be(once); } ``` ### Strategy 6: Business Rule Properties **When**: Domain rules must never be violated ```csharp // Uses PriceAttribute and DiscountAttribute defined earlier [Property] public void ApplyDiscount_Should_Never_Exceed_Original_Price( [Price] decimal price, [Discount] decimal discountPercent) { var discounted = ApplyDiscount(price, discountPercent); discounted.Should().BeLessThanOrEqualTo(price); } ``` ### Strategy 7: Model-Based (Output-First) Properties **When**: You know what valid output looks like and can derive inputs that should produce it **Pattern**: Generate expected output first, derive input that should produce it. Avoids complex preconditions and filtering. **Use Cases**: Encoding/decoding, normalization, commandevent flows, parsers ```csharp [Property] public void CreateAccountCommand_Should_Produce_Expected_Event(AccountCreatedEvent expectedEvent) { // Derive command from event (reverse direction) var command = new CreateAccountCommand(expectedEvent.AccountId, expectedEvent.Name, expectedEvent.InitialBalance); var actualEvent = accountService.Handle(command); actualEvent.Should().BeEquivalentTo(expectedEvent); } ``` ## Common Anti-Patterns to Avoid ### Testing Anti-Patterns  **Testing Implementation Details**: Don't test *how*, test *what*  **Over-Constraining Generators**: Don't make generators so specific that they only produce passing values  **Hidden Assumptions**: Don't assume specific generated values  **Example-Based Thinking**: Don't test for specific values instead of properties  **Ignoring Shrinking Output**: The minimal failing case reveals the real bug  **Too Many Assertions in One Test**: Keep property tests focused on single properties  **Not Using Custom Generators**: Don't rely on auto-generation when domain constraints exist  **Redundant Properties**: Don't create multiple tests that verify the same underlying property in different ways  **Weak Properties Instead of Strong Ones**: Don't write several weak properties when one stronger property would suffice ### Generator Anti-Patterns  **Insufficient Coverage**: Generators that miss important edge cases  **Over-Filtering**: Using `where` that rejects most generated values (>50% rejection)  **Forgetting GenAttribute**: Trying to use LINQ generators in test parameters directly  **Not Inheriting GenAttribute Correctly**: Must override `Generator` property  **Unrealistic Data**: Generating values that would never occur in production ## Property Test Naming Conventions Use: `MethodName_Should_DescribeExpectedBehavior_When_Condition` - Start with method/operation being tested - Use `Should` to clearly state expected behavior - Add `When` clause for conditional properties (optional) - Be specific about the property being verified  **Good**: `Sort_Should_Preserve_All_Elements`, `Serialize_Should_RoundTrip_When_Deserializing`, `ApplyDiscount_Should_Never_Exceed_Original_Price`  **Bad**: `TestSort`, `SerializationWorks`, `PriceTest`, `Check_Something` ## Working Style ### Discovery Questions When analyzing code to test, ask: - \"What's **always true** about the output?\" - \"What **can't possibly happen** if the code is correct?\" - \"What would it mean for this to be **correct**?\" - \"Can I **undo** this operation?\" - \"Does doing this **twice** differ from **once**?\" - \"What **relationships** must hold between input and output?\" - \"What are the **boundaries** between valid and invalid?\" - \"What **business rules** must never be violated?\" - \"Can I rely on **auto-generation** or do I need **custom constraints**?\" ### Communication Style - **Property-First**: Always frame tests as universal properties - **Generator-Aware**: Explain when to use auto-generation vs custom generators - **Pedagogical**: Help developers shift from examples to properties - **Pattern-Based**: Map code patterns to property patterns - **Shrinking-Conscious**: Explain what minimal failing cases reveal - **Attribute-Focused**: Emphasize the `[Property]` attribute with parameters approach - **Fluent Assertions**: Use AwesomeAssertions' fluent syntax for readable, expressive assertions - **Proposal-Driven**: Present analyzed property set for review before generating code ### Hedgehog.Xunit-Specific Guidance - **Parameters are auto-generated by default** - no need for explicit generators unless you need constraints - Use **custom GenAttribute** classes when you need controlled generation - Use **AutoGenConfig** for types that need custom generation across many tests - **LINQ syntax** is used inside GenAttribute generators and AutoGenConfig - The `[Property]` attribute extends `[Fact]`, so it accepts `DisplayName`, `Skip`, `Timeout` - **Shrinking happens automatically** - no configuration needed - Use **AwesomeAssertions** for fluent, expressive assertions with clear failure messages ### Critical Reminders - **Never write LINQ generators in test method bodies** - that's not how Hedgehog.Xunit works - **Parameters are the inputs** - they're automatically generated - **Use GenAttribute<T> for custom generators** - override the `Generator` property - **Auto-generation works for most cases** - only create custom generators when you need constraints - **One property per test method** - keep it focused - **Use AwesomeAssertions (FluentAssertions) for assertions** - provides expressive fluent syntax like `.Should().Be()`, `.Should().BeEquivalentTo()`, `.Should().Contain()`, etc. --- **Core Approach**: Discover universal properties (invariants, business rules, relationships) that must hold true for all valid inputs. Test methods receive generated inputs as parameters, then assert that the property holds for those inputs."
  },
  "xunit/generators.html": {
    "href": "xunit/generators.html",
    "title": "Custom Generators | Hedgehog .NET",
    "summary": "Custom Generators This page covers how to customize data generation using AutoGenConfig and GenAttribute. Using AutoGenConfig For complete control over generation, provide a custom AutoGenConfig: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit type PositiveInts = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 100)) [<Property(typeof<PositiveInts>)>] let ``only positive integers`` (x: int) = x > 0 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; public class PositiveInts { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 100))); } public class MyTests { [Property(AutoGenConfig = typeof(PositiveInts))] public bool OnlyPositiveIntegers(int x) { return x > 0; } } Using GenAttribute For parameter-level control, inherit from GenAttribute: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit type SmallPositiveInt() = inherit GenAttribute<int>() override _.Generator = Gen.int32 (Range.constant 1 20) [<Property>] let ``custom parameter generator`` ([<SmallPositiveInt>] x) = x >= 1 && x <= 20 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; public class SmallPositiveIntAttribute : GenAttribute<int> { public override Gen<int> Generator => Gen.Int32(Range.Constant(1, 20)); } [Property] public bool CustomParameterGenerator([SmallPositiveInt] int x) { return x >= 1 && x <= 20; } Parameter-level generators override any AutoGenConfig settings: F# C# type AlwaysThirteen = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.constant 13) type AlwaysFive() = inherit GenAttribute<int>() override _.Generator = Gen.constant 5 [<Property(typeof<AlwaysThirteen>)>] let ``GenAttribute overrides AutoGenConfig`` ([<AlwaysFive>] i) = i = 5 public class AlwaysThirteen { public static AutoGenConfig Config => AutoGenConfig.Empty.AddGenerator(Gen.Constant(13)); } public class AlwaysFiveAttribute : GenAttribute<int> { public override Gen<int> Generator => Gen.Constant(5); } [Property(AutoGenConfig = typeof(AlwaysThirteen))] public bool GenAttributeOverridesAutoGenConfig([AlwaysFive] int i) { return i == 5; } Understanding AutoGenConfig Layering Hedgehog merges AutoGenConfig settings from multiple levels, creating a layered configuration system: Default generators - Hedgehog's built-in generators for common types (base layer) PropertiesAttribute level - Configurations applied to all properties in a class/module PropertyAttribute level - Configurations for individual property tests GenAttribute level - Generators for specific parameters (highest priority) When merging layers, generators at more specific levels override those from outer levels. For example, if you configure an int generator at the Properties level and another int generator at the Property level, the Property one wins. Why Use AutoGenConfig.empty? When creating custom AutoGenConfig instances, always start with AutoGenConfig.empty rather than AutoGenConfig.defaults: F# C# //  Recommended: Add only what you need type CustomConfig = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 100)) //  Avoid: Contains all default generators type ProblematicConfig = static member __ = AutoGenConfig.defaults // Includes default generators for all types! |> AutoGenConfig.addGenerator (Gen.string (Range.constant 5 10) Gen.alpha) //  Recommended: Add only what you need public class CustomConfig { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 100))); } //  Avoid: Contains all default generators public class ProblematicConfig { public static AutoGenConfig Config => AutoGenConfig.Defaults // Includes default generators for all types! .AddGenerator(Gen.String(Range.Constant(5, 10), Gen.Alpha)); } The problem: When you start with AutoGenConfig.defaults, it includes generators for all built-in types. During merging, these will override any generators configured at outer layers. For example: Properties level configures a custom int generator (1-10) Property level uses AutoGenConfig.defaults.AddGenerator(...) Result: The default int generator (from defaults) overrides your custom one! By starting with AutoGenConfig.empty, you only include the generators you explicitly add. Since defaults are already used as the base layer, there's rarely a reason to start from AutoGenConfig.defaults. Layering Example Here's how configurations merge across levels: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit // Class-level config: integers 1-10 type SmallInts = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant 1 10)) // Method-level config: add string generator type WithStrings = static member __ = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.string (Range.constant 5 10) Gen.alpha) [<Properties(typeof<SmallInts>)>] module ``Layering example`` = [<Property>] let ``uses class-level config`` (x: int) = // x will be 1-10 from SmallInts x >= 1 && x <= 10 [<Property(typeof<WithStrings>)>] let ``merges class and method config`` (x: int) (s: string) = // x still 1-10 from SmallInts (class level) // s is 5-10 chars from WithStrings (method level) x >= 1 && x <= 10 && s.Length >= 5 && s.Length <= 10 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; using Range = Hedgehog.Linq.Range; // Class-level config: integers 1-10 public class SmallInts { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(1, 10))); } // Method-level config: add string generator public class WithStrings { public static AutoGenConfig Config => AutoGenConfig.Empty .AddGenerator(Gen.String(Range.Constant(5, 10), Gen.Alpha)); } [Properties(AutoGenConfig = typeof(SmallInts))] public class LayeringExample { [Property] public bool UsesClassLevelConfig(int x) { // x will be 1-10 from SmallInts return x >= 1 && x <= 10; } [Property(AutoGenConfig = typeof(WithStrings))] public bool MergesClassAndMethodConfig(int x, string s) { // x still 1-10 from SmallInts (class level) // s is 5-10 chars from WithStrings (method level) return x >= 1 && x <= 10 && s.Length >= 5 && s.Length <= 10; } } Working with AutoGenConfig Arguments For more dynamic configurations, you can pass arguments to your AutoGenConfig: F# C# type ConfigWithArgs = static member __ (minValue: int) (maxValue: int) = AutoGenConfig.empty |> AutoGenConfig.addGenerator (Gen.int32 (Range.constant minValue maxValue)) [<Property( AutoGenConfig = typeof<ConfigWithArgs>, AutoGenConfigArgs = [|10; 20|])>] let ``uses config arguments`` (x: int) = x >= 10 && x <= 20 public class ConfigWithArgs { public static AutoGenConfig Config(int minValue, int maxValue) => AutoGenConfig.Empty .AddGenerator(Gen.Int32(Range.Constant(minValue, maxValue))); } [Property( AutoGenConfig = typeof(ConfigWithArgs), AutoGenConfigArgs = new object[] { 10, 20 })] public bool UsesConfigArguments(int x) { return x >= 10 && x <= 20; }"
  },
  "xunit/index.html": {
    "href": "xunit/index.html",
    "title": "xUnit Integration | Hedgehog .NET",
    "summary": "xUnit Integration The Hedgehog.Xunit package provides seamless integration with xUnit, making it easy to write property-based tests that fit naturally into your existing xUnit test suite. Note We integrate with xUnit V3, so please make sure that your test project references xunit.v3 nuget package the older xunit. Installation Install Hedgehog.Xunit from NuGet: dotnet add package Hedgehog.Xunit.v3 Quick Start The simplest way to write a property test with xUnit is to use the [<Property>] attribute: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``reverse twice is identity`` (xs: int list) = List.rev (List.rev xs) = xs using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; public class MyTests { [Property] public bool ReverseTwiceIsIdentity(List<int> xs) { return xs.AsEnumerable().Reverse().Reverse().SequenceEqual(xs); } } The Property attribute automatically: Generates test data for all parameters Runs the property 100 times by default Shrinks failing cases to minimal examples Reports results through xUnit's test runner Property Return Types Properties can return various types to indicate success or failure: Supported return types: bool - false indicates failure unit / void - any exception indicates failure Result<'T, 'Error> (F#) - Error case indicates failure Property<unit> / Property<bool> (F#) - for using the property computation expression Task, Task<bool>, Task<T> - async versions of the above Async<unit>, Async<bool>, Async<Result<'T, 'Error>> (F#) - F# async versions"
  },
  "xunit/rechecking.html": {
    "href": "xunit/rechecking.html",
    "title": "Rechecking Failures | Hedgehog .NET",
    "summary": "Rechecking Failures When a property fails, Hedgehog provides recheck data that allows you to reproduce the exact failure. This is invaluable for debugging and creating regression tests. Using the Recheck Attribute When a property test fails, Hedgehog outputs recheck data that you can use to reproduce the failure: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Xunit [<Property>] let ``might fail`` (x: int) = x < 1000 // When the above fails, Hedgehog outputs: // *** Failed! Falsifiable (after 45 tests and 3 shrinks): // 1000 // This failure can be reproduced by running: // > Property.recheck \"0_16700074754810023652_2867022503662193831_\" // Use the recheck string to reproduce the exact failure: [<Property>] [<Recheck(\"0_16700074754810023652_2867022503662193831_\")>] let ``reproduce the failure`` (x: int) = x < 1000 using Hedgehog; using Hedgehog.Linq; using Hedgehog.Xunit; [Property] public bool MightFail(int x) { return x < 1000; } // When the above fails, Hedgehog outputs: // *** Failed! Falsifiable (after 45 tests and 3 shrinks): // 1000 // This failure can be reproduced by running: // > Property.recheck \"0_16700074754810023652_2867022503662193831_\" // Use the recheck string to reproduce the exact failure: [Property] [Recheck(\"0_16700074754810023652_2867022503662193831_\")] public bool ReproduceTheFailure(int x) { return x < 1000; } The Recheck attribute runs the test exactly once with the specific seed and shrink path that caused the original failure, making it a perfect regression test."
  }
}