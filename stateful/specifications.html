<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Specifications | Hedgehog .NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Specifications | Hedgehog .NET ">
      
      
      <link rel="icon" href="../images/favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/hedgehogqa/fsharp-hedgehog/blob/master/docs/stateful/specifications.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Hedgehog .NET">
            Hedgehog .NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="">
<h1 id="specifications">Specifications</h1>

<p>Once you've defined your commands, you need a <strong>specification</strong> that ties everything together. A specification declares:</p>
<ul>
<li>The initial state of your model</li>
<li>Which commands are available</li>
<li>How many actions to generate</li>
<li>Whether to test sequentially or in parallel</li>
</ul>
<p>Hedgehog provides two types of specifications:</p>
<ul>
<li><strong>SequentialSpecification</strong>: Tests sequences of operations running one after another</li>
<li><strong>ParallelSpecification</strong>: Tests concurrent operations to verify linearizability</li>
</ul>
<h2 id="sequential-specifications">Sequential Specifications</h2>
<p>Sequential specifications test your system by generating and executing sequences of commands one at a time. This is the most common type of stateful test.</p>
<h3 id="basic-structure">Basic Structure</h3>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_fsharp" role="tab" aria-controls="tabpanel_1_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_csharp" role="tab" aria-controls="tabpanel_1_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_1_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">type CounterSpec() =
    inherit SequentialSpecification&lt;Counter, CounterState&gt;()
    
    // The starting state of your model
    override _.InitialState = { CurrentCount = Var.symbolic 0 }
    
    // How many actions to generate (1 to 10)
    override _.Range = Range.linear 1 10
    
    // Available commands
    override _.Commands = [|
        IncrementCommand()
        DecrementCommand()
        ResetCommand()
    |]
</code></pre>
</section>
<section id="tabpanel_1_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class CounterSpec : SequentialSpecification&lt;Counter, CounterState&gt;
{
    // The starting state of your model
    public override CounterState InitialState =&gt; 
        new() { CurrentCount = Var.Symbolic(0) };
    
    // How many actions to generate (1 to 10)
    public override Range&lt;int&gt; Range =&gt; Range.Linear(1, 10);
    
    // Available commands
    public override ICommand&lt;Counter, CounterState&gt;[] Commands =&gt; 
        [
            new IncrementCommand(),
            new DecrementCommand(),
            new ResetCommand()
        ];
}
</code></pre>
</section>
</div>
<h3 id="running-the-test">Running the Test</h3>
<p>Convert the specification to a property and check it as a regular property:</p>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_fsharp" role="tab" aria-controls="tabpanel_2_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_csharp" role="tab" aria-controls="tabpanel_2_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_2_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">[&lt;Fact&gt;]
let ``Counter behaves correctly``() =
    // obtain sut somehow
    let sut = Counter()
    CounterSpec().ToProperty(sut).Check()
</code></pre>
</section>
<section id="tabpanel_2_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">[Fact]
public void Counter_BehavesCorrectly()
{
    // obtain sut somehow
    var sut = new Counter();
    new CounterSpec().ToProperty(sut).Check();
}
</code></pre>
</section>
</div>
<h3 id="setup-and-cleanup">Setup and Cleanup</h3>
<p>Sequential specifications support setup and cleanup commands that run before and after each test sequence:</p>
<div class="tabGroup" id="tabgroup_3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_3_fsharp" role="tab" aria-controls="tabpanel_3_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_3_csharp" role="tab" aria-controls="tabpanel_3_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_3_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">type CounterSpec() =
    inherit SequentialSpecification&lt;Counter, CounterState&gt;()
    
    override _.InitialState = { CurrentCount = Var.symbolic 0 }
    override _.Range = Range.linear 1 10
    
    // Setup runs BEFORE the test sequence
    override _.SetupCommands = [|
        InitializeCommand()  // e.g., set counter to a random value
    |]
    
    // Main test commands
    override _.Commands = [|
        IncrementCommand()
        DecrementCommand()
    |]
    
    // Cleanup runs AFTER the test sequence
    override _.CleanupCommands = [|
        ResetCommand()  // e.g., reset counter to 0
    |]
</code></pre>
</section>
<section id="tabpanel_3_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class CounterSpec : SequentialSpecification&lt;Counter, CounterState&gt;
{
    public override CounterState InitialState =&gt; 
        new() { CurrentCount = Var.Symbolic(0) };
    
    public override Range&lt;int&gt; Range =&gt; Range.Linear(1, 10);
    
    // Setup runs BEFORE the test sequence
    public override ICommand&lt;Counter, CounterState&gt;[] SetupCommands =&gt; 
        [ 
            InitializeCommand()  // e.g., set counter to a random value
        ];
    
    // Main test commands
    public override ICommand&lt;Counter, CounterState&gt;[] Commands =&gt; 
        [
            new IncrementCommand(),
            new DecrementCommand()
        ];
    
    // Cleanup runs AFTER the test sequence
    public override ICommand&lt;Counter, CounterState&gt;[] CleanupCommands =&gt; 
        [
            new ResetCommand()  // e.g., reset counter to 0
        ];
}
</code></pre>
</section>
</div>

<p><strong>Key points about setup and cleanup:</strong></p>
<ul>
<li>Setup commands execute <strong>in order</strong> before test commands.</li>
<li>Cleanup commands execute <strong>in order</strong> after test commands.</li>
<li>Cleanup runs <strong>even if the test fails</strong></li>
<li>Both setup and cleanup commands can have their <strong>parameters shrink</strong>, but they cannot be removed from the sequence during shrinking.</li>
</ul>
<h2 id="parallel-specifications">Parallel Specifications</h2>
<p>Parallel specifications test whether your system is <strong>linearizable</strong>—meaning concurrent operations behave as if they executed in <em>some</em> sequential order.</p>
<h3 id="what-is-linearizability">What is Linearizability?</h3>
<p>When operations run concurrently, they can interfere with each other. A linearizable system guarantees that despite this interference, the results match what <em>could have happened</em> if the operations ran sequentially.</p>
<p>For example, if two threads both increment a counter, linearizability ensures the counter increases by 2—not 1 (which would indicate a lost update).</p>
<h3 id="how-parallel-testing-works">How Parallel Testing Works</h3>
<p>Parallel testing has three phases:</p>
<ol>
<li><strong>Sequential Prefix</strong>: Run some operations sequentially to set up initial state</li>
<li><strong>Parallel Branches</strong>: Run two sequences of operations <strong>in parallel</strong> on the same system</li>
<li><strong>Linearizability Check</strong>: Verify the results match <em>some</em> interleaving of the operations</li>
</ol>
<h3 id="basic-structure-1">Basic Structure</h3>
<div class="tabGroup" id="tabgroup_4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_4_fsharp" role="tab" aria-controls="tabpanel_4_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_4_csharp" role="tab" aria-controls="tabpanel_4_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_4_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">type ParallelCounterSpec() =
    inherit ParallelSpecification&lt;ThreadSafeCounter, CounterState&gt;()
    
    // Starting state
    override _.InitialState = { CurrentCount = Var.symbolic 0 }
    
    // Length of sequential prefix (0-3 operations)
    override _.PrefixRange = Range.linear 0 3
    
    // Length of each parallel branch (1-5 operations each)
    override _.BranchRange = Range.linear 1 5
    
    // Commands that can run in parallel
    override _.Commands = [|
        IncrementCommand()
        DecrementCommand()
        GetCommand()
    |]
</code></pre>
</section>
<section id="tabpanel_4_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class ParallelCounterSpec : ParallelSpecification&lt;ThreadSafeCounter, CounterState&gt;
{
    // Starting state
    public override CounterState InitialState =&gt; 
        new() { CurrentCount = Var.Symbolic(0) };
    
    // Length of sequential prefix (0-3 operations)
    public override Range&lt;int&gt; PrefixRange =&gt; Range.Linear(0, 3);
    
    // Length of each parallel branch (1-5 operations each)
    public override Range&lt;int&gt; BranchRange =&gt; Range.Linear(1, 5);
    
    // Commands that can run in parallel
    public override ICommand&lt;ThreadSafeCounter, CounterState&gt;[] Commands =&gt; 
        [
            new IncrementCommand(),
            new DecrementCommand(),
            new GetCommand()
        ];
}
</code></pre>
</section>
</div>
<h3 id="running-parallel-tests">Running Parallel Tests</h3>
<div class="tabGroup" id="tabgroup_5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_5_fsharp" role="tab" aria-controls="tabpanel_5_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_5_csharp" role="tab" aria-controls="tabpanel_5_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_5_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">[&lt;Fact&gt;]
let ``Counter is thread-safe``() =
    let sut = ThreadSafeCounter()
    ParallelCounterSpec().ToProperty(sut).Check()
</code></pre>
</section>
<section id="tabpanel_5_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">[Fact]
public void Counter_IsThreadSafe()
{
    var sut = new ThreadSafeCounter();
    new ParallelCounterSpec().ToProperty(sut).Check();
}
</code></pre>
</section>
</div>
<h3 id="important-sharing-the-sut">Important: Sharing the SUT</h3>
<p><strong>The same SUT instance is intentionally shared between parallel branches.</strong> This is not a bug - it's the whole point!</p>
<p>We <em>want</em> operations to interfere with each other because we're testing whether the system handles concurrent access correctly. If the system is properly thread-safe, all results will be linearizable. If it has concurrency bugs, some test runs will produce results that can't be explained by any sequential ordering.</p>
<h3 id="writing-commands-for-parallel-testing">Writing Commands for Parallel Testing</h3>
<p>When writing commands for parallel testing, remember:</p>
<ol>
<li><strong>Preconditions and Require</strong> still check the model state</li>
<li><strong>Ensure</strong> should verify weak postconditions—linearizability checking handles the strong guarantees</li>
<li>Return values matter—the framework uses them to verify linearizability</li>
</ol>
<p>Example of a weak postcondition in parallel context:</p>
<div class="tabGroup" id="tabgroup_6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_6_fsharp" role="tab" aria-controls="tabpanel_6_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_6_csharp" role="tab" aria-controls="tabpanel_6_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_6_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">type IncrementCommand() =
    inherit Command&lt;ThreadSafeCounter, CounterState, unit, int&gt;()
    
    override _.Name = &quot;Increment&quot;
    override _.Precondition(state) = true
    override _.Execute(counter, env, state, input) = 
        Task.FromResult(counter.Increment())
    override _.Generate(state) = Gen.constant ()
    override _.Update(state, input, outputVar) = { CurrentCount = outputVar }
    
    // Weak postcondition: we can't assert the exact value
    // Linearizability checking verifies the sequence is valid
    override _.Ensure(env, oldState, newState, input, result) =
        result &gt; 0  // After increment, should be positive
</code></pre>
</section>
<section id="tabpanel_6_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class IncrementCommand : Command&lt;ThreadSafeCounter, CounterState, NoInput, int&gt;
{
    public override string Name =&gt; &quot;Increment&quot;;
    public override bool Precondition(CounterState state) =&gt; true;
    
    public override Task&lt;int&gt; Execute(ThreadSafeCounter sut, Env env, CounterState state, NoInput input) =&gt;
        Task.FromResult(sut.Increment());
    
    public override Gen&lt;NoInput&gt; Generate(CounterState state) =&gt; 
        Gen.Constant(NoInput.Value);
    
    public override CounterState Update(CounterState state, NoInput input, Var&lt;int&gt; outputVar) =&gt;
        state with { CurrentCount = outputVar };
    
    // Weak postcondition: we can't assert the exact value
    // Linearizability checking verifies the sequence is valid
    public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoInput input, int result) =&gt;
        result &gt; 0;  // After increment, should be positive
}
</code></pre>
</section>
</div>
<h3 id="setup-and-cleanup-in-parallel-tests">Setup and Cleanup in Parallel Tests</h3>
<p>Parallel specifications also support setup and cleanup:</p>
<div class="tabGroup" id="tabgroup_7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_7_fsharp" role="tab" aria-controls="tabpanel_7_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_7_csharp" role="tab" aria-controls="tabpanel_7_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_7_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">type ParallelCounterSpec() =
    inherit ParallelSpecification&lt;ThreadSafeCounter, CounterState&gt;()
    
    override _.InitialState = { CurrentCount = Var.symbolic 0 }
    override _.PrefixRange = Range.linear 0 3
    override _.BranchRange = Range.linear 1 5
    
    // Setup runs BEFORE prefix and parallel branches
    override _.SetupCommands = [|
        InitializeCommand()
    |]
    
    override _.Commands = [|
        IncrementCommand()
        DecrementCommand()
    |]
    
    // Cleanup runs AFTER parallel branches complete
    override _.CleanupCommands = [|
        ResetCommand()
    |]
</code></pre>
</section>
<section id="tabpanel_7_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public class ParallelCounterSpec : ParallelSpecification&lt;ThreadSafeCounter, CounterState&gt;
{
    public override CounterState InitialState =&gt; 
        new() { CurrentCount = Var.Symbolic(0) };
    
    public override Range&lt;int&gt; PrefixRange =&gt; Range.Linear(0, 3);
    public override Range&lt;int&gt; BranchRange =&gt; Range.Linear(1, 5);
    
    // Setup runs BEFORE prefix and parallel branches
    public override ICommand&lt;ThreadSafeCounter, CounterState&gt;[] SetupCommands =&gt;
        [ new InitializeCommand() ];
    
    public override ICommand&lt;ThreadSafeCounter, CounterState&gt;[] Commands =&gt; 
        [
            new IncrementCommand(),
            new DecrementCommand()
        ];
    
    // Cleanup runs AFTER parallel branches complete
    public override ICommand&lt;ThreadSafeCounter, CounterState&gt;[] CleanupCommands =&gt; 
        [ new ResetCommand() ];
}
</code></pre>
</section>
</div>

<p><strong>Note:</strong> Cleanup is generated using the state <strong>after the prefix</strong> (before parallel execution), since the parallel branches can't be used to predict a single final state. But it is <strong>executed</strong> at the end of the whole sequence.</p>
<h2 id="using-fresh-suts">Using Fresh SUTs</h2>
<p>Instead of creating the SUT yourself and passing it to the specification, you can provide a factory function that creates a fresh SUT for each test run:</p>
<div class="tabGroup" id="tabgroup_8">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_8_fsharp" role="tab" aria-controls="tabpanel_8_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_8_csharp" role="tab" aria-controls="tabpanel_8_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_8_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">[&lt;Fact&gt;]
let ``Counter test with fresh SUT``() =
    // Factory creates a new Counter for each test
    let createSut() = Counter()
    
    CounterSpec().ToPropertyWith(createSut).Check()
</code></pre>
</section>
<section id="tabpanel_8_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">[Fact]
public void Counter_TestWithFreshSUT()
{
    // Factory creates a new Counter for each test
    Func&lt;Counter&gt; createSut = () =&gt; new Counter();
    
    new CounterSpec().ToPropertyWith(createSut).Check();
}
</code></pre>
</section>
</div>

<p>This approach ensures test isolation—each test run gets a completely fresh system.</p>
<h2 id="summary">Summary</h2>
<p><strong>Sequential Specifications:</strong></p>
<ul>
<li>Test operations running one after another</li>
<li>Use <code>SequentialSpecification&lt;TSystem, TState&gt;</code></li>
<li>Define <code>InitialState</code>, <code>Range</code>, and <code>Commands</code></li>
<li>Optionally add <code>SetupCommands</code> and <code>CleanupCommands</code></li>
</ul>
<p><strong>Parallel Specifications:</strong></p>
<ul>
<li>Test concurrent operations for linearizability</li>
<li>Use <code>ParallelSpecification&lt;TSystem, TState&gt;</code></li>
<li>Define <code>InitialState</code>, <code>PrefixRange</code>, <code>BranchRange</code>, and <code>Commands</code></li>
<li>The same SUT is intentionally shared between parallel branches</li>
<li>Linearizability checking verifies results match some sequential interleaving</li>
<li>Optionally add <code>SetupCommands</code> and <code>CleanupCommands</code></li>
</ul>
<p>Both specifications provide:</p>
<ul>
<li>Automatic shrinking of test sequences</li>
<li>Setup/cleanup command support</li>
<li>Clear failure reporting</li>
<li>Integration with property-based testing frameworks</li>
</ul>

</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
