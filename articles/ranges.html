<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Understanding Ranges | Hedgehog .NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Understanding Ranges | Hedgehog .NET ">
      
      
      <link rel="icon" href="../images/favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/hedgehogqa/fsharp-hedgehog/blob/master/docs/articles/ranges.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Hedgehog .NET">
            Hedgehog .NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="">
<h1 id="understanding-ranges">Understanding Ranges</h1>

<p>Ranges control how Hedgehog generates values and are crucial for effective property-based testing. Choosing the right range type can mean the difference between tests that find bugs and tests that miss edge cases.</p>
<h2 id="what-are-ranges">What Are Ranges?</h2>
<p>A <strong>Range</strong> specifies the bounds within which a generator produces values. But ranges do more than just set minimum and maximum values—they control <em>how</em> the generator explores the value space as tests progress.</p>
<p>Hedgehog runs tests with a <strong>Size</strong> parameter that starts at 1 and increases to 99, then cycles back. Different range types use this Size parameter differently to control value generation.</p>
<h2 id="the-three-core-range-types">The Three Core Range Types</h2>
<h3 id="constant-ranges">Constant Ranges</h3>
<p><strong>What they do</strong>: Generate values uniformly across the entire range, unaffected by the Size parameter.</p>
<p><strong>When to use</strong>:</p>
<ul>
<li>Small ranges where you want full coverage (e.g., 0-10)</li>
<li>Critical edge cases that must be tested at all sizes</li>
<li>When the range is already appropriately scoped</li>
</ul>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>✅ Tests boundary values at all sizes</li>
<li>✅ Uniform distribution across the range</li>
<li>❌ Can miss patterns in large ranges</li>
<li>❌ No gradual exploration of the value space</li>
</ul>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_fsharp" role="tab" aria-controls="tabpanel_1_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_csharp" role="tab" aria-controls="tabpanel_1_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_1_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">open Hedgehog
open Hedgehog.FSharp

// Always generates values between 0-100, regardless of test size
Gen.int32 (Range.constant 0 100)

// Always generates lists with 5-10 elements
Gen.list (Range.constant 5 10) Gen.alpha
</code></pre>
</section>
<section id="tabpanel_1_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">using Hedgehog;
using Hedgehog.Linq;

// Always generates values between 0-100, regardless of test size
Gen.Int32(Range.Constant(0, 100));

// Always generates lists with 5-10 elements
Gen.Alpha.List(Range.Constant(5, 10));
</code></pre>
</section>
</div>

<p><strong>Example Use Case</strong>: Testing a function that works with percentages (0-100) or small counts.</p>
<h3 id="linear-ranges">Linear Ranges</h3>
<p><strong>What they do</strong>: Scale the range bounds <em>linearly</em> with the Size parameter. At Size 1, generates values near the origin; at Size 99, generates values near the bounds.</p>
<p><strong>When to use</strong>:</p>
<ul>
<li>When you want gradual, predictable exploration of the value space</li>
<li>When the range is small enough that skipping the first ~1% won't miss critical values</li>
<li>When you control the origin point with <code>linearFrom</code></li>
</ul>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>⚠️ <strong>At Size 1, bounds are only ~1% of the full range</strong> (e.g., bounds 0-10 for a range of 0-1000)</li>
<li>⚠️ <strong>Origin affects the bounds</strong> - use <code>linearFrom</code> to control where small sizes start</li>
<li>✅ Gradual, predictable scaling</li>
<li>❌ May miss critical edge cases in large ranges (takes many iterations to reach upper bound)</li>
<li>❌ Poor for ranges where you need to test boundary values early</li>
</ul>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_fsharp" role="tab" aria-controls="tabpanel_2_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_csharp" role="tab" aria-controls="tabpanel_2_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_2_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">open Hedgehog
open Hedgehog.FSharp

// Scales linearly from 0 to 1000
// Size 1:  bounds (0, ~10) - generates random values like 0, 4, 7, 10
// Size 50: bounds (0, ~505)
// Size 99: bounds (0, 1000)
Gen.int32 (Range.linear 0 1000)

// Scales from origin=0, range 0-1000
// Size 1: near 0
// Size 99: ~1000
Gen.int32 (Range.linearFrom 0 0 1000)
</code></pre>
</section>
<section id="tabpanel_2_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">using Hedgehog;
using Hedgehog.Linq;

// Scales linearly from 0 to 1000
// Size 1:  bounds (0, ~10) - generates random values like 0, 4, 7, 10
// Size 50: bounds (0, ~505)
// Size 99: bounds (0, 1000)
Gen.Int32(Range.LinearInt32(0, 1000));

// Scales from origin=0, range 0-1000
// Size 1: near 0
// Size 99: ~1000
Gen.Int32(Range.LinearFromInt32(0, 0, 1000));
</code></pre>
</section>
</div>

<p><strong>Example Use Case</strong>: Testing array indices (0-1000), moderately-sized counts, or when you control the origin with <code>linearFrom</code>.</p>
<h3 id="exponential-ranges">Exponential Ranges</h3>
<p><strong>What they do</strong>: Scale the range bounds <em>exponentially</em> with the Size parameter. Start very close to the origin and grow exponentially toward the bounds.</p>
<p><strong>When to use</strong>:</p>
<ul>
<li><strong>Large ranges</strong> (Int32.MaxValue, Int64.MaxValue, etc.)</li>
<li>When boundary values (especially small ones) are critical</li>
<li>When you need both edge cases and large values</li>
</ul>
<p><strong>Characteristics</strong>:</p>
<ul>
<li>✅ <strong>Tests boundary values</strong> at small sizes</li>
<li>✅ Perfect for huge ranges like Int32.MaxValue</li>
<li>✅ Explores both edge cases and large values effectively</li>
<li>✅ Reaches the maximum bound at Size 99</li>
</ul>
<div class="tabGroup" id="tabgroup_3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_3_fsharp" role="tab" aria-controls="tabpanel_3_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_3_csharp" role="tab" aria-controls="tabpanel_3_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_3_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">open Hedgehog
open Hedgehog.FSharp

// Exponential scaling from 0 to Int32.MaxValue
// Size 0:  0
// Size 1:  ~0 (very small)
// Size 10: ~2
// Size 50: ~46,340
// Size 99: 2,147,483,647 (Int32.MaxValue)
Gen.int32 (Range.exponential 0 System.Int32.MaxValue)

// From origin=1
Gen.int32 (Range.exponentialFrom 1 1 System.Int32.MaxValue)
</code></pre>
</section>
<section id="tabpanel_3_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">using Hedgehog;
using Hedgehog.Linq;

// Exponential scaling from 0 to Int32.MaxValue
// Size 0:  0
// Size 1:  ~0 (very small)
// Size 10: ~2
// Size 50: ~46,340
// Size 99: 2,147,483,647 (Int32.MaxValue)
Gen.Int32(Range.ExponentialInt32(0, int.MaxValue));

// From origin=1
Gen.Int32(Range.ExponentialFromInt32(1, 1, int.MaxValue));
</code></pre>
</section>
</div>

<p><strong>Example Use Case</strong>: Testing with any integer, testing with very large collections, performance testing.</p>
<h2 id="the-boundary-value-problem">The Boundary Value Problem</h2>
<p><strong>Critical Insight</strong>: When using <code>linear</code> over very large ranges, <strong>boundary values are only tested at very small sizes</strong> where they're less likely to be generated.</p>
<h3 id="the-problem">The Problem</h3>
<p>Consider this common pattern:</p>
<div class="tabGroup" id="tabgroup_4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_4_fsharp" role="tab" aria-controls="tabpanel_4_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_4_csharp" role="tab" aria-controls="tabpanel_4_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_4_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">// This looks reasonable but has a problem!
Gen.int32 (Range.linear 0 System.Int32.MaxValue)
</code></pre>
</section>
<section id="tabpanel_4_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// This looks reasonable but has a problem!
Gen.Int32(Range.LinearInt32(0, int.MaxValue))
</code></pre>
</section>
</div>

<p><strong>What actually happens</strong>:</p>
<table>
<thead>
<tr>
<th>Size</th>
<th>Bounds</th>
<th>Issue</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>(0, ~21,691,854)</td>
<td>Upper bound already in millions!</td>
</tr>
<tr>
<td>10</td>
<td>(0, ~216,918,546)</td>
<td></td>
</tr>
<tr>
<td>50</td>
<td>(0, ~1,084,592,732)</td>
<td></td>
</tr>
<tr>
<td>99</td>
<td>(0, 2,147,483,647)</td>
<td>Only reaches max at size 99</td>
</tr>
</tbody>
</table>
<p><strong>At Size 1, while bounds include 0-21M, small values like 0-1000 are rare</strong> - only a ~0.005% chance of being picked!</p>
<h3 id="the-solution-use-exponential-for-large-ranges">The Solution: Use Exponential for Large Ranges</h3>
<div class="tabGroup" id="tabgroup_5">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_5_fsharp" role="tab" aria-controls="tabpanel_5_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_5_csharp" role="tab" aria-controls="tabpanel_5_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_5_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">// ✅ Correctly tests boundary values
Gen.int32 (Range.exponential 0 System.Int32.MaxValue)
</code></pre>
</section>
<section id="tabpanel_5_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// ✅ Correctly tests boundary values
Gen.Int32(Range.ExponentialInt32(0, int.MaxValue))
</code></pre>
</section>
</div>

<p><strong>What actually happens</strong>:</p>
<table>
<thead>
<tr>
<th>Size</th>
<th>Bounds</th>
<th>Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(0, 0)</td>
<td>✅ Tests exact boundary</td>
</tr>
<tr>
<td>1</td>
<td>(0, ~1)</td>
<td>✅ Tests small values</td>
</tr>
<tr>
<td>10</td>
<td>(0, ~2)</td>
<td>✅ Tests edge cases</td>
</tr>
<tr>
<td>50</td>
<td>(0, ~46,340)</td>
<td>✅ Tests medium values</td>
</tr>
<tr>
<td>99</td>
<td>(0, 2,147,483,647)</td>
<td>✅ Tests maximum</td>
</tr>
</tbody>
</table>
<h2 id="quick-reference-guide">Quick Reference Guide</h2>
<p>Choose based on <strong>what matters for your domain</strong>, not just the size of the range:</p>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Recommended Range</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Small range (0-100)</td>
<td><code>constant</code> or <code>linear</code></td>
<td>Range is small enough that linear won't skip important values</td>
</tr>
<tr>
<td>Edge cases are critical</td>
<td><strong><code>exponential</code></strong> or <code>constant</code></td>
<td>Tests boundary values (0, 1, -1, etc.) at small sizes</td>
</tr>
<tr>
<td>Uniform distribution needed</td>
<td><code>linear</code> (with appropriate size)</td>
<td>Spreads values evenly across the range</td>
</tr>
<tr>
<td>Very large range (Int32, Int64)</td>
<td><strong><code>exponential</code></strong></td>
<td>Linear will skip millions of values near the origin</td>
</tr>
<tr>
<td>Need specific start point</td>
<td><code>linearFrom</code> or <code>exponentialFrom</code></td>
<td>Control where shrinking targets and small sizes start</td>
</tr>
<tr>
<td>Fixed size collections</td>
<td><code>constant</code> or <code>singleton</code></td>
<td>Size shouldn't vary with test iterations</td>
</tr>
</tbody>
</table>
<p><strong>Key Insight</strong>: The question isn't &quot;how big is my range?&quot; but &quot;<strong>will linear skip values that could expose bugs?</strong>&quot;</p>
<p>For a range like 0-10,000:</p>
<ul>
<li><code>linear</code> at Size 1 has bounds (0, ~101) - small values possible but less likely as range grows</li>
<li><code>exponential</code> at Size 1 has bounds (0, ~1) - heavily focused on small values</li>
<li>If bugs are likely in 0-10 (empty, minimal values, off-by-one): use <strong>exponential</strong></li>
<li>If testing the full range gradually is more important: <strong>linear is fine</strong></li>
</ul>
<h2 id="common-patterns-and-examples">Common Patterns and Examples</h2>
<h3 id="testing-positive-integers">Testing Positive Integers</h3>
<p>When you need positive integers (&gt; 0), use <code>linearFrom</code> or <code>exponentialFrom</code> to set the origin:</p>
<div class="tabGroup" id="tabgroup_6">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_6_fsharp" role="tab" aria-controls="tabpanel_6_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_6_csharp" role="tab" aria-controls="tabpanel_6_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_6_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">// ✅ Starts at 1, scales to Int32.MaxValue
Gen.int32 (Range.linearFrom 1 1 System.Int32.MaxValue)

// ✅ Better for very large ranges
Gen.int32 (Range.exponentialFrom 1 1 System.Int32.MaxValue)
</code></pre>
</section>
<section id="tabpanel_6_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// ✅ Starts at 1, scales to int.MaxValue
Gen.Int32(Range.LinearFromInt32(1, 1, int.MaxValue));

// ✅ Better for very large ranges
Gen.Int32(Range.ExponentialFromInt32(1, 1, int.MaxValue));
</code></pre>
</section>
</div>

<p>This is exactly what the <code>[PositiveInt]</code> attribute does in Hedgehog.Xunit.</p>
<h3 id="testing-collection-sizes">Testing Collection Sizes</h3>
<div class="tabGroup" id="tabgroup_7">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_7_fsharp" role="tab" aria-controls="tabpanel_7_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_7_csharp" role="tab" aria-controls="tabpanel_7_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_7_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">// Small lists with gradual growth
Gen.list (Range.linear 0 20) Gen.alpha

// Can test up to very large lists
Gen.list (Range.exponential 0 10000) Gen.int32

// Fixed small size for focused testing
Gen.list (Range.constant 5 10) Gen.bool
</code></pre>
</section>
<section id="tabpanel_7_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// Small lists with gradual growth
Gen.Alpha.List(Range.LinearInt32(0, 20));

// Can test up to very large lists
Gen.Int32(Range.ConstantBoundedInt32()).List(Range.ExponentialInt32(0, 10000));

// Fixed small size for focused testing
Gen.Bool.List(Range.Constant(5, 10));
</code></pre>
</section>
</div>
<h3 id="testing-with-bounded-types">Testing with Bounded Types</h3>
<p>For types with natural bounds (bytes, shorts, etc.), use <code>exponentialBounded</code>:</p>
<div class="tabGroup" id="tabgroup_8">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_8_fsharp" role="tab" aria-controls="tabpanel_8_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_8_csharp" role="tab" aria-controls="tabpanel_8_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_8_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">// Automatically uses 0 to Byte.MaxValue (255)
Gen.byte (Range.exponentialBounded ())

// Automatically uses Int16.MinValue to Int16.MaxValue
Gen.int16 (Range.exponentialBounded ())
</code></pre>
</section>
<section id="tabpanel_8_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">// Automatically uses 0 to byte.MaxValue (255)
Gen.Byte(Range.ExponentialBoundedByte());

// Automatically uses short.MinValue to short.MaxValue
Gen.Int16(Range.ExponentialBoundedInt16());
</code></pre>
</section>
</div>
<h2 id="how-size-affects-test-execution">How Size Affects Test Execution</h2>
<p>Understanding how the Size parameter works helps you choose the right range:</p>
<pre><code>Test 1:  Size = 1
Test 2:  Size = 2
Test 3:  Size = 3
...
Test 99: Size = 99
Test 100: Size = 100
Test 101: Size = 1   (cycles back)
Test 102: Size = 2
...
</code></pre>
<p><strong>Note</strong>: Size 0 is used internally for shrinking but is <strong>not used</strong> in the main test loop, which starts at Size 1.</p>
<h3 id="scaling-formulas">Scaling Formulas</h3>
<p><strong>Linear</strong>:</p>
<pre><code>value = origin + ((bound - origin) × size) / 99
</code></pre>
<p><strong>Exponential</strong>:</p>
<pre><code>diff = (((|bound - origin| + 1) ^ (size / 99)) - 1) × sign(bound - origin)
value = origin + diff
</code></pre>
<p><strong>Constant</strong>:</p>
<pre><code>value = random between lowerBound and upperBound (ignores size)
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="-do">✅ Do</h3>
<ul>
<li><strong>Use exponential for large ranges</strong> (Int32, Int64)</li>
<li><strong>Use linearFrom to control the starting point</strong> when the origin matters</li>
<li><strong>Use constant for small ranges</strong> where full coverage is needed</li>
<li><strong>Test your assumptions</strong> about what values are being generated</li>
<li><strong>Consider boundary values</strong> when choosing ranges</li>
</ul>
<h3 id="-dont">❌ Don't</h3>
<ul>
<li><strong>Don't use linear over huge ranges</strong> (you'll miss edge cases)</li>
<li><strong>Don't assume Size 0 is tested</strong> (it starts at 1)</li>
<li><strong>Don't use unbounded ranges</strong> without understanding the implications</li>
<li><strong>Don't forget that linear doesn't start at the lower bound</strong> (use linearFrom instead)</li>
</ul>
<h2 id="debugging-range-behavior">Debugging Range Behavior</h2>
<p>If you're unsure what values a range is producing, you can sample it:</p>
<div class="tabGroup" id="tabgroup_9">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_9_fsharp" role="tab" aria-controls="tabpanel_9_fsharp" data-tab="fsharp" tabindex="0" aria-selected="true">F#</a>
</li>
<li role="presentation">
<a href="#tabpanel_9_csharp" role="tab" aria-controls="tabpanel_9_csharp" data-tab="csharp" tabindex="-1">C#</a>
</li>
</ul>
<section id="tabpanel_9_fsharp" role="tabpanel" data-tab="fsharp">

<pre><code class="lang-fsharp">open Hedgehog
open Hedgehog.FSharp

// See what values are generated
Range.exponential 0 System.Int32.MaxValue
|&gt; Gen.int32
|&gt; Gen.sampleFrom 1 20  // 20 samples statring from size 1
// Output: [0; 0; 1; 1; 2; 1; 4; 5; 4; 0; 8; 1; 5; 17; 12; 20; 18; 48; 60; 22] - tests edge cases!

// Compare linear vs exponential
Range.linear 0 1000
|&gt; Gen.int32
|&gt; Gen.sampleFrom 1 20 
// Output: [4; 12; 6; 20; 39; 20; 27; 3; 0; 52; 70; 77; 100; 137; 140; 66; 42; 27; 3; 194]

Range.exponential 0 1000
|&gt; Gen.int32
|&gt; Gen.sampleFrom 1 20 
// Output: [0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 0; 1; 1; 1; 1; 2; 3; 3; 0] - tests edge cases!
</code></pre>
</section>
<section id="tabpanel_9_csharp" role="tabpanel" data-tab="csharp" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">using Hedgehog;
using Hedgehog.Linq;

// See what values are generated
Gen.Int32(Range.ExponentialInt32(0, int.MaxValue)) 
   .SampleFrom(size: 1, count: 20);
// Output: [0, 0, 1, 1, 2, 1, 4, 5, 4, 0, 8, 1, 5, 17, 12, 20, 18, 48, 60, 22] - tests edge cases!

// Compare linear vs exponential
Gen.Int32(Range.LinearInt32(0, 1000))
   .SampleFrom(size: 1, count: 20);
// Output: [4, 12, 6, 20, 39, 20, 27, 3, 0, 52, 70, 77, 100, 137, 140, 66, 42, 27, 3, 194]

</code></pre>
</section>
</div>
<h2 id="summary">Summary</h2>
<p>Choosing the right range is crucial for effective property-based testing:</p>
<ul>
<li><strong>Constant</strong>: Full range at all sizes, best when uniform distribution matters more than gradual scaling</li>
<li><strong>Linear</strong>: Gradual scaling, good when ~1% skip at small sizes won't miss bugs</li>
<li><strong>Exponential</strong>: Exponential scaling, <strong>best when edge cases near the origin are critical</strong></li>
</ul>
<p><strong>The decision isn't about the range size—it's about your domain</strong>:</p>
<ul>
<li>Are bugs likely near 0, 1, empty, minimal values? → <strong>Exponential</strong></li>
<li>Does skipping the first 1% of your range matter? → <strong>Exponential</strong> or <strong>Constant</strong></li>
<li>Is uniform distribution more important than edge cases? → <strong>Linear</strong> or <strong>Constant</strong></li>
</ul>
<p>When in doubt for large ranges (like Int32.MaxValue), <strong>use exponential</strong>—it's safer because it ensures boundary value coverage.</p>

</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
