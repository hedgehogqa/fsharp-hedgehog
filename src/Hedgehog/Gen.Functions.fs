namespace Hedgehog.FSharp

open Hedgehog

[<AutoOpen>]
module GenFunctions =

    [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    [<RequireQualifiedAccess>]
    module Gen =

        /// Generates a list using inpGen together with a function that maps each
        /// of the distinct elements in the list to values generated by outGen.
        /// Distinct elements in the input list may map to the same output values.
        /// For example, [2; 3; 2] may map to ['A'; 'B'; 'A'] or ['A'; 'A'; 'A'],
        /// but never ['A'; 'B'; 'C']. The generated function throws if called with
        /// values not present in the input list.
        let withMapTo (outGen : Gen<'b>) (inpGen : Gen<'a list>): Gen<'a list * ('a -> 'b)> =
            gen {
                let! inputs = inpGen
                let inputsDistinct = inputs |> List.distinct
                let! outputs = outGen |> Gen.list (Range.singleton inputsDistinct.Length)
                let inOutMap = List.zip inputsDistinct outputs |> Map.ofList
                return inputs, (fun x -> inOutMap.Item x)
            }

        /// Generates a list using inpGen together with a function that maps each
        /// of the distinct elements in the list to values generated by outGen.
        /// Distinct elements in the input list are guaranteed to map to distinct
        /// output values. For example, [2; 3; 2] may map to ['A'; 'B'; 'A'], but
        /// never ['A'; 'A'; 'A'] or ['A'; 'B'; 'C']. Only use this if the output
        /// space is large enough that the required number of distinct output values
        /// are likely to be generated. The generated function throws if called with
        /// values not present in the input list.
        let withDistinctMapTo (outGen : Gen<'b>) (inpGen : Gen<'a list>): Gen<'a list * ('a -> 'b)> =
            gen {
                let rec distinctOutGen (xs : 'b list) (length : int) : Gen<'b list> =
                    gen {
                        if xs.Length = length then return xs
                        else
                          let! x = outGen |> Gen.notIn xs
                          return! distinctOutGen (x::xs) length
                    }

                let! inputs = inpGen
                let inputsDistinct = inputs |> List.distinct
                let! outputs = distinctOutGen [] inputsDistinct.Length
                let inOutMap = List.zip inputsDistinct outputs |> Map.ofList
                return inputs, (fun x -> inOutMap.Item x)
            }
